/* proxy-compat-disable */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.Engine = {}));
}(this, function (exports) { 'use strict';

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect() {
        // Don't apply polyfill when ProxyCompat is enabled.
        if ('getKey' in Proxy) {
            return false;
        }
        const proxy = new Proxy([3, 4], {});
        const res = [1, 2].concat(proxy);
        return res.length !== 4;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const { isConcatSpreadable } = Symbol;
    const { isArray } = Array;
    const { slice: ArraySlice, unshift: ArrayUnshift, shift: ArrayShift } = Array.prototype;
    function isObject(O) {
        return typeof O === 'object' ? O !== null : typeof O === 'function';
    }
    // https://www.ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable
    function isSpreadable(O) {
        if (!isObject(O)) {
            return false;
        }
        const spreadable = O[isConcatSpreadable];
        return spreadable !== undefined ? Boolean(spreadable) : isArray(O);
    }
    // https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat
    function ArrayConcatPolyfill(..._args) {
        const O = Object(this);
        const A = [];
        let N = 0;
        const items = ArraySlice.call(arguments);
        ArrayUnshift.call(items, O);
        while (items.length) {
            const E = ArrayShift.call(items);
            if (isSpreadable(E)) {
                let k = 0;
                const length = E.length;
                for (k; k < length; k += 1, N += 1) {
                    if (k in E) {
                        const subElement = E[k];
                        A[N] = subElement;
                    }
                }
            }
            else {
                A[N] = E;
                N += 1;
            }
        }
        return A;
    }
    function apply() {
        Array.prototype.concat = ArrayConcatPolyfill;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (detect()) {
        apply();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect$1(propName) {
        return Object.getOwnPropertyDescriptor(Element.prototype, propName) === undefined;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const { freeze, seal, keys, create, assign, defineProperty, getPrototypeOf, setPrototypeOf, getOwnPropertyDescriptor, getOwnPropertyNames, defineProperties, hasOwnProperty, } = Object;
    const { isArray: isArray$1 } = Array;
    const { slice: ArraySlice$1, splice: ArraySplice, unshift: ArrayUnshift$1, indexOf: ArrayIndexOf, push: ArrayPush, map: ArrayMap, join: ArrayJoin, forEach, reduce: ArrayReduce, } = Array.prototype;
    const { replace: StringReplace, toLowerCase: StringToLowerCase, charCodeAt: StringCharCodeAt, slice: StringSlice, } = String.prototype;
    function isUndefined(obj) {
        return obj === undefined;
    }
    function isNull(obj) {
        return obj === null;
    }
    function isTrue(obj) {
        return obj === true;
    }
    function isFalse(obj) {
        return obj === false;
    }
    function isFunction(obj) {
        return typeof obj === 'function';
    }
    function isObject$1(obj) {
        return typeof obj === 'object';
    }
    function isString(obj) {
        return typeof obj === 'string';
    }
    const OtS = {}.toString;
    function toString(obj) {
        if (obj && obj.toString) {
            // Arrays might hold objects with "null" prototype
            // So using Array.prototype.toString directly will cause an error
            // Iterate through all the items and handle individually.
            if (isArray$1(obj)) {
                return ArrayJoin.call(ArrayMap.call(obj, toString), ',');
            }
            return obj.toString();
        }
        else if (typeof obj === 'object') {
            return OtS.call(obj);
        }
        else {
            return obj + emptyString;
        }
    }
    function getPropertyDescriptor(o, p) {
        do {
            const d = getOwnPropertyDescriptor(o, p);
            if (!isUndefined(d)) {
                return d;
            }
            o = getPrototypeOf(o);
        } while (o !== null);
    }
    const emptyString = '';

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const { hasAttribute, getAttribute, setAttribute, setAttributeNS, removeAttribute, removeAttributeNS, } = Element.prototype;
    const tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // this regular expression is used to transform aria props into aria attributes because
    // that doesn't follow the regular transformation process. e.g.: `aria-labeledby` <=> `ariaLabelBy`
    const ARIA_REGEX = /^aria/;
    const nodeToAriaPropertyValuesMap = new WeakMap();
    const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
    const { replace: StringReplace$1, toLowerCase: StringToLowerCase$1 } = String.prototype;
    function getAriaPropertyMap(elm) {
        let map = nodeToAriaPropertyValuesMap.get(elm);
        if (map === undefined) {
            map = {};
            nodeToAriaPropertyValuesMap.set(elm, map);
        }
        return map;
    }
    function getNormalizedAriaPropertyValue(value) {
        return value == null ? null : value + '';
    }
    function createAriaPropertyPropertyDescriptor(propName, attrName) {
        return {
            get() {
                const map = getAriaPropertyMap(this);
                if (hasOwnProperty$1.call(map, propName)) {
                    return map[propName];
                }
                // otherwise just reflect what's in the attribute
                return hasAttribute.call(this, attrName) ? getAttribute.call(this, attrName) : null;
            },
            set(newValue) {
                const normalizedValue = getNormalizedAriaPropertyValue(newValue);
                const map = getAriaPropertyMap(this);
                map[propName] = normalizedValue;
                // reflect into the corresponding attribute
                if (newValue === null) {
                    removeAttribute.call(this, attrName);
                }
                else {
                    setAttribute.call(this, attrName, newValue);
                }
            },
            configurable: true,
            enumerable: true,
        };
    }
    function patch(propName) {
        // Typescript is inferring the wrong function type for this particular
        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        const replaced = StringReplace$1.call(propName, ARIA_REGEX, 'aria-');
        const attrName = StringToLowerCase$1.call(replaced);
        const descriptor = createAriaPropertyPropertyDescriptor(propName, attrName);
        Object.defineProperty(Element.prototype, propName, descriptor);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Global Aria and Role Properties derived from ARIA and Role Attributes.
    // https://wicg.github.io/aom/spec/aria-reflection.html
    const ElementPrototypeAriaPropertyNames = [
        'ariaAutoComplete',
        'ariaChecked',
        'ariaCurrent',
        'ariaDisabled',
        'ariaExpanded',
        'ariaHasPopup',
        'ariaHidden',
        'ariaInvalid',
        'ariaLabel',
        'ariaLevel',
        'ariaMultiLine',
        'ariaMultiSelectable',
        'ariaOrientation',
        'ariaPressed',
        'ariaReadOnly',
        'ariaRequired',
        'ariaSelected',
        'ariaSort',
        'ariaValueMax',
        'ariaValueMin',
        'ariaValueNow',
        'ariaValueText',
        'ariaLive',
        'ariaRelevant',
        'ariaAtomic',
        'ariaBusy',
        'ariaActiveDescendant',
        'ariaControls',
        'ariaDescribedBy',
        'ariaFlowTo',
        'ariaLabelledBy',
        'ariaOwns',
        'ariaPosInSet',
        'ariaSetSize',
        'ariaColCount',
        'ariaColIndex',
        'ariaDetails',
        'ariaErrorMessage',
        'ariaKeyShortcuts',
        'ariaModal',
        'ariaPlaceholder',
        'ariaRoleDescription',
        'ariaRowCount',
        'ariaRowIndex',
        'ariaRowSpan',
        'ariaColSpan',
        'role',
    ];
    /**
     * Note: Attributes aria-dropeffect and aria-grabbed were deprecated in
     * ARIA 1.1 and do not have corresponding IDL attributes.
     */
    for (let i = 0, len = ElementPrototypeAriaPropertyNames.length; i < len; i += 1) {
        const propName = ElementPrototypeAriaPropertyNames[i];
        if (detect$1(propName)) {
            patch(propName);
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const { appendChild, insertBefore, removeChild, replaceChild } = Node.prototype;
    const parentNodeGetter = getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;
    const parentElementGetter = hasOwnProperty.call(Node.prototype, 'parentElement')
        ? getOwnPropertyDescriptor(Node.prototype, 'parentElement').get
        : getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get; // IE11

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const ShadowRootHostGetter = getOwnPropertyDescriptor(window.ShadowRoot.prototype, 'host').get;
    const ShadowRootInnerHTMLSetter = getOwnPropertyDescriptor(window.ShadowRoot.prototype, 'innerHTML').set;
    const dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent; // IE11

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */
    const hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
    function createFieldName(key) {
        // @ts-ignore: using a string as a symbol for perf reasons
        return hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${key}$$`;
    }
    function setInternalField(o, fieldName, value) {
        // TODO: #1299 - use a weak map instead
        defineProperty(o, fieldName, {
            value,
        });
    }
    function getInternalField(o, fieldName) {
        return o[fieldName];
    }
    /**
     * Store fields that should be hidden from outside world
     * hiddenFieldsMap is a WeakMap.
     * It stores a hash of any given objects associative relationships.
     * The hash uses the fieldName as the key, the value represents the other end of the association.
     *
     * For example, if the association is
     *              ViewModel
     * Component-A --------------> VM-1
     * then,
     * hiddenFieldsMap : (Component-A, { Symbol(ViewModel) : VM-1 })
     *
     */
    const hiddenFieldsMap = new WeakMap();
    const setHiddenField = hasNativeSymbolsSupport
        ? (o, fieldName, value) => {
            let valuesByField = hiddenFieldsMap.get(o);
            if (isUndefined(valuesByField)) {
                valuesByField = create(null);
                hiddenFieldsMap.set(o, valuesByField);
            }
            valuesByField[fieldName] = value;
        }
        : setInternalField; // Fall back to symbol based approach in compat mode
    const getHiddenField = hasNativeSymbolsSupport
        ? (o, fieldName) => {
            const valuesByField = hiddenFieldsMap.get(o);
            return !isUndefined(valuesByField) && valuesByField[fieldName];
        }
        : getInternalField; // Fall back to symbol based approach in compat mode

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // These properties get added to LWCElement.prototype publicProps automatically
    const defaultDefHTMLPropertyNames = [
        'accessKey',
        'dir',
        'draggable',
        'hidden',
        'id',
        'lang',
        'tabIndex',
        'title',
    ];
    // Few more exceptions that are using the attribute name to match the property in lowercase.
    // this list was compiled from https://msdn.microsoft.com/en-us/library/ms533062(v=vs.85).aspx
    // and https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
    // Note: this list most be in sync with the compiler as well.
    const HTMLPropertyNamesWithLowercasedReflectiveAttributes = [
        'accessKey',
        'readOnly',
        'tabIndex',
        'bgColor',
        'colSpan',
        'rowSpan',
        'contentEditable',
        'dateTime',
        'formAction',
        'isMap',
        'maxLength',
        'useMap',
    ];
    function offsetPropertyErrorMessage(name) {
        return `Using the \`${name}\` property is an anti-pattern because it rounds the value to an integer. Instead, use the \`getBoundingClientRect\` method to obtain fractional values for the size of an element and its position relative to the viewport.`;
    }
    // Global HTML Attributes & Properties
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
    const globalHTMLProperties = assign(create(null), {
        accessKey: {
            attribute: 'accesskey',
        },
        accessKeyLabel: {
            readOnly: true,
        },
        className: {
            attribute: 'class',
            error: 'Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead.',
        },
        contentEditable: {
            attribute: 'contenteditable',
        },
        dataset: {
            readOnly: true,
            error: "Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead.",
        },
        dir: {
            attribute: 'dir',
        },
        draggable: {
            attribute: 'draggable',
        },
        dropzone: {
            attribute: 'dropzone',
            readOnly: true,
        },
        hidden: {
            attribute: 'hidden',
        },
        id: {
            attribute: 'id',
        },
        inputMode: {
            attribute: 'inputmode',
        },
        lang: {
            attribute: 'lang',
        },
        slot: {
            attribute: 'slot',
            error: 'Using the `slot` property is an anti-pattern.',
        },
        spellcheck: {
            attribute: 'spellcheck',
        },
        style: {
            attribute: 'style',
        },
        tabIndex: {
            attribute: 'tabindex',
        },
        title: {
            attribute: 'title',
        },
        translate: {
            attribute: 'translate',
        },
        // additional "global attributes" that are not present in the link above.
        isContentEditable: {
            readOnly: true,
        },
        offsetHeight: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetHeight'),
        },
        offsetLeft: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetLeft'),
        },
        offsetParent: {
            readOnly: true,
        },
        offsetTop: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetTop'),
        },
        offsetWidth: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetWidth'),
        },
        role: {
            attribute: 'role',
        },
    });
    const AttrNameToPropNameMap = create(null);
    const PropNameToAttrNameMap = create(null);
    // Synthetic creation of all AOM property descriptors for Custom Elements
    forEach.call(ElementPrototypeAriaPropertyNames, (propName) => {
        // Typescript is inferring the wrong function type for this particular
        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        const attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, 'aria-'));
        AttrNameToPropNameMap[attrName] = propName;
        PropNameToAttrNameMap[propName] = attrName;
    });
    forEach.call(defaultDefHTMLPropertyNames, propName => {
        const attrName = StringToLowerCase.call(propName);
        AttrNameToPropNameMap[attrName] = propName;
        PropNameToAttrNameMap[propName] = attrName;
    });
    forEach.call(HTMLPropertyNamesWithLowercasedReflectiveAttributes, propName => {
        const attrName = StringToLowerCase.call(propName);
        AttrNameToPropNameMap[attrName] = propName;
        PropNameToAttrNameMap[propName] = attrName;
    });
    const CAMEL_REGEX = /-([a-z])/g;
    /**
     * This method maps between attribute names
     * and the corresponding property name.
     */
    function getPropNameFromAttrName(attrName) {
        if (isUndefined(AttrNameToPropNameMap[attrName])) {
            AttrNameToPropNameMap[attrName] = StringReplace.call(attrName, CAMEL_REGEX, (g) => g[1].toUpperCase());
        }
        return AttrNameToPropNameMap[attrName];
    }
    const CAPS_REGEX = /[A-Z]/g;
    /**
     * This method maps between property names
     * and the corresponding attribute name.
     */
    function getAttrNameFromPropName(propName) {
        if (isUndefined(PropNameToAttrNameMap[propName])) {
            PropNameToAttrNameMap[propName] = StringReplace.call(propName, CAPS_REGEX, (match) => '-' + match.toLowerCase());
        }
        return PropNameToAttrNameMap[propName];
    }
    let controlledElement = null;
    let controlledAttributeName;
    function isAttributeLocked(elm, attrName) {
        return elm !== controlledElement || attrName !== controlledAttributeName;
    }
    function lockAttribute(_elm, _key) {
        controlledElement = null;
        controlledAttributeName = undefined;
    }
    function unlockAttribute(elm, key) {
        controlledElement = elm;
        controlledAttributeName = key;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    let nextTickCallbackQueue = [];
    const SPACE_CHAR = 32;
    const EmptyObject = seal(create(null));
    const EmptyArray = seal([]);
    const ViewModelReflection = createFieldName('ViewModel');
    function flushCallbackQueue() {
        const callbacks = nextTickCallbackQueue;
        nextTickCallbackQueue = []; // reset to a new queue
        for (let i = 0, len = callbacks.length; i < len; i += 1) {
            callbacks[i]();
        }
    }
    function addCallbackToNextTick(callback) {
        if (nextTickCallbackQueue.length === 0) {
            Promise.resolve().then(flushCallbackQueue);
        }
        ArrayPush.call(nextTickCallbackQueue, callback);
    }
    function isCircularModuleDependency(value) {
        return hasOwnProperty.call(value, '__circular__');
    }
    /**
     * When LWC is used in the context of an Aura application, the compiler produces AMD
     * modules, that doesn't resolve properly circular dependencies between modules. In order
     * to circumvent this issue, the module loader returns a factory with a symbol attached
     * to it.
     *
     * This method returns the resolved value if it received a factory as argument. Otherwise
     * it returns the original value.
     */
    function resolveCircularModuleDependency(fn) {
        return fn();
    }
    const useSyntheticShadow = hasOwnProperty.call(Element.prototype, '$shadowToken$');

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function handleEvent(event, vnode) {
        const { type } = event;
        const { data: { on }, } = vnode;
        const handler = on && on[type];
        // call event handler if exists
        if (handler) {
            handler.call(undefined, event);
        }
    }
    function createListener() {
        return function handler(event) {
            handleEvent(event, handler.vnode);
        };
    }
    function updateAllEventListeners(oldVnode, vnode) {
        if (isUndefined(oldVnode.listener)) {
            createAllEventListeners(vnode);
        }
        else {
            vnode.listener = oldVnode.listener;
            vnode.listener.vnode = vnode;
        }
    }
    function createAllEventListeners(vnode) {
        const { data: { on }, } = vnode;
        if (isUndefined(on)) {
            return;
        }
        const elm = vnode.elm;
        const listener = (vnode.listener = createListener());
        listener.vnode = vnode;
        let name;
        for (name in on) {
            elm.addEventListener(name, listener);
        }
    }
    var modEvents = {
        update: updateAllEventListeners,
        create: createAllEventListeners,
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const xlinkNS = 'http://www.w3.org/1999/xlink';
    const xmlNS = 'http://www.w3.org/XML/1998/namespace';
    const ColonCharCode = 58;
    function updateAttrs(oldVnode, vnode) {
        const { data: { attrs }, } = vnode;
        if (isUndefined(attrs)) {
            return;
        }
        let { data: { attrs: oldAttrs }, } = oldVnode;
        if (oldAttrs === attrs) {
            return;
        }
        const elm = vnode.elm;
        let key;
        oldAttrs = isUndefined(oldAttrs) ? EmptyObject : oldAttrs;
        // update modified attributes, add new attributes
        // this routine is only useful for data-* attributes in all kind of elements
        // and aria-* in standard elements (custom elements will use props for these)
        for (key in attrs) {
            const cur = attrs[key];
            const old = oldAttrs[key];
            if (old !== cur) {
                unlockAttribute(elm, key);
                if (StringCharCodeAt.call(key, 3) === ColonCharCode) {
                    // Assume xml namespace
                    elm.setAttributeNS(xmlNS, key, cur);
                }
                else if (StringCharCodeAt.call(key, 5) === ColonCharCode) {
                    // Assume xlink namespace
                    elm.setAttributeNS(xlinkNS, key, cur);
                }
                else if (isNull(cur)) {
                    elm.removeAttribute(key);
                }
                else {
                    elm.setAttribute(key, cur);
                }
                lockAttribute(elm, key);
            }
        }
    }
    const emptyVNode = { data: {} };
    var modAttrs = {
        create: (vnode) => updateAttrs(emptyVNode, vnode),
        update: updateAttrs,
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This is a descriptor map that contains
     * all standard properties that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base HTML Element and
     * Base Lightning Element should support.
     */
    const HTMLElementOriginalDescriptors = create(null);
    forEach.call(ElementPrototypeAriaPropertyNames, (propName) => {
        // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
        // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.
        const descriptor = getPropertyDescriptor(HTMLElement.prototype, propName);
        if (!isUndefined(descriptor)) {
            HTMLElementOriginalDescriptors[propName] = descriptor;
        }
    });
    forEach.call(defaultDefHTMLPropertyNames, propName => {
        // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
        // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into
        // this category, so, better to be sure.
        const descriptor = getPropertyDescriptor(HTMLElement.prototype, propName);
        if (!isUndefined(descriptor)) {
            HTMLElementOriginalDescriptors[propName] = descriptor;
        }
    });

    /**
     * Copyright (C) 2017 salesforce.com, inc.
     */
    const { isArray: isArray$2 } = Array;
    const { getPrototypeOf: getPrototypeOf$1, create: ObjectCreate, defineProperty: ObjectDefineProperty, defineProperties: ObjectDefineProperties, isExtensible, getOwnPropertyDescriptor: getOwnPropertyDescriptor$1, getOwnPropertyNames: getOwnPropertyNames$1, getOwnPropertySymbols, preventExtensions, hasOwnProperty: hasOwnProperty$2, } = Object;
    const { push: ArrayPush$1, concat: ArrayConcat, map: ArrayMap$1, } = Array.prototype;
    function isUndefined$1(obj) {
        return obj === undefined;
    }
    function isFunction$1(obj) {
        return typeof obj === 'function';
    }
    function isObject$2(obj) {
        return typeof obj === 'object';
    }
    const proxyToValueMap = new WeakMap();
    function registerProxy(proxy, value) {
        proxyToValueMap.set(proxy, value);
    }
    const unwrap = (replicaOrAny) => proxyToValueMap.get(replicaOrAny) || replicaOrAny;
    function wrapValue(membrane, value) {
        return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;
    }
    /**
     * Unwrap property descriptors will set value on original descriptor
     * We only need to unwrap if value is specified
     * @param descriptor external descrpitor provided to define new property on original value
     */
    function unwrapDescriptor(descriptor) {
        if (hasOwnProperty$2.call(descriptor, 'value')) {
            descriptor.value = unwrap(descriptor.value);
        }
        return descriptor;
    }
    function lockShadowTarget(membrane, shadowTarget, originalTarget) {
        const targetKeys = ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));
        targetKeys.forEach((key) => {
            let descriptor = getOwnPropertyDescriptor$1(originalTarget, key);
            // We do not need to wrap the descriptor if configurable
            // Because we can deal with wrapping it when user goes through
            // Get own property descriptor. There is also a chance that this descriptor
            // could change sometime in the future, so we can defer wrapping
            // until we need to
            if (!descriptor.configurable) {
                descriptor = wrapDescriptor(membrane, descriptor, wrapValue);
            }
            ObjectDefineProperty(shadowTarget, key, descriptor);
        });
        preventExtensions(shadowTarget);
    }
    class ReactiveProxyHandler {
        constructor(membrane, value) {
            this.originalTarget = value;
            this.membrane = membrane;
        }
        get(shadowTarget, key) {
            const { originalTarget, membrane } = this;
            const value = originalTarget[key];
            const { valueObserved } = membrane;
            valueObserved(originalTarget, key);
            return membrane.getProxy(value);
        }
        set(shadowTarget, key, value) {
            const { originalTarget, membrane: { valueMutated } } = this;
            const oldValue = originalTarget[key];
            if (oldValue !== value) {
                originalTarget[key] = value;
                valueMutated(originalTarget, key);
            }
            else if (key === 'length' && isArray$2(originalTarget)) {
                // fix for issue #236: push will add the new index, and by the time length
                // is updated, the internal length is already equal to the new length value
                // therefore, the oldValue is equal to the value. This is the forking logic
                // to support this use case.
                valueMutated(originalTarget, key);
            }
            return true;
        }
        deleteProperty(shadowTarget, key) {
            const { originalTarget, membrane: { valueMutated } } = this;
            delete originalTarget[key];
            valueMutated(originalTarget, key);
            return true;
        }
        apply(shadowTarget, thisArg, argArray) {
            /* No op */
        }
        construct(target, argArray, newTarget) {
            /* No op */
        }
        has(shadowTarget, key) {
            const { originalTarget, membrane: { valueObserved } } = this;
            valueObserved(originalTarget, key);
            return key in originalTarget;
        }
        ownKeys(shadowTarget) {
            const { originalTarget } = this;
            return ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));
        }
        isExtensible(shadowTarget) {
            const shadowIsExtensible = isExtensible(shadowTarget);
            if (!shadowIsExtensible) {
                return shadowIsExtensible;
            }
            const { originalTarget, membrane } = this;
            const targetIsExtensible = isExtensible(originalTarget);
            if (!targetIsExtensible) {
                lockShadowTarget(membrane, shadowTarget, originalTarget);
            }
            return targetIsExtensible;
        }
        setPrototypeOf(shadowTarget, prototype) {
        }
        getPrototypeOf(shadowTarget) {
            const { originalTarget } = this;
            return getPrototypeOf$1(originalTarget);
        }
        getOwnPropertyDescriptor(shadowTarget, key) {
            const { originalTarget, membrane } = this;
            const { valueObserved } = this.membrane;
            // keys looked up via hasOwnProperty need to be reactive
            valueObserved(originalTarget, key);
            let desc = getOwnPropertyDescriptor$1(originalTarget, key);
            if (isUndefined$1(desc)) {
                return desc;
            }
            const shadowDescriptor = getOwnPropertyDescriptor$1(shadowTarget, key);
            if (!isUndefined$1(shadowDescriptor)) {
                return shadowDescriptor;
            }
            // Note: by accessing the descriptor, the key is marked as observed
            // but access to the value, setter or getter (if available) cannot observe
            // mutations, just like regular methods, in which case we just do nothing.
            desc = wrapDescriptor(membrane, desc, wrapValue);
            if (!desc.configurable) {
                // If descriptor from original target is not configurable,
                // We must copy the wrapped descriptor over to the shadow target.
                // Otherwise, proxy will throw an invariant error.
                // This is our last chance to lock the value.
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
                ObjectDefineProperty(shadowTarget, key, desc);
            }
            return desc;
        }
        preventExtensions(shadowTarget) {
            const { originalTarget, membrane } = this;
            lockShadowTarget(membrane, shadowTarget, originalTarget);
            preventExtensions(originalTarget);
            return true;
        }
        defineProperty(shadowTarget, key, descriptor) {
            const { originalTarget, membrane } = this;
            const { valueMutated } = membrane;
            const { configurable } = descriptor;
            // We have to check for value in descriptor
            // because Object.freeze(proxy) calls this method
            // with only { configurable: false, writeable: false }
            // Additionally, method will only be called with writeable:false
            // if the descriptor has a value, as opposed to getter/setter
            // So we can just check if writable is present and then see if
            // value is present. This eliminates getter and setter descriptors
            if (hasOwnProperty$2.call(descriptor, 'writable') && !hasOwnProperty$2.call(descriptor, 'value')) {
                const originalDescriptor = getOwnPropertyDescriptor$1(originalTarget, key);
                descriptor.value = originalDescriptor.value;
            }
            ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));
            if (configurable === false) {
                ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));
            }
            valueMutated(originalTarget, key);
            return true;
        }
    }
    function wrapReadOnlyValue(membrane, value) {
        return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;
    }
    class ReadOnlyHandler {
        constructor(membrane, value) {
            this.originalTarget = value;
            this.membrane = membrane;
        }
        get(shadowTarget, key) {
            const { membrane, originalTarget } = this;
            const value = originalTarget[key];
            const { valueObserved } = membrane;
            valueObserved(originalTarget, key);
            return membrane.getReadOnlyProxy(value);
        }
        set(shadowTarget, key, value) {
            return false;
        }
        deleteProperty(shadowTarget, key) {
            return false;
        }
        apply(shadowTarget, thisArg, argArray) {
            /* No op */
        }
        construct(target, argArray, newTarget) {
            /* No op */
        }
        has(shadowTarget, key) {
            const { originalTarget, membrane: { valueObserved } } = this;
            valueObserved(originalTarget, key);
            return key in originalTarget;
        }
        ownKeys(shadowTarget) {
            const { originalTarget } = this;
            return ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));
        }
        setPrototypeOf(shadowTarget, prototype) {
        }
        getOwnPropertyDescriptor(shadowTarget, key) {
            const { originalTarget, membrane } = this;
            const { valueObserved } = membrane;
            // keys looked up via hasOwnProperty need to be reactive
            valueObserved(originalTarget, key);
            let desc = getOwnPropertyDescriptor$1(originalTarget, key);
            if (isUndefined$1(desc)) {
                return desc;
            }
            const shadowDescriptor = getOwnPropertyDescriptor$1(shadowTarget, key);
            if (!isUndefined$1(shadowDescriptor)) {
                return shadowDescriptor;
            }
            // Note: by accessing the descriptor, the key is marked as observed
            // but access to the value or getter (if available) cannot be observed,
            // just like regular methods, in which case we just do nothing.
            desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);
            if (hasOwnProperty$2.call(desc, 'set')) {
                desc.set = undefined; // readOnly membrane does not allow setters
            }
            if (!desc.configurable) {
                // If descriptor from original target is not configurable,
                // We must copy the wrapped descriptor over to the shadow target.
                // Otherwise, proxy will throw an invariant error.
                // This is our last chance to lock the value.
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
                ObjectDefineProperty(shadowTarget, key, desc);
            }
            return desc;
        }
        preventExtensions(shadowTarget) {
            return false;
        }
        defineProperty(shadowTarget, key, descriptor) {
            return false;
        }
    }
    function createShadowTarget(value) {
        let shadowTarget = undefined;
        if (isArray$2(value)) {
            shadowTarget = [];
        }
        else if (isObject$2(value)) {
            shadowTarget = {};
        }
        return shadowTarget;
    }
    const ObjectDotPrototype = Object.prototype;
    function defaultValueIsObservable(value) {
        // intentionally checking for null
        if (value === null) {
            return false;
        }
        // treat all non-object types, including undefined, as non-observable values
        if (typeof value !== 'object') {
            return false;
        }
        if (isArray$2(value)) {
            return true;
        }
        const proto = getPrototypeOf$1(value);
        return (proto === ObjectDotPrototype || proto === null || getPrototypeOf$1(proto) === null);
    }
    const defaultValueObserved = (obj, key) => {
        /* do nothing */
    };
    const defaultValueMutated = (obj, key) => {
        /* do nothing */
    };
    const defaultValueDistortion = (value) => value;
    function wrapDescriptor(membrane, descriptor, getValue) {
        const { set, get } = descriptor;
        if (hasOwnProperty$2.call(descriptor, 'value')) {
            descriptor.value = getValue(membrane, descriptor.value);
        }
        else {
            if (!isUndefined$1(get)) {
                descriptor.get = function () {
                    // invoking the original getter with the original target
                    return getValue(membrane, get.call(unwrap(this)));
                };
            }
            if (!isUndefined$1(set)) {
                descriptor.set = function (value) {
                    // At this point we don't have a clear indication of whether
                    // or not a valid mutation will occur, we don't have the key,
                    // and we are not sure why and how they are invoking this setter.
                    // Nevertheless we preserve the original semantics by invoking the
                    // original setter with the original target and the unwrapped value
                    set.call(unwrap(this), membrane.unwrapProxy(value));
                };
            }
        }
        return descriptor;
    }
    class ReactiveMembrane {
        constructor(options) {
            this.valueDistortion = defaultValueDistortion;
            this.valueMutated = defaultValueMutated;
            this.valueObserved = defaultValueObserved;
            this.valueIsObservable = defaultValueIsObservable;
            this.objectGraph = new WeakMap();
            if (!isUndefined$1(options)) {
                const { valueDistortion, valueMutated, valueObserved, valueIsObservable } = options;
                this.valueDistortion = isFunction$1(valueDistortion) ? valueDistortion : defaultValueDistortion;
                this.valueMutated = isFunction$1(valueMutated) ? valueMutated : defaultValueMutated;
                this.valueObserved = isFunction$1(valueObserved) ? valueObserved : defaultValueObserved;
                this.valueIsObservable = isFunction$1(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;
            }
        }
        getProxy(value) {
            const unwrappedValue = unwrap(value);
            const distorted = this.valueDistortion(unwrappedValue);
            if (this.valueIsObservable(distorted)) {
                const o = this.getReactiveState(unwrappedValue, distorted);
                // when trying to extract the writable version of a readonly
                // we return the readonly.
                return o.readOnly === value ? value : o.reactive;
            }
            return distorted;
        }
        getReadOnlyProxy(value) {
            value = unwrap(value);
            const distorted = this.valueDistortion(value);
            if (this.valueIsObservable(distorted)) {
                return this.getReactiveState(value, distorted).readOnly;
            }
            return distorted;
        }
        unwrapProxy(p) {
            return unwrap(p);
        }
        getReactiveState(value, distortedValue) {
            const { objectGraph, } = this;
            let reactiveState = objectGraph.get(distortedValue);
            if (reactiveState) {
                return reactiveState;
            }
            const membrane = this;
            reactiveState = {
                get reactive() {
                    const reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue);
                    // caching the reactive proxy after the first time it is accessed
                    const proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);
                    registerProxy(proxy, value);
                    ObjectDefineProperty(this, 'reactive', { value: proxy });
                    return proxy;
                },
                get readOnly() {
                    const readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue);
                    // caching the readOnly proxy after the first time it is accessed
                    const proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);
                    registerProxy(proxy, value);
                    ObjectDefineProperty(this, 'readOnly', { value: proxy });
                    return proxy;
                }
            };
            objectGraph.set(distortedValue, reactiveState);
            return reactiveState;
        }
    }
    /** version: 0.26.0 */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const TargetToReactiveRecordMap = new WeakMap();
    function notifyMutation(target, key) {
        const reactiveRecord = TargetToReactiveRecordMap.get(target);
        if (!isUndefined(reactiveRecord)) {
            const value = reactiveRecord[key];
            if (value) {
                const len = value.length;
                for (let i = 0; i < len; i += 1) {
                    const vm = value[i];
                    if (isFalse(vm.isDirty)) {
                        markComponentAsDirty(vm);
                        scheduleRehydration(vm);
                    }
                }
            }
        }
    }
    function observeMutation(target, key) {
        if (isNull(vmBeingRendered)) {
            return; // nothing to subscribe to
        }
        const vm = vmBeingRendered;
        let reactiveRecord = TargetToReactiveRecordMap.get(target);
        if (isUndefined(reactiveRecord)) {
            const newRecord = create(null);
            reactiveRecord = newRecord;
            TargetToReactiveRecordMap.set(target, newRecord);
        }
        let value = reactiveRecord[key];
        if (isUndefined(value)) {
            value = [];
            reactiveRecord[key] = value;
        }
        else if (value[0] === vm) {
            return; // perf optimization considering that most subscriptions will come from the same vm
        }
        if (ArrayIndexOf.call(value, vm) === -1) {
            ArrayPush.call(value, vm);
            // we keep track of the sets that vm is listening from to be able to do some clean up later on
            ArrayPush.call(vm.deps, value);
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function valueDistortion(value) {
        return value;
    }
    const reactiveMembrane = new ReactiveMembrane({
        valueObserved: observeMutation,
        valueMutated: notifyMutation,
        valueDistortion,
    });
    /**
     * EXPERIMENTAL: This function implements an unwrap mechanism that
     * works for observable membrane objects. This API is subject to
     * change or being removed.
     */
    const unwrap$1 = function (value) {
        const unwrapped = reactiveMembrane.unwrapProxy(value);
        if (unwrapped !== value) {
            // if value is a proxy, unwrap to access original value and apply distortion
            return valueDistortion(unwrapped);
        }
        return value;
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // A bridge descriptor is a descriptor whose job is just to get the component instance
    // from the element instance, and get the value or set a new value on the component.
    // This means that across different elements, similar names can get the exact same
    // descriptor, so we can cache them:
    const cachedGetterByKey = create(null);
    const cachedSetterByKey = create(null);
    function createGetter(key) {
        let fn = cachedGetterByKey[key];
        if (isUndefined(fn)) {
            fn = cachedGetterByKey[key] = function () {
                const vm = getCustomElementVM(this);
                const { getHook } = vm;
                return getHook(vm.component, key);
            };
        }
        return fn;
    }
    function createSetter(key) {
        let fn = cachedSetterByKey[key];
        if (isUndefined(fn)) {
            fn = cachedSetterByKey[key] = function (newValue) {
                const vm = getCustomElementVM(this);
                const { setHook } = vm;
                newValue = reactiveMembrane.getReadOnlyProxy(newValue);
                setHook(vm.component, key, newValue);
            };
        }
        return fn;
    }
    function createMethodCaller(methodName) {
        return function () {
            const vm = getCustomElementVM(this);
            const { callHook, component } = vm;
            const fn = component[methodName];
            return callHook(vm.component, fn, ArraySlice$1.call(arguments));
        };
    }
    function HTMLBridgeElementFactory(SuperClass, props, methods) {
        let HTMLBridgeElement;
        /**
         * Modern browsers will have all Native Constructors as regular Classes
         * and must be instantiated with the new keyword. In older browsers,
         * specifically IE11, those are objects with a prototype property defined,
         * since they are not supposed to be extended or instantiated with the
         * new keyword. This forking logic supports both cases, specifically because
         * wc.ts relies on the construction path of the bridges to create new
         * fully qualifying web components.
         */
        if (isFunction(SuperClass)) {
            HTMLBridgeElement = class extends SuperClass {
            };
        }
        else {
            HTMLBridgeElement = function () {
                // Bridge classes are not supposed to be instantiated directly in
                // browsers that do not support web components.
                throw new TypeError('Illegal constructor');
            };
            // prototype inheritance dance
            setPrototypeOf(HTMLBridgeElement, SuperClass);
            setPrototypeOf(HTMLBridgeElement.prototype, SuperClass.prototype);
            defineProperty(HTMLBridgeElement.prototype, 'constructor', {
                writable: true,
                configurable: true,
                value: HTMLBridgeElement,
            });
        }
        const descriptors = create(null);
        // expose getters and setters for each public props on the new Element Bridge
        for (let i = 0, len = props.length; i < len; i += 1) {
            const propName = props[i];
            descriptors[propName] = {
                get: createGetter(propName),
                set: createSetter(propName),
                enumerable: true,
                configurable: true,
            };
        }
        // expose public methods as props on the new Element Bridge
        for (let i = 0, len = methods.length; i < len; i += 1) {
            const methodName = methods[i];
            descriptors[methodName] = {
                value: createMethodCaller(methodName),
                writable: true,
                configurable: true,
            };
        }
        defineProperties(HTMLBridgeElement.prototype, descriptors);
        return HTMLBridgeElement;
    }
    const BaseBridgeElement = HTMLBridgeElementFactory(HTMLElement, getOwnPropertyNames(HTMLElementOriginalDescriptors), []);
    freeze(BaseBridgeElement);
    seal(BaseBridgeElement.prototype);

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isLiveBindingProp(sel, key) {
        // For special whitelisted properties, we check against the actual property value on the DOM element instead of
        // relying on tracked property values.
        return sel === 'input' && (key === 'value' || key === 'checked');
    }
    function update(oldVnode, vnode) {
        const props = vnode.data.props;
        if (isUndefined(props)) {
            return;
        }
        const oldProps = oldVnode.data.props;
        if (oldProps === props) {
            return;
        }
        const elm = vnode.elm;
        const vm = getInternalField(elm, ViewModelReflection);
        const isFirstPatch = isUndefined(oldProps);
        const { sel } = vnode;
        for (const key in props) {
            const cur = props[key];
            // if it is the first time this element is patched, or the current value is different to the previous value...
            if (isFirstPatch ||
                cur !== (isLiveBindingProp(sel, key) ? elm[key] : oldProps[key])) {
                elm[key] = cur;
            }
        }
    }
    const emptyVNode$1 = { data: {} };
    var modProps = {
        create: (vnode) => update(emptyVNode$1, vnode),
        update,
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const classNameToClassMap = create(null);
    function getMapFromClassName(className) {
        // Intentionally using == to match undefined and null values from computed style attribute
        if (className == null) {
            return EmptyObject;
        }
        // computed class names must be string
        className = isString(className) ? className : className + '';
        let map = classNameToClassMap[className];
        if (map) {
            return map;
        }
        map = create(null);
        let start = 0;
        let o;
        const len = className.length;
        for (o = 0; o < len; o++) {
            if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {
                if (o > start) {
                    map[StringSlice.call(className, start, o)] = true;
                }
                start = o + 1;
            }
        }
        if (o > start) {
            map[StringSlice.call(className, start, o)] = true;
        }
        classNameToClassMap[className] = map;
        return map;
    }
    function updateClassAttribute(oldVnode, vnode) {
        const { elm, data: { className: newClass }, } = vnode;
        const { data: { className: oldClass }, } = oldVnode;
        if (oldClass === newClass) {
            return;
        }
        const { classList } = elm;
        const newClassMap = getMapFromClassName(newClass);
        const oldClassMap = getMapFromClassName(oldClass);
        let name;
        for (name in oldClassMap) {
            // remove only if it is not in the new class collection and it is not set from within the instance
            if (isUndefined(newClassMap[name])) {
                classList.remove(name);
            }
        }
        for (name in newClassMap) {
            if (isUndefined(oldClassMap[name])) {
                classList.add(name);
            }
        }
    }
    const emptyVNode$2 = { data: {} };
    var modComputedClassName = {
        create: (vnode) => updateClassAttribute(emptyVNode$2, vnode),
        update: updateClassAttribute,
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The style property is a string when defined via an expression in the template.
    function updateStyleAttribute(oldVnode, vnode) {
        const { style: newStyle } = vnode.data;
        if (oldVnode.data.style === newStyle) {
            return;
        }
        const elm = vnode.elm;
        const { style } = elm;
        if (!isString(newStyle) || newStyle === '') {
            removeAttribute.call(elm, 'style');
        }
        else {
            style.cssText = newStyle;
        }
    }
    const emptyVNode$3 = { data: {} };
    var modComputedStyle = {
        create: (vnode) => updateStyleAttribute(emptyVNode$3, vnode),
        update: updateStyleAttribute,
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The HTML class property becomes the vnode.data.classMap object when defined as a string in the template.
    // The compiler takes care of transforming the inline classnames into an object. It's faster to set the
    // different classnames properties individually instead of via a string.
    function createClassAttribute(vnode) {
        const { elm, data: { classMap }, } = vnode;
        if (isUndefined(classMap)) {
            return;
        }
        const { classList } = elm;
        for (const name in classMap) {
            classList.add(name);
        }
    }
    var modStaticClassName = {
        create: createClassAttribute,
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The HTML style property becomes the vnode.data.styleMap object when defined as a string in the template.
    // The compiler takes care of transforming the inline style into an object. It's faster to set the
    // different style properties individually instead of via a string.
    function createStyleAttribute(vnode) {
        const { elm, data: { styleMap }, } = vnode;
        if (isUndefined(styleMap)) {
            return;
        }
        const { style } = elm;
        for (const name in styleMap) {
            style[name] = styleMap[name];
        }
    }
    var modStaticStyle = {
        create: createStyleAttribute,
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function createContext(vnode) {
        const { data: { context }, } = vnode;
        if (isUndefined(context)) {
            return;
        }
        const elm = vnode.elm;
        const vm = getInternalField(elm, ViewModelReflection);
        if (!isUndefined(vm)) {
            assign(vm.context, context);
        }
    }
    const contextModule = {
        create: createContext,
    };

    // TODO: #1164 - eventually the engine should not do any of this work,
    // it should just interact with the DOM, and the polyfill should
    // take care of all these operation
    const { PatchedElement, PatchedSlotElement, PatchedNode } = useSyntheticShadow
        ? Element.prototype.$lwcPolyfill$
        : {};
    // Using a WeakMap instead of a WeakSet because this one works in IE11 :(
    const FromIteration = new WeakMap();
    // dynamic children means it was generated by an iteration
    // in a template, and will require a more complex diffing algo.
    function markAsDynamicChildren(children) {
        FromIteration.set(children, 1);
    }
    function hasDynamicChildren(children) {
        return FromIteration.has(children);
    }
    let TextNodeProto;
    // this method is supposed to be invoked when in fallback mode only
    // to patch text nodes generated by a template.
    function patchTextNodeProto(text) {
        if (isUndefined(TextNodeProto)) {
            TextNodeProto = PatchedNode(text).prototype;
        }
        setPrototypeOf(text, TextNodeProto);
    }
    let CommentNodeProto;
    // this method is supposed to be invoked when in fallback mode only
    // to patch comment nodes generated by a template.
    function patchCommentNodeProto(comment) {
        if (isUndefined(CommentNodeProto)) {
            CommentNodeProto = PatchedNode(comment).prototype;
        }
        setPrototypeOf(comment, CommentNodeProto);
    }
    const TagToProtoCache = create(null);
    function getPatchedElementClass(elm) {
        switch (tagNameGetter.call(elm)) {
            case 'SLOT':
                return PatchedSlotElement(elm);
        }
        return PatchedElement(elm);
    }
    // this method is supposed to be invoked when in fallback mode only
    // to patch elements generated by a template.
    function patchElementProto(elm, options) {
        const { sel } = options;
        let proto = TagToProtoCache[sel];
        if (isUndefined(proto)) {
            proto = TagToProtoCache[sel] = getPatchedElementClass(elm).prototype;
        }
        setPrototypeOf(elm, proto);
    }
    function patchCustomElementProto(elm, options) {
        const { def } = options;
        let patchedBridge = def.patchedBridge;
        if (isUndefined(patchedBridge)) {
            patchedBridge = def.patchedBridge = PatchedElement(elm);
        }
        // temporary patching the proto, eventually this should be just more nodes in the proto chain
        setPrototypeOf(elm, patchedBridge.prototype);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
    @license
    Copyright (c) 2015 Simon Friis Vindum.
    This code may only be used under the MIT License found at
    https://github.com/snabbdom/snabbdom/blob/master/LICENSE
    Code distributed by Snabbdom as part of the Snabbdom project at
    https://github.com/snabbdom/snabbdom/
    */
    function isUndef(s) {
        return s === undefined;
    }
    function sameVnode(vnode1, vnode2) {
        return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
    }
    function isVNode(vnode) {
        return vnode != null;
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
        const map = {};
        let j, key, ch;
        // TODO: simplify this by assuming that all vnodes has keys
        for (j = beginIdx; j <= endIdx; ++j) {
            ch = children[j];
            if (isVNode(ch)) {
                key = ch.key;
                if (key !== undefined) {
                    map[key] = j;
                }
            }
        }
        return map;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            const ch = vnodes[startIdx];
            if (isVNode(ch)) {
                ch.hook.create(ch);
                ch.hook.insert(ch, parentElm, before);
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            const ch = vnodes[startIdx];
            // text nodes do not have logic associated to them
            if (isVNode(ch)) {
                ch.hook.remove(ch, parentElm);
            }
        }
    }
    function updateDynamicChildren(parentElm, oldCh, newCh) {
        let oldStartIdx = 0;
        let newStartIdx = 0;
        let oldEndIdx = oldCh.length - 1;
        let oldStartVnode = oldCh[0];
        let oldEndVnode = oldCh[oldEndIdx];
        let newEndIdx = newCh.length - 1;
        let newStartVnode = newCh[0];
        let newEndVnode = newCh[newEndIdx];
        let oldKeyToIdx;
        let idxInOld;
        let elmToMove;
        let before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (!isVNode(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            }
            else if (!isVNode(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (!isVNode(newStartVnode)) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (!isVNode(newEndVnode)) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode);
                newEndVnode.hook.move(oldStartVnode, parentElm, 
                // TODO: resolve this, but using dot notation for nextSibling for now
                oldEndVnode.elm.nextSibling);
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode);
                newStartVnode.hook.move(oldEndVnode, parentElm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) {
                    // New element
                    newStartVnode.hook.create(newStartVnode);
                    newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    elmToMove = oldCh[idxInOld];
                    if (isVNode(elmToMove)) {
                        if (elmToMove.sel !== newStartVnode.sel) {
                            // New element
                            newStartVnode.hook.create(newStartVnode);
                            newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);
                        }
                        else {
                            patchVnode(elmToMove, newStartVnode);
                            oldCh[idxInOld] = undefined;
                            newStartVnode.hook.move(elmToMove, parentElm, oldStartVnode.elm);
                        }
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
            if (oldStartIdx > oldEndIdx) {
                const n = newCh[newEndIdx + 1];
                before = isVNode(n) ? n.elm : null;
                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
            }
            else {
                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
        }
    }
    function updateStaticChildren(parentElm, oldCh, newCh) {
        const { length } = newCh;
        if (oldCh.length === 0) {
            // the old list is empty, we can directly insert anything new
            addVnodes(parentElm, null, newCh, 0, length);
            return;
        }
        // if the old list is not empty, the new list MUST have the same
        // amount of nodes, that's why we call this static children
        let referenceElm = null;
        for (let i = length - 1; i >= 0; i -= 1) {
            const vnode = newCh[i];
            const oldVNode = oldCh[i];
            if (vnode !== oldVNode) {
                if (isVNode(oldVNode)) {
                    if (isVNode(vnode)) {
                        // both vnodes must be equivalent, and se just need to patch them
                        patchVnode(oldVNode, vnode);
                        referenceElm = vnode.elm;
                    }
                    else {
                        // removing the old vnode since the new one is null
                        oldVNode.hook.remove(oldVNode, parentElm);
                    }
                }
                else if (isVNode(vnode)) {
                    // this condition is unnecessary
                    vnode.hook.create(vnode);
                    // insert the new node one since the old one is null
                    vnode.hook.insert(vnode, parentElm, referenceElm);
                    referenceElm = vnode.elm;
                }
            }
        }
    }
    function patchVnode(oldVnode, vnode) {
        if (oldVnode !== vnode) {
            vnode.elm = oldVnode.elm;
            vnode.hook.update(oldVnode, vnode);
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const noop = () => void 0;
    function observeElementChildNodes(elm) {
        elm.$domManual$ = true;
    }
    function setElementShadowToken(elm, token) {
        elm.$shadowToken$ = token;
    }
    function updateNodeHook(oldVnode, vnode) {
        const { text } = vnode;
        if (oldVnode.text !== text) {
            /**
             * Compiler will never produce a text property that is not string
             */
            vnode.elm.nodeValue = text;
        }
    }
    function insertNodeHook(vnode, parentNode, referenceNode) {
        parentNode.insertBefore(vnode.elm, referenceNode);
    }
    function removeNodeHook(vnode, parentNode) {
        parentNode.removeChild(vnode.elm);
    }
    function createTextHook(vnode) {
        const text = vnode.elm;
        if (isTrue(useSyntheticShadow)) {
            patchTextNodeProto(text);
        }
    }
    function createCommentHook(vnode) {
        const comment = vnode.elm;
        if (isTrue(useSyntheticShadow)) {
            patchCommentNodeProto(comment);
        }
    }
    function createElmHook(vnode) {
        modEvents.create(vnode);
        // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.create(vnode);
        modProps.create(vnode);
        modStaticClassName.create(vnode);
        modStaticStyle.create(vnode);
        modComputedClassName.create(vnode);
        modComputedStyle.create(vnode);
        contextModule.create(vnode);
    }
    var LWCDOMMode;
    (function (LWCDOMMode) {
        LWCDOMMode["manual"] = "manual";
    })(LWCDOMMode || (LWCDOMMode = {}));
    function fallbackElmHook(vnode) {
        const { owner, sel } = vnode;
        const elm = vnode.elm;
        if (isTrue(useSyntheticShadow)) {
            const { data: { context }, } = vnode;
            const { shadowAttribute } = owner.context;
            if (!isUndefined(context) &&
                !isUndefined(context.lwc) &&
                context.lwc.dom === LWCDOMMode.manual) {
                // this element will now accept any manual content inserted into it
                observeElementChildNodes(elm);
            }
            // when running in synthetic shadow mode, we need to set the shadowToken value
            // into each element from the template, so they can be styled accordingly.
            setElementShadowToken(elm, shadowAttribute);
            patchElementProto(elm, { sel });
        }
    }
    function updateElmHook(oldVnode, vnode) {
        // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.update(oldVnode, vnode);
        modProps.update(oldVnode, vnode);
        modComputedClassName.update(oldVnode, vnode);
        modComputedStyle.update(oldVnode, vnode);
    }
    function insertCustomElmHook(vnode) {
        const vm = getCustomElementVM(vnode.elm);
        appendVM(vm);
    }
    function updateChildrenHook(oldVnode, vnode) {
        const { children, owner } = vnode;
        const fn = hasDynamicChildren(children) ? updateDynamicChildren : updateStaticChildren;
        runWithBoundaryProtection(owner, owner.owner, noop, () => {
            fn(vnode.elm, oldVnode.children, children);
        }, noop);
    }
    function allocateChildrenHook(vnode) {
        const elm = vnode.elm;
        const vm = getCustomElementVM(elm);
        const { children } = vnode;
        vm.aChildren = children;
        if (isTrue(useSyntheticShadow)) {
            // slow path
            allocateInSlot(vm, children);
            // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!
            vnode.children = EmptyArray;
        }
    }
    function createViewModelHook(vnode) {
        const elm = vnode.elm;
        if (hasOwnProperty.call(elm, ViewModelReflection)) {
            // There is a possibility that a custom element is registered under tagName,
            // in which case, the initialization is already carry on, and there is nothing else
            // to do here since this hook is called right after invoking `document.createElement`.
            return;
        }
        const { mode, ctor, owner } = vnode;
        const def = getComponentDef(ctor);
        setElementProto(elm, def);
        if (isTrue(useSyntheticShadow)) {
            const { shadowAttribute } = owner.context;
            // when running in synthetic shadow mode, we need to set the shadowToken value
            // into each element from the template, so they can be styled accordingly.
            setElementShadowToken(elm, shadowAttribute);
            patchCustomElementProto(elm, { def });
        }
        createVM(elm, ctor, {
            mode,
            owner,
        });
        const vm = getCustomElementVM(elm);
    }
    function createCustomElmHook(vnode) {
        modEvents.create(vnode);
        // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.create(vnode);
        modProps.create(vnode);
        modStaticClassName.create(vnode);
        modStaticStyle.create(vnode);
        modComputedClassName.create(vnode);
        modComputedStyle.create(vnode);
        contextModule.create(vnode);
    }
    function createChildrenHook(vnode) {
        const { elm, children } = vnode;
        for (let j = 0; j < children.length; ++j) {
            const ch = children[j];
            if (ch != null) {
                ch.hook.create(ch);
                ch.hook.insert(ch, elm, null);
            }
        }
    }
    function rerenderCustomElmHook(vnode) {
        const vm = getCustomElementVM(vnode.elm);
        rerenderVM(vm);
    }
    function updateCustomElmHook(oldVnode, vnode) {
        // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.update(oldVnode, vnode);
        modProps.update(oldVnode, vnode);
        modComputedClassName.update(oldVnode, vnode);
        modComputedStyle.update(oldVnode, vnode);
    }
    function removeElmHook(vnode) {
        // this method only needs to search on child vnodes from template
        // to trigger the remove hook just in case some of those children
        // are custom elements.
        const { children, elm } = vnode;
        for (let j = 0, len = children.length; j < len; ++j) {
            const ch = children[j];
            if (!isNull(ch)) {
                ch.hook.remove(ch, elm);
            }
        }
    }
    function removeCustomElmHook(vnode) {
        // for custom elements we don't have to go recursively because the removeVM routine
        // will take care of disconnecting any child VM attached to its shadow as well.
        removeVM(getCustomElementVM(vnode.elm));
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const Services = create(null);
    const hooks = [
        'wiring',
        'locator',
        'rendered',
        'connected',
        'disconnected',
    ];
    /**
     * EXPERIMENTAL: This function allows for the registration of "services"
     * in LWC by exposing hooks into the component life-cycle. This API is
     * subject to change or being removed.
     */
    function register(service) {
        for (let i = 0; i < hooks.length; ++i) {
            const hookName = hooks[i];
            if (hookName in service) {
                let l = Services[hookName];
                if (isUndefined(l)) {
                    Services[hookName] = l = [];
                }
                ArrayPush.call(l, service[hookName]);
            }
        }
    }
    function invokeServiceHook(vm, cbs) {
        const { component, data, def, context } = vm;
        for (let i = 0, len = cbs.length; i < len; ++i) {
            cbs[i].call(undefined, component, data, def, context);
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const CHAR_S = 115;
    const CHAR_V = 118;
    const CHAR_G = 103;
    const NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';
    const SymbolIterator = Symbol.iterator;
    const TextHook = {
        create: (vnode) => {
            vnode.elm = document.createTextNode(vnode.text);
            linkNodeToShadow(vnode);
            createTextHook(vnode);
        },
        update: updateNodeHook,
        insert: insertNodeHook,
        move: insertNodeHook,
        remove: removeNodeHook,
    };
    const CommentHook = {
        create: (vnode) => {
            vnode.elm = document.createComment(vnode.text);
            linkNodeToShadow(vnode);
            createCommentHook(vnode);
        },
        update: updateNodeHook,
        insert: insertNodeHook,
        move: insertNodeHook,
        remove: removeNodeHook,
    };
    // insert is called after update, which is used somewhere else (via a module)
    // to mark the vm as inserted, that means we cannot use update as the main channel
    // to rehydrate when dirty, because sometimes the element is not inserted just yet,
    // which breaks some invariants. For that reason, we have the following for any
    // Custom Element that is inserted via a template.
    const ElementHook = {
        create: (vnode) => {
            const { data, sel, clonedElement } = vnode;
            const { ns } = data;
            // TODO: issue #1364 - supporting the ability to inject a cloned StyleElement
            // via a vnode this is used for style tags for native shadow
            if (isUndefined(clonedElement)) {
                vnode.elm = isUndefined(ns)
                    ? document.createElement(sel)
                    : document.createElementNS(ns, sel);
            }
            else {
                vnode.elm = clonedElement;
            }
            linkNodeToShadow(vnode);
            fallbackElmHook(vnode);
            createElmHook(vnode);
        },
        update: (oldVnode, vnode) => {
            updateElmHook(oldVnode, vnode);
            updateChildrenHook(oldVnode, vnode);
        },
        insert: (vnode, parentNode, referenceNode) => {
            insertNodeHook(vnode, parentNode, referenceNode);
            createChildrenHook(vnode);
        },
        move: (vnode, parentNode, referenceNode) => {
            insertNodeHook(vnode, parentNode, referenceNode);
        },
        remove: (vnode, parentNode) => {
            removeNodeHook(vnode, parentNode);
            removeElmHook(vnode);
        },
    };
    const CustomElementHook = {
        create: (vnode) => {
            const { sel } = vnode;
            vnode.elm = document.createElement(sel);
            linkNodeToShadow(vnode);
            createViewModelHook(vnode);
            allocateChildrenHook(vnode);
            createCustomElmHook(vnode);
        },
        update: (oldVnode, vnode) => {
            updateCustomElmHook(oldVnode, vnode);
            // in fallback mode, the allocation will always set children to
            // empty and delegate the real allocation to the slot elements
            allocateChildrenHook(vnode);
            // in fallback mode, the children will be always empty, so, nothing
            // will happen, but in native, it does allocate the light dom
            updateChildrenHook(oldVnode, vnode);
            // this will update the shadowRoot
            rerenderCustomElmHook(vnode);
        },
        insert: (vnode, parentNode, referenceNode) => {
            insertNodeHook(vnode, parentNode, referenceNode);
            createChildrenHook(vnode);
            insertCustomElmHook(vnode);
        },
        move: (vnode, parentNode, referenceNode) => {
            insertNodeHook(vnode, parentNode, referenceNode);
        },
        remove: (vnode, parentNode) => {
            removeNodeHook(vnode, parentNode);
            removeCustomElmHook(vnode);
        },
    };
    function linkNodeToShadow(vnode) {
        // TODO: #1164 - this should eventually be done by the polyfill directly
        vnode.elm.$shadowResolver$ = vnode.owner.cmpRoot.$shadowResolver$;
    }
    // TODO: #1136 - this should be done by the compiler, adding ns to every sub-element
    function addNS(vnode) {
        const { data, children, sel } = vnode;
        data.ns = NamespaceAttributeForSVG;
        // TODO: #1275 - review why `sel` equal `foreignObject` should get this `ns`
        if (isArray$1(children) && sel !== 'foreignObject') {
            for (let j = 0, n = children.length; j < n; ++j) {
                const childNode = children[j];
                if (childNode != null && childNode.hook === ElementHook) {
                    addNS(childNode);
                }
            }
        }
    }
    function addVNodeToChildLWC(vnode) {
        ArrayPush.call(vmBeingRendered.velements, vnode);
    }
    // [h]tml node
    function h(sel, data, children) {
        const { key } = data;
        let text, elm;
        const vnode = {
            sel,
            data,
            children,
            text,
            elm,
            key,
            hook: ElementHook,
            owner: vmBeingRendered,
        };
        if (sel.length === 3 &&
            StringCharCodeAt.call(sel, 0) === CHAR_S &&
            StringCharCodeAt.call(sel, 1) === CHAR_V &&
            StringCharCodeAt.call(sel, 2) === CHAR_G) {
            addNS(vnode);
        }
        return vnode;
    }
    // [t]ab[i]ndex function
    function ti(value) {
        // if value is greater than 0, we normalize to 0
        // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through
        // If value is less than -1, we don't care
        const shouldNormalize = value > 0 && !(isTrue(value) || isFalse(value));
        return shouldNormalize ? 0 : value;
    }
    // [s]lot element node
    function s(slotName, data, children, slotset) {
        if (!isUndefined(slotset) &&
            !isUndefined(slotset[slotName]) &&
            slotset[slotName].length !== 0) {
            children = slotset[slotName];
        }
        const vnode = h('slot', data, children);
        if (useSyntheticShadow) {
            // the content of the slot has to be dynamic when in synthetic shadow mode because
            // the `vnode.children` might be the slotted content vs default content, in which case
            // the size and the keys are not matching.
            markAsDynamicChildren(children);
        }
        return vnode;
    }
    // [c]ustom element node
    function c(sel, Ctor, data, children) {
        if (isCircularModuleDependency(Ctor)) {
            Ctor = resolveCircularModuleDependency(Ctor);
        }
        const { key } = data;
        let text, elm;
        children = arguments.length === 3 ? EmptyArray : children;
        const vnode = {
            sel,
            data,
            children,
            text,
            elm,
            key,
            hook: CustomElementHook,
            ctor: Ctor,
            owner: vmBeingRendered,
            mode: 'open',
        };
        addVNodeToChildLWC(vnode);
        return vnode;
    }
    // [i]terable node
    function i(iterable, factory) {
        const list = [];
        // marking the list as generated from iteration so we can optimize the diffing
        markAsDynamicChildren(list);
        if (isUndefined(iterable) || iterable === null) {
            return list;
        }
        const iterator = iterable[SymbolIterator]();
        let next = iterator.next();
        let j = 0;
        let { value, done: last } = next;
        while (last === false) {
            // implementing a look-back-approach because we need to know if the element is the last
            next = iterator.next();
            last = next.done;
            // template factory logic based on the previous collected value
            const vnode = factory(value, j, j === 0, last);
            if (isArray$1(vnode)) {
                ArrayPush.apply(list, vnode);
            }
            else {
                ArrayPush.call(list, vnode);
            }
            // preparing next value
            j += 1;
            value = next.value;
        }
        return list;
    }
    /**
     * [f]lattening
     */
    function f(items) {
        const len = items.length;
        const flattened = [];
        // all flattened nodes should be marked as dynamic because
        // flattened nodes are because of a conditional or iteration.
        // We have to mark as dynamic because this could switch from an
        // iterator to "static" text at any time.
        // TODO: #1276 - compiler should give us some sort of indicator to describe whether a vnode is dynamic or not
        markAsDynamicChildren(flattened);
        for (let j = 0; j < len; j += 1) {
            const item = items[j];
            if (isArray$1(item)) {
                ArrayPush.apply(flattened, item);
            }
            else {
                ArrayPush.call(flattened, item);
            }
        }
        return flattened;
    }
    // [t]ext node
    function t(text) {
        const data = EmptyObject;
        let sel, children, key, elm;
        return {
            sel,
            data,
            children,
            text,
            elm,
            key,
            hook: TextHook,
            owner: vmBeingRendered,
        };
    }
    // comment node
    function p(text) {
        const data = EmptyObject;
        const sel = '!';
        let children, key, elm;
        return {
            sel,
            data,
            children,
            text,
            elm,
            key,
            hook: CommentHook,
            owner: vmBeingRendered,
        };
    }
    // [d]ynamic value to produce a text vnode
    function d(value) {
        if (value == null) {
            return null;
        }
        return t(value);
    }
    // [b]ind function
    function b(fn) {
        if (isNull(vmBeingRendered)) {
            throw new Error();
        }
        const vm = vmBeingRendered;
        return function (event) {
            invokeEventListener(vm, fn, vm.component, event);
        };
    }
    // [f]unction_[b]ind
    function fb(fn) {
        if (isNull(vmBeingRendered)) {
            throw new Error();
        }
        const vm = vmBeingRendered;
        return function () {
            return invokeComponentCallback(vm, fn, ArraySlice$1.call(arguments));
        };
    }
    // [l]ocator_[l]istener function
    function ll(originalHandler, id, context) {
        if (isNull(vmBeingRendered)) {
            throw new Error();
        }
        const vm = vmBeingRendered;
        // bind the original handler with b() so we can call it
        // after resolving the locator
        const eventListener = b(originalHandler);
        // create a wrapping handler to resolve locator, and
        // then invoke the original handler.
        return function (event) {
            // located service for the locator metadata
            const { context: { locator }, } = vm;
            if (!isUndefined(locator)) {
                const { locator: locatorService } = Services;
                if (locatorService) {
                    locator.resolved = {
                        target: id,
                        host: locator.id,
                        targetContext: isFunction(context) && context(),
                        hostContext: isFunction(locator.context) && locator.context(),
                    };
                    // a registered `locator` service will be invoked with
                    // access to the context.locator.resolved, which will contain:
                    // outer id, outer context, inner id, and inner context
                    invokeServiceHook(vm, locatorService);
                }
            }
            // invoke original event listener via b()
            eventListener(event);
        };
    }
    // [k]ey function
    function k(compilerKey, obj) {
        switch (typeof obj) {
            case 'number':
            case 'string':
                return compilerKey + ':' + obj;
            case 'object':

        }
    }
    // [g]lobal [id] function
    function gid(id) {
        if (isUndefined(id) || id === '') {
            return id;
        }
        // We remove attributes when they are assigned a value of null
        if (isNull(id)) {
            return null;
        }
        return `${id}-${vmBeingRendered.idx}`;
    }
    // [f]ragment [id] function
    function fid(url) {
        if (isUndefined(url) || url === '') {
            return url;
        }
        // We remove attributes when they are assigned a value of null
        if (isNull(url)) {
            return null;
        }
        // Apply transformation only for fragment-only-urls
        if (/^#/.test(url)) {
            return `${url}-${vmBeingRendered.idx}`;
        }
        return url;
    }

    var api = /*#__PURE__*/Object.freeze({
        h: h,
        ti: ti,
        s: s,
        c: c,
        i: i,
        f: f,
        t: t,
        p: p,
        d: d,
        b: b,
        fb: fb,
        ll: ll,
        k: k,
        gid: gid,
        fid: fid
    });

    const signedTemplateSet = new Set();
    function defaultEmptyTemplate() {
        return [];
    }
    signedTemplateSet.add(defaultEmptyTemplate);
    function isTemplateRegistered(tpl) {
        return signedTemplateSet.has(tpl);
    }
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */
    function registerTemplate(tpl) {
        signedTemplateSet.add(tpl);
        // chaining this method as a way to wrap existing
        // assignment of templates easily, without too much transformation
        return tpl;
    }
    /**
     * EXPERIMENTAL: This function acts like a hook for Lightning Locker
     * Service and other similar libraries to sanitize vulnerable attributes.
     * This API is subject to change or being removed.
     */
    function sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {
        // locker-service patches this function during runtime to sanitize vulnerable attributes.
        // when ran off-core this function becomes a noop and returns the user authored value.
        return attrValue;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const CachedStyleFragments = create(null);
    function createStyleElement(styleContent) {
        const elm = document.createElement('style');
        elm.type = 'text/css';
        elm.textContent = styleContent;
        return elm;
    }
    function getCachedStyleElement(styleContent) {
        let fragment = CachedStyleFragments[styleContent];
        if (isUndefined(fragment)) {
            fragment = document.createDocumentFragment();
            const styleElm = createStyleElement(styleContent);
            fragment.appendChild(styleElm);
            CachedStyleFragments[styleContent] = fragment;
        }
        return fragment.cloneNode(true).firstChild;
    }
    const globalStyleParent = document.head || document.body || document;
    const InsertedGlobalStyleContent = create(null);
    function insertGlobalStyle(styleContent) {
        // inserts the global style when needed, otherwise does nothing
        if (isUndefined(InsertedGlobalStyleContent[styleContent])) {
            InsertedGlobalStyleContent[styleContent] = true;
            const elm = createStyleElement(styleContent);
            globalStyleParent.appendChild(elm);
        }
    }
    function createStyleVNode(elm) {
        const vnode = h('style', {
            key: 'style',
        }, EmptyArray);
        // TODO: issue #1364 - supporting the ability to inject a cloned StyleElement
        // forcing the diffing algo to use the cloned style for native shadow
        vnode.clonedElement = elm;
        return vnode;
    }
    /**
     * Reset the styling token applied to the host element.
     */
    function resetStyleAttributes(vm) {
        const { context, elm } = vm;
        // Remove the style attribute currently applied to the host element.
        const oldHostAttribute = context.hostAttribute;
        if (!isUndefined(oldHostAttribute)) {
            removeAttribute.call(elm, oldHostAttribute);
        }
        // Reset the scoping attributes associated to the context.
        context.hostAttribute = context.shadowAttribute = undefined;
    }
    /**
     * Apply/Update the styling token applied to the host element.
     */
    function applyStyleAttributes(vm, hostAttribute, shadowAttribute) {
        const { context, elm } = vm;
        // Remove the style attribute currently applied to the host element.
        setAttribute.call(elm, hostAttribute, '');
        context.hostAttribute = hostAttribute;
        context.shadowAttribute = shadowAttribute;
    }
    function collectStylesheets(stylesheets, hostSelector, shadowSelector, isNative, aggregatorFn) {
        forEach.call(stylesheets, sheet => {
            if (isArray$1(sheet)) {
                collectStylesheets(sheet, hostSelector, shadowSelector, isNative, aggregatorFn);
            }
            else {
                aggregatorFn(sheet(hostSelector, shadowSelector, isNative));
            }
        });
    }
    function evaluateCSS(vm, stylesheets, hostAttribute, shadowAttribute) {
        if (useSyntheticShadow) {
            const hostSelector = `[${hostAttribute}]`;
            const shadowSelector = `[${shadowAttribute}]`;
            collectStylesheets(stylesheets, hostSelector, shadowSelector, false, textContent => {
                insertGlobalStyle(textContent);
            });
            return null;
        }
        else {
            // Native shadow in place, we need to act accordingly by using the `:host` selector, and an
            // empty shadow selector since it is not really needed.
            let buffer = '';
            collectStylesheets(stylesheets, emptyString, emptyString, true, textContent => {
                buffer += textContent;
            });
            return createStyleVNode(getCachedStyleElement(buffer));
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const EmptySlots = create(null);
    function evaluateTemplate(vm, html) {
        const { component, context, cmpSlots, cmpTemplate } = vm;
        // reset the cache memoizer for template when needed
        if (html !== cmpTemplate) {
            // perf opt: do not reset the shadow root during the first rendering (there is nothing to reset)
            if (!isUndefined(cmpTemplate)) {
                // It is important to reset the content to avoid reusing similar elements generated from a different
                // template, because they could have similar IDs, and snabbdom just rely on the IDs.
                resetShadowRoot(vm);
            }
            // Check that the template was built by the compiler
            if (!isTemplateRegistered(html)) {
                throw new TypeError(`Invalid template returned by the render() method on ${vm}. It must return an imported template (e.g.: \`import html from "./${vm.def.name}.html"\`), instead, it has returned: ${toString(html)}.`);
            }
            vm.cmpTemplate = html;
            // Populate context with template information
            context.tplCache = create(null);
            resetStyleAttributes(vm);
            const { stylesheets, stylesheetTokens } = html;
            if (isUndefined(stylesheets) || stylesheets.length === 0) {
                context.styleVNode = null;
            }
            else if (!isUndefined(stylesheetTokens)) {
                const { hostAttribute, shadowAttribute } = stylesheetTokens;
                applyStyleAttributes(vm, hostAttribute, shadowAttribute);
                // Caching style vnode so it can be reused on every render
                context.styleVNode = evaluateCSS(vm, stylesheets, hostAttribute, shadowAttribute);
            }
        }
        // right before producing the vnodes, we clear up all internal references
        // to custom elements from the template.
        vm.velements = [];
        // invoke the selected template.
        const vnodes = html.call(undefined, api, component, cmpSlots, context.tplCache);
        const { styleVNode } = context;
        if (!isNull(styleVNode)) {
            ArrayUnshift$1.call(vnodes, styleVNode);
        }
        return vnodes;
    }

    var GlobalMeasurementPhase;
    (function (GlobalMeasurementPhase) {
        GlobalMeasurementPhase["REHYDRATE"] = "lwc-rehydrate";
        GlobalMeasurementPhase["HYDRATE"] = "lwc-hydrate";
    })(GlobalMeasurementPhase || (GlobalMeasurementPhase = {}));
    // Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.
    // JSDom (used in Jest) for example doesn't implement the UserTiming APIs.
    const isUserTimingSupported = typeof performance !== 'undefined' &&
        typeof performance.mark === 'function' &&
        typeof performance.clearMarks === 'function' &&
        typeof performance.measure === 'function' &&
        typeof performance.clearMeasures === 'function';
    function getMarkName(phase, vm) {
        return `<${StringToLowerCase.call(tagNameGetter.call(vm.elm))} (${vm.idx})> - ${phase}`;
    }
    function start(markName) {
        performance.mark(markName);
    }
    function end(measureName, markName) {
        performance.measure(measureName, markName);
        // Clear the created marks and measure to avoid filling the performance entries buffer.
        // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.
        performance.clearMarks(markName);
        performance.clearMarks(measureName);
    }
    function noop$1() {
        /* do nothing */
    }
    // Global measurements can be nested into each others (e.g. nested component creation via createElement). In those cases
    // the VM is used to create unique mark names at each level.
    const startGlobalMeasure = !isUserTimingSupported
        ? noop$1
        : function (phase, vm) {
            const markName = isUndefined(vm) ? phase : getMarkName(phase, vm);
            start(markName);
        };
    const endGlobalMeasure = !isUserTimingSupported
        ? noop$1
        : function (phase, vm) {
            const markName = isUndefined(vm) ? phase : getMarkName(phase, vm);
            end(phase, markName);
        };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    let vmBeingRendered = null;
    let vmBeingConstructed = null;
    function isBeingConstructed(vm) {
        return vmBeingConstructed === vm;
    }
    function invokeComponentCallback(vm, fn, args) {
        const { component, callHook, context, owner } = vm;
        let result;
        runWithBoundaryProtection(vm, owner, () => {
        }, () => {
            // job
            result = callHook(component, fn, args);
        }, () => {
        });
        return result;
    }
    function invokeComponentConstructor(vm, Ctor) {
        const vmBeingConstructedInception = vmBeingConstructed;
        let error;
        vmBeingConstructed = vm;
        /**
         * Constructors don't need to be wrapped with a boundary because for root elements
         * it should throw, while elements from template are already wrapped by a boundary
         * associated to the diffing algo.
         */
        try {
            // job
            const result = new Ctor();
            // Check indirectly if the constructor result is an instance of LightningElement. Using
            // the "instanceof" operator would not work here since Locker Service provides its own
            // implementation of LightningElement, so we indirectly check if the base constructor is
            // invoked by accessing the component on the vm.
            if (vmBeingConstructed.component !== result) {
                throw new TypeError('Invalid component constructor, the class should extend LightningElement.');
            }
        }
        catch (e) {
            error = Object(e);
        }
        finally {
            vmBeingConstructed = vmBeingConstructedInception;
            if (!isUndefined(error)) {
                error.wcStack = getErrorComponentStack(vm.elm);
                // re-throwing the original error annotated after restoring the context
                throw error; // eslint-disable-line no-unsafe-finally
            }
        }
    }
    function invokeComponentRenderMethod(vm) {
        const { def: { render }, callHook, component, context, owner, } = vm;
        const vmBeingRenderedInception = vmBeingRendered;
        vmBeingRendered = vm;
        let result;
        runWithBoundaryProtection(vm, owner, () => {
            vmBeingRendered = vm;
        }, () => {
            // job
            const html = callHook(component, render);
            result = evaluateTemplate(vm, html);
        }, () => {
            vmBeingRendered = vmBeingRenderedInception;
        });
        return result || [];
    }
    function invokeEventListener(vm, fn, thisValue, event) {
        const { callHook, owner, context } = vm;
        runWithBoundaryProtection(vm, owner, () => {
        }, () => {
            callHook(thisValue, fn, [event]);
        }, () => {
        });
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const signedComponentToMetaMap = new Map();
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */
    function registerComponent(Ctor, { name, tmpl: template }) {
        signedComponentToMetaMap.set(Ctor, { name, template });
        // chaining this method as a way to wrap existing
        // assignment of component constructor easily, without too much transformation
        return Ctor;
    }
    function getComponentRegisteredMeta(Ctor) {
        return signedComponentToMetaMap.get(Ctor);
    }
    function createComponent(uninitializedVm, Ctor) {
        // create the component instance
        invokeComponentConstructor(uninitializedVm, Ctor);
        const initializedVm = uninitializedVm;
        if (isUndefined(initializedVm.component)) {
            throw new ReferenceError(`Invalid construction for ${Ctor}, you must extend LightningElement.`);
        }
    }
    function linkComponent(vm) {
        // wiring service
        const { def: { wire }, } = vm;
        if (wire) {
            const { wiring } = Services;
            if (wiring) {
                invokeServiceHook(vm, wiring);
            }
        }
    }
    function clearReactiveListeners(vm) {
        const { deps } = vm;
        const len = deps.length;
        if (len > 0) {
            for (let i = 0; i < len; i += 1) {
                const set = deps[i];
                const pos = ArrayIndexOf.call(deps[i], vm);
                ArraySplice.call(set, pos, 1);
            }
            deps.length = 0;
        }
    }
    function renderComponent(vm) {
        clearReactiveListeners(vm);
        const vnodes = invokeComponentRenderMethod(vm);
        vm.isDirty = false;
        vm.isScheduled = false;
        return vnodes;
    }
    function markComponentAsDirty(vm) {
        vm.isDirty = true;
    }
    const cmpEventListenerMap = new WeakMap();
    function getWrappedComponentsListener(vm, listener) {
        if (!isFunction(listener)) {
            throw new TypeError(); // avoiding problems with non-valid listeners
        }
        let wrappedListener = cmpEventListenerMap.get(listener);
        if (isUndefined(wrappedListener)) {
            wrappedListener = function (event) {
                invokeEventListener(vm, listener, undefined, event);
            };
            cmpEventListenerMap.set(listener, wrappedListener);
        }
        return wrappedListener;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This operation is called with a descriptor of an standard html property
     * that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors
     * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.
     */
    function createBridgeToElementDescriptor(propName, descriptor) {
        const { get, set, enumerable, configurable } = descriptor;
        if (!isFunction(get)) {
            throw new TypeError();
        }
        if (!isFunction(set)) {
            throw new TypeError();
        }
        return {
            enumerable,
            configurable,
            get() {
                const vm = getComponentVM(this);
                if (isBeingConstructed(vm)) {
                    return;
                }
                observeMutation(this, propName);
                return get.call(vm.elm);
            },
            set(newValue) {
                const vm = getComponentVM(this);
                if (newValue !== vm.cmpProps[propName]) {
                    vm.cmpProps[propName] = newValue;
                    if (isFalse(vm.isDirty)) {
                        // perf optimization to skip this step if not in the DOM
                        notifyMutation(this, propName);
                    }
                }
                return set.call(vm.elm, newValue);
            },
        };
    }
    function getLinkedElement(cmp) {
        return getComponentVM(cmp).elm;
    }
    /**
     * This class is the base class for any LWC element.
     * Some elements directly extends this class, others implement it via inheritance.
     **/
    function BaseLightningElement() {
        // This should be as performant as possible, while any initialization should be done lazily
        if (isNull(vmBeingConstructed)) {
            throw new ReferenceError();
        }
        const vm = vmBeingConstructed;
        const { elm, mode, def: { ctor }, } = vm;
        const component = this;
        vm.component = component;
        // interaction hooks
        // We are intentionally hiding this argument from the formal API of LWCElement because
        // we don't want folks to know about it just yet.
        if (arguments.length === 1) {
            const { callHook, setHook, getHook } = arguments[0];
            vm.callHook = callHook;
            vm.setHook = setHook;
            vm.getHook = getHook;
        }
        // attaching the shadowRoot
        const shadowRootOptions = {
            mode,
            delegatesFocus: !!ctor.delegatesFocus,
        };
        const cmpRoot = elm.attachShadow(shadowRootOptions);
        // linking elm, shadow root and component with the VM
        setHiddenField(component, ViewModelReflection, vm);
        setInternalField(elm, ViewModelReflection, vm);
        setInternalField(cmpRoot, ViewModelReflection, vm);
        // VM is now initialized
        vm.cmpRoot = cmpRoot;
    }
    // HTML Element - The Good Parts
    BaseLightningElement.prototype = {
        constructor: BaseLightningElement,
        dispatchEvent(event) {
            const elm = getLinkedElement(this);
            const vm = getComponentVM(this);
            return dispatchEvent.call(elm, event);
        },
        addEventListener(type, listener, options) {
            const vm = getComponentVM(this);
            const wrappedListener = getWrappedComponentsListener(vm, listener);
            vm.elm.addEventListener(type, wrappedListener, options);
        },
        removeEventListener(type, listener, options) {
            const vm = getComponentVM(this);
            const wrappedListener = getWrappedComponentsListener(vm, listener);
            vm.elm.removeEventListener(type, wrappedListener, options);
        },
        setAttributeNS(ns, attrName, _value) {
            const elm = getLinkedElement(this);
            unlockAttribute(elm, attrName);
            // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            elm.setAttributeNS.apply(elm, arguments);
            lockAttribute(elm, attrName);
        },
        removeAttributeNS(ns, attrName) {
            const elm = getLinkedElement(this);
            unlockAttribute(elm, attrName);
            // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            elm.removeAttributeNS.apply(elm, arguments);
            lockAttribute(elm, attrName);
        },
        removeAttribute(attrName) {
            const elm = getLinkedElement(this);
            unlockAttribute(elm, attrName);
            // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            elm.removeAttribute.apply(elm, arguments);
            lockAttribute(elm, attrName);
        },
        setAttribute(attrName, _value) {
            const elm = getLinkedElement(this);
            unlockAttribute(elm, attrName);
            // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            elm.setAttribute.apply(elm, arguments);
            lockAttribute(elm, attrName);
        },
        getAttribute(attrName) {
            const elm = getLinkedElement(this);
            unlockAttribute(elm, attrName);
            // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            const value = elm.getAttribute.apply(elm, arguments);
            lockAttribute(elm, attrName);
            return value;
        },
        getAttributeNS(ns, attrName) {
            const elm = getLinkedElement(this);
            unlockAttribute(elm, attrName);
            // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            const value = elm.getAttributeNS.apply(elm, arguments);
            lockAttribute(elm, attrName);
            return value;
        },
        getBoundingClientRect() {
            const elm = getLinkedElement(this);
            return elm.getBoundingClientRect();
        },
        /**
         * Returns the first element that is a descendant of node that
         * matches selectors.
         */
        // querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;
        // querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;
        querySelector(selectors) {
            const vm = getComponentVM(this);
            const { elm } = vm;
            return elm.querySelector(selectors);
        },
        /**
         * Returns all element descendants of node that
         * match selectors.
         */
        // querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>,
        // querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>,
        querySelectorAll(selectors) {
            const vm = getComponentVM(this);
            const { elm } = vm;
            return elm.querySelectorAll(selectors);
        },
        /**
         * Returns all element descendants of node that
         * match the provided tagName.
         */
        getElementsByTagName(tagNameOrWildCard) {
            const vm = getComponentVM(this);
            const { elm } = vm;
            return elm.getElementsByTagName(tagNameOrWildCard);
        },
        /**
         * Returns all element descendants of node that
         * match the provide classnames.
         */
        getElementsByClassName(names) {
            const vm = getComponentVM(this);
            const { elm } = vm;
            return elm.getElementsByClassName(names);
        },
        get classList() {
            return getLinkedElement(this).classList;
        },
        get template() {
            const vm = getComponentVM(this);
            return vm.cmpRoot;
        },
        get shadowRoot() {
            // From within the component instance, the shadowRoot is always
            // reported as "closed". Authors should rely on this.template instead.
            return null;
        },
        render() {
            const vm = getComponentVM(this);
            return vm.def.template;
        },
        toString() {
            const vm = getComponentVM(this);
            return `[object ${vm.def.name}]`;
        },
    };
    // Typescript is inferring the wrong function type for this particular
    // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
    // @ts-ignore type-mismatch
    const baseDescriptors = ArrayReduce.call(getOwnPropertyNames(HTMLElementOriginalDescriptors), (descriptors, propName) => {
        descriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);
        return descriptors;
    }, create(null));
    defineProperties(BaseLightningElement.prototype, baseDescriptors);
    freeze(BaseLightningElement);
    seal(BaseLightningElement.prototype);

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function track(target, prop, descriptor) {
        if (arguments.length === 1) {
            return reactiveMembrane.getProxy(target);
        }
        return createTrackedPropertyDescriptor(target, prop, isUndefined(descriptor) ? true : descriptor.enumerable === true);
    }
    function createTrackedPropertyDescriptor(Ctor, key, enumerable) {
        return {
            get() {
                const vm = getComponentVM(this);
                observeMutation(this, key);
                return vm.cmpTrack[key];
            },
            set(newValue) {
                const vm = getComponentVM(this);
                const reactiveOrAnyValue = reactiveMembrane.getProxy(newValue);
                if (reactiveOrAnyValue !== vm.cmpTrack[key]) {
                    vm.cmpTrack[key] = reactiveOrAnyValue;
                    if (isFalse(vm.isDirty)) {
                        // perf optimization to skip this step if the track property is on a component that is already dirty
                        notifyMutation(this, key);
                    }
                }
            },
            enumerable,
            configurable: true,
        };
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function wireDecorator(target, prop, descriptor) {
        return createTrackedPropertyDescriptor(target, prop, isObject$1(descriptor) ? descriptor.enumerable === true : true);
    }
    /**
     * @wire decorator to wire fields and methods to a wire adapter in
     * LWC Components. This function implements the internals of this
     * decorator.
     */
    function wire(_adapter, _config) {
        const len = arguments.length;
        if (len > 0 && len < 3) {
            return wireDecorator;
        }
        else {
            throw new TypeError();
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * @api decorator to mark public fields and public methods in
     * LWC Components. This function implements the internals of this
     * decorator.
     */
    function api$1(target, propName, descriptor) {
        const meta = getDecoratorsRegisteredMeta(target);
        // initializing getters and setters for each public prop on the target prototype
        if (isObject$1(descriptor) && (isFunction(descriptor.get) || isFunction(descriptor.set))) {
            // if it is configured as an accessor it must have a descriptor
            // @ts-ignore it must always be set before calling this method
            meta.props[propName].config = isFunction(descriptor.set) ? 3 : 1;
            return createPublicAccessorDescriptor(target, propName, descriptor);
        }
        else {
            // @ts-ignore it must always be set before calling this method
            meta.props[propName].config = 0;
            return createPublicPropertyDescriptor(target, propName, descriptor);
        }
    }
    function createPublicPropertyDescriptor(proto, key, descriptor) {
        return {
            get() {
                const vm = getComponentVM(this);
                if (isBeingConstructed(vm)) {
                    return;
                }
                observeMutation(this, key);
                return vm.cmpProps[key];
            },
            set(newValue) {
                const vm = getComponentVM(this);
                vm.cmpProps[key] = newValue;
                // avoid notification of observability if the instance is already dirty
                if (isFalse(vm.isDirty)) {
                    // perf optimization to skip this step if the component is dirty already.
                    notifyMutation(this, key);
                }
            },
            enumerable: isUndefined(descriptor) ? true : descriptor.enumerable,
        };
    }
    function createPublicAccessorDescriptor(Ctor, key, descriptor) {
        const { get, set, enumerable } = descriptor;
        if (!isFunction(get)) {
            throw new TypeError();
        }
        return {
            get() {
                return get.call(this);
            },
            set(newValue) {
                const vm = getComponentVM(this);
                if (set) {
                    set.call(this, newValue);
                }
            },
            enumerable,
        };
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function allows for the registration of "services" in
     * LWC by exposing hooks into the component life-cycle. This API is subject
     * to change or being removed.
     */
    function decorate(Ctor, decorators) {
        // intentionally comparing decorators with null and undefined
        if (!isFunction(Ctor) || decorators == null) {
            throw new TypeError();
        }
        const props = getOwnPropertyNames(decorators);
        // intentionally allowing decoration of classes only for now
        const target = Ctor.prototype;
        for (let i = 0, len = props.length; i < len; i += 1) {
            const propName = props[i];
            const decorator = decorators[propName];
            if (!isFunction(decorator)) {
                throw new TypeError();
            }
            const originalDescriptor = getOwnPropertyDescriptor(target, propName);
            const descriptor = decorator(Ctor, propName, originalDescriptor);
            if (!isUndefined(descriptor)) {
                defineProperty(target, propName, descriptor);
            }
        }
        return Ctor; // chaining
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const signedDecoratorToMetaMap = new Map();
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */
    function registerDecorators(Ctor, meta) {
        const decoratorMap = create(null);
        const props = getPublicPropertiesHash(Ctor, meta.publicProps);
        const methods = getPublicMethodsHash(Ctor, meta.publicMethods);
        const wire$1 = getWireHash(Ctor, meta.wire);
        const track$1 = getTrackHash(Ctor, meta.track);
        signedDecoratorToMetaMap.set(Ctor, {
            props,
            methods,
            wire: wire$1,
            track: track$1,
        });
        for (const propName in props) {
            decoratorMap[propName] = api$1;
        }
        if (wire$1) {
            for (const propName in wire$1) {
                const wireDef = wire$1[propName];
                if (wireDef.method) {
                    // for decorated methods we need to do nothing
                    continue;
                }
                decoratorMap[propName] = wire(wireDef.adapter, wireDef.params);
            }
        }
        if (track$1) {
            for (const propName in track$1) {
                decoratorMap[propName] = track;
            }
        }
        decorate(Ctor, decoratorMap);
        return Ctor;
    }
    function getDecoratorsRegisteredMeta(Ctor) {
        return signedDecoratorToMetaMap.get(Ctor);
    }
    function getTrackHash(target, track) {
        if (isUndefined(track) || getOwnPropertyNames(track).length === 0) {
            return EmptyObject;
        }
        // TODO: #1302 - check that anything in `track` is correctly defined in the prototype
        return assign(create(null), track);
    }
    function getWireHash(target, wire) {
        if (isUndefined(wire) || getOwnPropertyNames(wire).length === 0) {
            return;
        }
        // TODO: #1302 - check that anything in `wire` is correctly defined in the prototype
        return assign(create(null), wire);
    }
    function getPublicPropertiesHash(target, props) {
        if (isUndefined(props) || getOwnPropertyNames(props).length === 0) {
            return EmptyObject;
        }
        return getOwnPropertyNames(props).reduce((propsHash, propName) => {
            const attr = getAttrNameFromPropName(propName);
            propsHash[propName] = assign({
                config: 0,
                type: 'any',
                attr,
            }, props[propName]);
            return propsHash;
        }, create(null));
    }
    function getPublicMethodsHash(target, publicMethods) {
        if (isUndefined(publicMethods) || publicMethods.length === 0) {
            return EmptyObject;
        }
        return publicMethods.reduce((methodsHash, methodName) => {
            methodsHash[methodName] = target.prototype[methodName];
            return methodsHash;
        }, create(null));
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const CtorToDefMap = new WeakMap();
    function getCtorProto(Ctor, subclassComponentName) {
        let proto = getPrototypeOf(Ctor);
        if (isNull(proto)) {
            throw new ReferenceError(`Invalid prototype chain for ${subclassComponentName}, you must extend LightningElement.`);
        }
        // covering the cases where the ref is circular in AMD
        if (isCircularModuleDependency(proto)) {
            const p = resolveCircularModuleDependency(proto);
            // escape hatch for Locker and other abstractions to provide their own base class instead
            // of our Base class without having to leak it to user-land. If the circular function returns
            // itself, that's the signal that we have hit the end of the proto chain, which must always
            // be base.
            proto = p === proto ? BaseLightningElement : p;
        }
        return proto;
    }
    function createComponentDef(Ctor, meta, subclassComponentName) {
        const { name } = meta;
        let { template } = meta;
        let decoratorsMeta = getDecoratorsRegisteredMeta(Ctor);
        // TODO: #1295 - refactor tests that are using this declaration manually
        if (isUndefined(decoratorsMeta)) {
            registerDecorators(Ctor, {
                publicMethods: getOwnValue(Ctor, 'publicMethods'),
                publicProps: getOwnValue(Ctor, 'publicProps'),
                track: getOwnValue(Ctor, 'track'),
                wire: getOwnValue(Ctor, 'wire'),
            });
            decoratorsMeta = getDecoratorsRegisteredMeta(Ctor);
        }
        let { props, methods, wire, track } = decoratorsMeta || EmptyObject;
        const proto = Ctor.prototype;
        let { connectedCallback, disconnectedCallback, renderedCallback, errorCallback, render, } = proto;
        const superProto = getCtorProto(Ctor, subclassComponentName);
        const superDef = superProto !== BaseLightningElement
            ? getComponentDef(superProto, subclassComponentName)
            : null;
        const SuperBridge = isNull(superDef) ? BaseBridgeElement : superDef.bridge;
        const bridge = HTMLBridgeElementFactory(SuperBridge, getOwnPropertyNames(props), getOwnPropertyNames(methods));
        if (!isNull(superDef)) {
            props = assign(create(null), superDef.props, props);
            methods = assign(create(null), superDef.methods, methods);
            wire = superDef.wire || wire ? assign(create(null), superDef.wire, wire) : undefined;
            track = assign(create(null), superDef.track, track);
            connectedCallback = connectedCallback || superDef.connectedCallback;
            disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;
            renderedCallback = renderedCallback || superDef.renderedCallback;
            errorCallback = errorCallback || superDef.errorCallback;
            render = render || superDef.render;
            template = template || superDef.template;
        }
        props = assign(create(null), HTML_PROPS, props);
        if (isUndefined(template)) {
            // default template
            template = defaultEmptyTemplate;
        }
        const def = {
            ctor: Ctor,
            name,
            wire,
            track,
            props,
            methods,
            bridge,
            template,
            connectedCallback,
            disconnectedCallback,
            renderedCallback,
            errorCallback,
            render,
        };
        return def;
    }
    /**
     * EXPERIMENTAL: This function allows for the identification of LWC
     * constructors. This API is subject to change or being removed.
     */
    function isComponentConstructor(ctor) {
        if (!isFunction(ctor)) {
            return false;
        }
        // Fast path: LightningElement is part of the prototype chain of the constructor.
        if (ctor.prototype instanceof BaseLightningElement) {
            return true;
        }
        // Slow path: LightningElement is not part of the prototype chain of the constructor, we need
        // climb up the constructor prototype chain to check in case there are circular dependencies
        // to resolve.
        let current = ctor;
        do {
            if (isCircularModuleDependency(current)) {
                const circularResolved = resolveCircularModuleDependency(current);
                // If the circular function returns itself, that's the signal that we have hit the end of the proto chain,
                // which must always be a valid base constructor.
                if (circularResolved === current) {
                    return true;
                }
                current = circularResolved;
            }
            if (current === BaseLightningElement) {
                return true;
            }
        } while (!isNull(current) && (current = getPrototypeOf(current)));
        // Finally return false if the LightningElement is not part of the prototype chain.
        return false;
    }
    function getOwnValue(o, key) {
        const d = getOwnPropertyDescriptor(o, key);
        return d && d.value;
    }
    /**
     * EXPERIMENTAL: This function allows for the collection of internal
     * component metadata. This API is subject to change or being removed.
     */
    function getComponentDef(Ctor, subclassComponentName) {
        let def = CtorToDefMap.get(Ctor);
        if (isUndefined(def)) {
            if (!isComponentConstructor(Ctor)) {
                throw new TypeError(`${Ctor} is not a valid component, or does not extends LightningElement from "lwc". You probably forgot to add the extend clause on the class declaration.`);
            }
            let meta = getComponentRegisteredMeta(Ctor);
            if (isUndefined(meta)) {
                // TODO: #1295 - remove this workaround after refactoring tests
                meta = {
                    template: undefined,
                    name: Ctor.name,
                };
            }
            def = createComponentDef(Ctor, meta, subclassComponentName || Ctor.name);
            CtorToDefMap.set(Ctor, def);
        }
        return def;
    }
    /**
     * EXPERIMENTAL: This function provides access to the component constructor,
     * given an HTMLElement. This API is subject to change or being removed.
     */
    function getComponentConstructor(elm) {
        let ctor = null;
        if (elm instanceof HTMLElement) {
            const vm = getInternalField(elm, ViewModelReflection);
            if (!isUndefined(vm)) {
                ctor = vm.def.ctor;
            }
        }
        return ctor;
    }
    // Only set prototype for public methods and properties
    // No DOM Patching occurs here
    function setElementProto(elm, def) {
        setPrototypeOf(elm, def.bridge.prototype);
    }
    // Typescript is inferring the wrong function type for this particular
    // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
    // @ts-ignore type-mismatch
    const HTML_PROPS = ArrayReduce.call(getOwnPropertyNames(HTMLElementOriginalDescriptors), (props, propName) => {
        const attrName = getAttrNameFromPropName(propName);
        props[propName] = {
            config: 3,
            type: 'any',
            attr: attrName,
        };
        return props;
    }, create(null));

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Object of type ShadowRoot for instance checks
    const GlobalShadowRoot = window.ShadowRoot;
    var VMState;
    (function (VMState) {
        VMState[VMState["created"] = 0] = "created";
        VMState[VMState["connected"] = 1] = "connected";
        VMState[VMState["disconnected"] = 2] = "disconnected";
    })(VMState || (VMState = {}));
    let idx = 0;
    function callHook(cmp, fn, args = []) {
        return fn.apply(cmp, args);
    }
    function setHook(cmp, prop, newValue) {
        cmp[prop] = newValue;
    }
    function getHook(cmp, prop) {
        return cmp[prop];
    }
    function rerenderVM(vm) {
        rehydrate(vm);
    }
    function appendRootVM(vm) {
        runConnectedCallback(vm);
        rehydrate(vm);
    }
    function appendVM(vm) {
        runConnectedCallback(vm);
        rehydrate(vm);
    }
    // just in case the component comes back, with this we guarantee re-rendering it
    // while preventing any attempt to rehydration until after reinsertion.
    function resetComponentStateWhenRemoved(vm) {
        const { state } = vm;
        if (state !== VMState.disconnected) {
            runDisconnectedCallback(vm);
            // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)
            runShadowChildNodesDisconnectedCallback(vm);
            runLightChildNodesDisconnectedCallback(vm);
        }
    }
    // this method is triggered by the diffing algo only when a vnode from the
    // old vnode.children is removed from the DOM.
    function removeVM(vm) {
        resetComponentStateWhenRemoved(vm);
    }
    // this method is triggered by the removal of a root element from the DOM.
    function removeRootVM(vm) {
        resetComponentStateWhenRemoved(vm);
    }
    function createVM(elm, Ctor, options) {
        const def = getComponentDef(Ctor);
        const { isRoot, mode, owner } = options;
        idx += 1;
        const uninitializedVm = {
            // component creation index is defined once, and never reset, it can
            // be preserved from one insertion to another without any issue
            idx,
            state: VMState.created,
            isScheduled: false,
            isDirty: true,
            isRoot: isTrue(isRoot),
            mode,
            def,
            owner,
            elm,
            data: EmptyObject,
            context: create(null),
            cmpTemplate: undefined,
            cmpProps: create(null),
            cmpTrack: create(null),
            cmpSlots: useSyntheticShadow ? create(null) : undefined,
            callHook,
            setHook,
            getHook,
            component: undefined,
            children: EmptyArray,
            aChildren: EmptyArray,
            velements: EmptyArray,
            // used to track down all object-key pairs that makes this vm reactive
            deps: [],
        };
        // create component instance associated to the vm and the element
        createComponent(uninitializedVm, Ctor);
        // link component to the wire service
        const initializedVm = uninitializedVm;
        linkComponent(initializedVm);
    }
    function rehydrate(vm) {
        if (isTrue(vm.isDirty)) {
            const children = renderComponent(vm);
            patchShadowRoot(vm, children);
        }
    }
    function patchShadowRoot(vm, newCh) {
        const { cmpRoot, children: oldCh } = vm;
        vm.children = newCh; // caching the new children collection
        if (newCh.length > 0 || oldCh.length > 0) {
            // patch function mutates vnodes by adding the element reference,
            // however, if patching fails it contains partial changes.
            if (oldCh !== newCh) {
                const fn = hasDynamicChildren(newCh) ? updateDynamicChildren : updateStaticChildren;
                runWithBoundaryProtection(vm, vm, () => {
                }, () => {
                    // job
                    fn(cmpRoot, oldCh, newCh);
                }, () => {
                });
            }
        }
        if (vm.state === VMState.connected) {
            // If the element is connected, that means connectedCallback was already issued, and
            // any successive rendering should finish with the call to renderedCallback, otherwise
            // the connectedCallback will take care of calling it in the right order at the end of
            // the current rehydration process.
            runRenderedCallback(vm);
        }
    }
    function runRenderedCallback(vm) {
        const { rendered } = Services;
        if (rendered) {
            invokeServiceHook(vm, rendered);
        }
        const { renderedCallback } = vm.def;
        if (!isUndefined(renderedCallback)) {
            invokeComponentCallback(vm, renderedCallback);
        }
    }
    let rehydrateQueue = [];
    function flushRehydrationQueue() {
        startGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);
        const vms = rehydrateQueue.sort((a, b) => a.idx - b.idx);
        rehydrateQueue = []; // reset to a new queue
        for (let i = 0, len = vms.length; i < len; i += 1) {
            const vm = vms[i];
            try {
                rehydrate(vm);
            }
            catch (error) {
                if (i + 1 < len) {
                    // pieces of the queue are still pending to be rehydrated, those should have priority
                    if (rehydrateQueue.length === 0) {
                        addCallbackToNextTick(flushRehydrationQueue);
                    }
                    ArrayUnshift$1.apply(rehydrateQueue, ArraySlice$1.call(vms, i + 1));
                }
                // we need to end the measure before throwing.
                endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);
                // re-throwing the original error will break the current tick, but since the next tick is
                // already scheduled, it should continue patching the rest.
                throw error; // eslint-disable-line no-unsafe-finally
            }
        }
        endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);
    }
    function runConnectedCallback(vm) {
        const { state } = vm;
        if (state === VMState.connected) {
            return; // nothing to do since it was already connected
        }
        vm.state = VMState.connected;
        // reporting connection
        const { connected } = Services;
        if (connected) {
            invokeServiceHook(vm, connected);
        }
        const { connectedCallback } = vm.def;
        if (!isUndefined(connectedCallback)) {
            invokeComponentCallback(vm, connectedCallback);
        }
    }
    function runDisconnectedCallback(vm) {
        if (isFalse(vm.isDirty)) {
            // this guarantees that if the component is reused/reinserted,
            // it will be re-rendered because we are disconnecting the reactivity
            // linking, so mutations are not automatically reflected on the state
            // of disconnected components.
            vm.isDirty = true;
        }
        clearReactiveListeners(vm);
        vm.state = VMState.disconnected;
        // reporting disconnection
        const { disconnected } = Services;
        if (disconnected) {
            invokeServiceHook(vm, disconnected);
        }
        const { disconnectedCallback } = vm.def;
        if (!isUndefined(disconnectedCallback)) {
            invokeComponentCallback(vm, disconnectedCallback);
        }
    }
    function runShadowChildNodesDisconnectedCallback(vm) {
        const { velements: vCustomElementCollection } = vm;
        // reporting disconnection for every child in inverse order since they are inserted in reserved order
        for (let i = vCustomElementCollection.length - 1; i >= 0; i -= 1) {
            const elm = vCustomElementCollection[i].elm;
            // There are two cases where the element could be undefined:
            // * when there is an error during the construction phase, and an
            //   error boundary picks it, there is a possibility that the VCustomElement
            //   is not properly initialized, and therefore is should be ignored.
            // * when slotted custom element is not used by the element where it is slotted
            //   into it, as a result, the custom element was never initialized.
            if (!isUndefined(elm)) {
                const childVM = getCustomElementVM(elm);
                resetComponentStateWhenRemoved(childVM);
            }
        }
    }
    function runLightChildNodesDisconnectedCallback(vm) {
        const { aChildren: adoptedChildren } = vm;
        recursivelyDisconnectChildren(adoptedChildren);
    }
    /**
     * The recursion doesn't need to be a complete traversal of the vnode graph,
     * instead it can be partial, when a custom element vnode is found, we don't
     * need to continue into its children because by attempting to disconnect the
     * custom element itself will trigger the removal of anything slotted or anything
     * defined on its shadow.
     */
    function recursivelyDisconnectChildren(vnodes) {
        for (let i = 0, len = vnodes.length; i < len; i += 1) {
            const vnode = vnodes[i];
            if (!isNull(vnode) && isArray$1(vnode.children) && !isUndefined(vnode.elm)) {
                // vnode is a VElement with children
                if (isUndefined(vnode.ctor)) {
                    // it is a VElement, just keep looking (recursively)
                    recursivelyDisconnectChildren(vnode.children);
                }
                else {
                    // it is a VCustomElement, disconnect it and ignore its children
                    resetComponentStateWhenRemoved(getCustomElementVM(vnode.elm));
                }
            }
        }
    }
    // This is a super optimized mechanism to remove the content of the shadowRoot
    // without having to go into snabbdom. Especially useful when the reset is a consequence
    // of an error, in which case the children VNodes might not be representing the current
    // state of the DOM
    function resetShadowRoot(vm) {
        vm.children = EmptyArray;
        ShadowRootInnerHTMLSetter.call(vm.cmpRoot, '');
        // disconnecting any known custom element inside the shadow of the this vm
        runShadowChildNodesDisconnectedCallback(vm);
    }
    function scheduleRehydration(vm) {
        if (!vm.isScheduled) {
            vm.isScheduled = true;
            if (rehydrateQueue.length === 0) {
                addCallbackToNextTick(flushRehydrationQueue);
            }
            ArrayPush.call(rehydrateQueue, vm);
        }
    }
    function getErrorBoundaryVMFromOwnElement(vm) {
        const { elm } = vm;
        return getErrorBoundaryVM(elm);
    }
    function getErrorBoundaryVM(startingElement) {
        let elm = startingElement;
        let vm;
        while (!isNull(elm)) {
            vm = getInternalField(elm, ViewModelReflection);
            if (!isUndefined(vm) && !isUndefined(vm.def.errorCallback)) {
                return vm;
            }
            elm = getParentOrHostElement(elm);
        }
    }
    /**
     * Returns the component stack. Used for errors messages only.
     *
     * @param {Element} startingElement
     *
     * @return {string} The component stack for errors.
     */
    function getErrorComponentStack(startingElement) {
        const wcStack = [];
        let elm = startingElement;
        do {
            const currentVm = getInternalField(elm, ViewModelReflection);
            if (!isUndefined(currentVm)) {
                const tagName = tagNameGetter.call(elm);
                const is = elm.getAttribute('is');
                ArrayPush.call(wcStack, `<${StringToLowerCase.call(tagName)}${is ? ' is="${is}' : ''}>`);
            }
            elm = getParentOrHostElement(elm);
        } while (!isNull(elm));
        return wcStack.reverse().join('\n\t');
    }
    /**
     * Finds the parent of the specified element. If shadow DOM is enabled, finds
     * the host of the shadow root to escape the shadow boundary.
     */
    function getParentOrHostElement(elm) {
        const parentElement = parentElementGetter.call(elm);
        // If parentElement is a shadow root, find the host instead
        return isNull(parentElement) ? getHostElement(elm) : parentElement;
    }
    /**
     * Finds the host element, if it exists.
     */
    function getHostElement(elm) {
        const parentNode = parentNodeGetter.call(elm);
        return parentNode instanceof GlobalShadowRoot
            ? ShadowRootHostGetter.call(parentNode)
            : null;
    }
    /**
     * EXPERIMENTAL: This function detects whether or not a Node is
     * controlled by a LWC template. This API is subject to
     * change or being removed.
     */
    function isNodeFromTemplate(node) {
        if (isFalse(node instanceof Node)) {
            return false;
        }
        // TODO: #1250 - skipping the shadowRoot instances itself makes no sense, we need to revisit this with locker
        if (node instanceof GlobalShadowRoot) {
            return false;
        }
        if (useSyntheticShadow) {
            // TODO: #1252 - old behavior that is still used by some pieces of the platform, specifically, nodes inserted
            // manually on places where `lwc:dom="manual"` directive is not used, will be considered global elements.
            if (isUndefined(node.$shadowResolver$)) {
                return false;
            }
        }
        const root = node.getRootNode();
        return root instanceof GlobalShadowRoot;
    }
    function getCustomElementVM(elm) {
        return getInternalField(elm, ViewModelReflection);
    }
    function getComponentVM(component) {
        return getHiddenField(component, ViewModelReflection);
    }
    // slow path routine
    // NOTE: we should probably more this routine to the synthetic shadow folder
    // and get the allocation to be cached by in the elm instead of in the VM
    function allocateInSlot(vm, children) {
        const { cmpSlots: oldSlots } = vm;
        const cmpSlots = (vm.cmpSlots = create(null));
        for (let i = 0, len = children.length; i < len; i += 1) {
            const vnode = children[i];
            if (isNull(vnode)) {
                continue;
            }
            const { data } = vnode;
            const slotName = ((data.attrs && data.attrs.slot) || '');
            const vnodes = (cmpSlots[slotName] = cmpSlots[slotName] || []);
            // re-keying the vnodes is necessary to avoid conflicts with default content for the slot
            // which might have similar keys. Each vnode will always have a key that
            // starts with a numeric character from compiler. In this case, we add a unique
            // notation for slotted vnodes keys, e.g.: `@foo:1:1`
            vnode.key = `@${slotName}:${vnode.key}`;
            ArrayPush.call(vnodes, vnode);
        }
        if (isFalse(vm.isDirty)) {
            // We need to determine if the old allocation is really different from the new one
            // and mark the vm as dirty
            const oldKeys = keys(oldSlots);
            if (oldKeys.length !== keys(cmpSlots).length) {
                markComponentAsDirty(vm);
                return;
            }
            for (let i = 0, len = oldKeys.length; i < len; i += 1) {
                const key = oldKeys[i];
                if (isUndefined(cmpSlots[key]) || oldSlots[key].length !== cmpSlots[key].length) {
                    markComponentAsDirty(vm);
                    return;
                }
                const oldVNodes = oldSlots[key];
                const vnodes = cmpSlots[key];
                for (let j = 0, a = cmpSlots[key].length; j < a; j += 1) {
                    if (oldVNodes[j] !== vnodes[j]) {
                        markComponentAsDirty(vm);
                        return;
                    }
                }
            }
        }
    }
    function runWithBoundaryProtection(vm, owner, pre, job, post) {
        let error;
        pre();
        try {
            job();
        }
        catch (e) {
            error = Object(e);
        }
        finally {
            post();
            if (!isUndefined(error)) {
                error.wcStack = error.wcStack || getErrorComponentStack(vm.elm);
                const errorBoundaryVm = isNull(owner)
                    ? undefined
                    : getErrorBoundaryVMFromOwnElement(owner);
                if (isUndefined(errorBoundaryVm)) {
                    throw error; // eslint-disable-line no-unsafe-finally
                }
                resetShadowRoot(vm); // remove offenders
                // error boundaries must have an ErrorCallback
                const errorCallback = errorBoundaryVm.def.errorCallback;
                invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);
            }
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    const ConnectingSlot = createFieldName('connecting');
    const DisconnectingSlot = createFieldName('disconnecting');
    function callNodeSlot(node, slot) {
        const fn = getInternalField(node, slot);
        if (!isUndefined(fn)) {
            fn();
        }
        return node; // for convenience
    }
    // monkey patching Node methods to be able to detect the insertions and removal of
    // root elements created via createElement.
    assign(Node.prototype, {
        appendChild(newChild) {
            const appendedNode = appendChild.call(this, newChild);
            return callNodeSlot(appendedNode, ConnectingSlot);
        },
        insertBefore(newChild, referenceNode) {
            const insertedNode = insertBefore.call(this, newChild, referenceNode);
            return callNodeSlot(insertedNode, ConnectingSlot);
        },
        removeChild(oldChild) {
            const removedNode = removeChild.call(this, oldChild);
            return callNodeSlot(removedNode, DisconnectingSlot);
        },
        replaceChild(newChild, oldChild) {
            const replacedNode = replaceChild.call(this, newChild, oldChild);
            callNodeSlot(replacedNode, DisconnectingSlot);
            callNodeSlot(newChild, ConnectingSlot);
            return replacedNode;
        },
    });
    /**
     * EXPERIMENTAL: This function is almost identical to document.createElement
     * (https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)
     * with the slightly difference that in the options, you can pass the `is`
     * property set to a Constructor instead of just a string value. The intent
     * is to allow the creation of an element controlled by LWC without having
     * to register the element as a custom element. E.g.:
     *
     * const el = createElement('x-foo', { is: FooCtor });
     *
     * If the value of `is` attribute is not a constructor,
     * then it throws a TypeError.
     */
    function createElement(sel, options) {
        if (!isObject$1(options) || isNull(options)) {
            throw new TypeError(`"createElement" function expects an object as second parameter but received "${toString(options)}".`);
        }
        let Ctor = options.is;
        if (!isFunction(Ctor)) {
            throw new TypeError(`"createElement" function expects a "is" option with a valid component constructor.`);
        }
        const mode = options.mode !== 'closed' ? 'open' : 'closed';
        // Create element with correct tagName
        const element = document.createElement(sel);
        if (!isUndefined(getInternalField(element, ViewModelReflection))) {
            // There is a possibility that a custom element is registered under tagName,
            // in which case, the initialization is already carry on, and there is nothing else
            // to do here.
            return element;
        }
        if (isCircularModuleDependency(Ctor)) {
            Ctor = resolveCircularModuleDependency(Ctor);
        }
        const def = getComponentDef(Ctor);
        setElementProto(element, def);
        if (isTrue(useSyntheticShadow)) {
            patchCustomElementProto(element, {
                def,
            });
        }
        // In case the element is not initialized already, we need to carry on the manual creation
        createVM(element, Ctor, { mode, isRoot: true, owner: null });
        // Handle insertion and removal from the DOM manually
        setInternalField(element, ConnectingSlot, () => {
            const vm = getCustomElementVM(element);
            startGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm);
            if (vm.state === VMState.connected) {
                // usually means moving the element from one place to another, which is observable via life-cycle hooks
                removeRootVM(vm);
            }
            appendRootVM(vm);
            endGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm);
        });
        setInternalField(element, DisconnectingSlot, () => {
            const vm = getCustomElementVM(element);
            removeRootVM(vm);
        });
        return element;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function allows you to create a reactive readonly
     * membrane around any object value. This API is subject to change or
     * being removed.
     */
    function readonly(obj) {
        return reactiveMembrane.getReadOnlyProxy(obj);
    }

    /**
     * This function builds a Web Component class from a LWC constructor
     * so it can be registered as a new element via customElements.define()
     * at any given time. E.g.:
     *
     *      import { buildCustomElementConstructor } from 'lwc';
     *      import Foo from 'ns/foo';
     *      const WC = buildCustomElementConstructor(Foo);
     *      customElements.define('x-foo', Foo);
     *      const elm = document.createElement('x-foo');
     *
     */
    function buildCustomElementConstructor(Ctor, options) {
        var _a;
        const { props, bridge: BaseElement } = getComponentDef(Ctor);
        const normalizedOptions = {
            mode: 'open',
            isRoot: true,
            owner: null,
        };
        if (isObject$1(options) && !isNull(options)) {
            const { mode } = options;
            if (mode === 'closed') {
                normalizedOptions.mode = mode;
            }
        }
        return _a = class extends BaseElement {
                constructor() {
                    super();
                    if (isTrue(useSyntheticShadow)) {
                        const def = getComponentDef(Ctor);
                        patchCustomElementProto(this, {
                            def,
                        });
                    }
                    createVM(this, Ctor, normalizedOptions);
                }
                connectedCallback() {
                    const vm = getCustomElementVM(this);
                    appendRootVM(vm);
                }
                disconnectedCallback() {
                    const vm = getCustomElementVM(this);
                    removeRootVM(vm);
                }
                attributeChangedCallback(attrName, oldValue, newValue) {
                    if (oldValue === newValue) {
                        // ignoring similar values for better perf
                        return;
                    }
                    const propName = getPropNameFromAttrName(attrName);
                    if (isUndefined(props[propName])) {
                        // ignoring unknown attributes
                        return;
                    }
                    if (!isAttributeLocked(this, attrName)) {
                        // ignoring changes triggered by the engine itself during:
                        // * diffing when public props are attempting to reflect to the DOM
                        // * component via `this.setAttribute()`, should never update the prop.
                        // Both cases, the the setAttribute call is always wrap by the unlocking
                        // of the attribute to be changed
                        return;
                    }
                    // reflect attribute change to the corresponding props when changed
                    // from outside.
                    this[propName] = newValue;
                }
            },
            // collecting all attribute names from all public props to apply
            // the reflection from attributes to props via attributeChangedCallback.
            _a.observedAttributes = ArrayMap.call(getOwnPropertyNames(props), propName => props[propName].attr),
            _a;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    exports.LightningElement = BaseLightningElement;
    exports.api = api$1;
    exports.buildCustomElementConstructor = buildCustomElementConstructor;
    exports.createElement = createElement;
    exports.decorate = decorate;
    exports.getComponentConstructor = getComponentConstructor;
    exports.getComponentDef = getComponentDef;
    exports.isComponentConstructor = isComponentConstructor;
    exports.isNodeFromTemplate = isNodeFromTemplate;
    exports.readonly = readonly;
    exports.register = register;
    exports.registerComponent = registerComponent;
    exports.registerDecorators = registerDecorators;
    exports.registerTemplate = registerTemplate;
    exports.sanitizeAttribute = sanitizeAttribute;
    exports.track = track;
    exports.unwrap = unwrap$1;
    exports.wire = wire;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
/** version: 1.0.2-222.23 */
