"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const utils_1 = require("./utils");
const vm_1 = require("./vm");
const events_1 = __importDefault(require("./modules/events"));
const attrs_1 = __importDefault(require("./modules/attrs"));
const props_1 = __importDefault(require("./modules/props"));
const computed_class_attr_1 = __importDefault(require("./modules/computed-class-attr"));
const computed_style_attr_1 = __importDefault(require("./modules/computed-style-attr"));
const static_class_attr_1 = __importDefault(require("./modules/static-class-attr"));
const static_style_attr_1 = __importDefault(require("./modules/static-style-attr"));
const context_1 = __importDefault(require("./modules/context"));
const patch_1 = require("./patch");
const snabbdom_1 = require("../3rdparty/snabbdom/snabbdom");
const restrictions_1 = require("./restrictions");
const patch_2 = require("./patch");
const def_1 = require("./def");
const noop = () => void 0;
function observeElementChildNodes(elm) {
    elm.$domManual$ = true;
}
function setElementShadowToken(elm, token) {
    elm.$shadowToken$ = token;
}
function updateNodeHook(oldVnode, vnode) {
    const { text } = vnode;
    if (oldVnode.text !== text) {
        if (process.env.NODE_ENV !== 'production') {
            restrictions_1.unlockDomMutation();
        }
        /**
         * Compiler will never produce a text property that is not string
         */
        vnode.elm.nodeValue = text;
        if (process.env.NODE_ENV !== 'production') {
            restrictions_1.lockDomMutation();
        }
    }
}
exports.updateNodeHook = updateNodeHook;
function insertNodeHook(vnode, parentNode, referenceNode) {
    if (process.env.NODE_ENV !== 'production') {
        restrictions_1.unlockDomMutation();
    }
    parentNode.insertBefore(vnode.elm, referenceNode);
    if (process.env.NODE_ENV !== 'production') {
        restrictions_1.lockDomMutation();
    }
}
exports.insertNodeHook = insertNodeHook;
function removeNodeHook(vnode, parentNode) {
    if (process.env.NODE_ENV !== 'production') {
        restrictions_1.unlockDomMutation();
    }
    parentNode.removeChild(vnode.elm);
    if (process.env.NODE_ENV !== 'production') {
        restrictions_1.lockDomMutation();
    }
}
exports.removeNodeHook = removeNodeHook;
function createTextHook(vnode) {
    const text = vnode.elm;
    if (language_1.isTrue(utils_1.useSyntheticShadow)) {
        patch_2.patchTextNodeProto(text);
    }
}
exports.createTextHook = createTextHook;
function createCommentHook(vnode) {
    const comment = vnode.elm;
    if (language_1.isTrue(utils_1.useSyntheticShadow)) {
        patch_2.patchCommentNodeProto(comment);
    }
}
exports.createCommentHook = createCommentHook;
function createElmHook(vnode) {
    events_1.default.create(vnode);
    // Attrs need to be applied to element before props
    // IE11 will wipe out value on radio inputs if value
    // is set before type=radio.
    attrs_1.default.create(vnode);
    props_1.default.create(vnode);
    static_class_attr_1.default.create(vnode);
    static_style_attr_1.default.create(vnode);
    computed_class_attr_1.default.create(vnode);
    computed_style_attr_1.default.create(vnode);
    context_1.default.create(vnode);
}
exports.createElmHook = createElmHook;
var LWCDOMMode;
(function (LWCDOMMode) {
    LWCDOMMode["manual"] = "manual";
})(LWCDOMMode || (LWCDOMMode = {}));
function fallbackElmHook(vnode) {
    const { owner, sel } = vnode;
    const elm = vnode.elm;
    if (language_1.isTrue(utils_1.useSyntheticShadow)) {
        const { data: { context }, } = vnode;
        const { shadowAttribute } = owner.context;
        if (!language_1.isUndefined(context) &&
            !language_1.isUndefined(context.lwc) &&
            context.lwc.dom === LWCDOMMode.manual) {
            // this element will now accept any manual content inserted into it
            observeElementChildNodes(elm);
        }
        // when running in synthetic shadow mode, we need to set the shadowToken value
        // into each element from the template, so they can be styled accordingly.
        setElementShadowToken(elm, shadowAttribute);
        patch_2.patchElementProto(elm, { sel });
    }
    if (process.env.NODE_ENV !== 'production') {
        const { data: { context }, } = vnode;
        const isPortal = !language_1.isUndefined(context) &&
            !language_1.isUndefined(context.lwc) &&
            context.lwc.dom === LWCDOMMode.manual;
        restrictions_1.patchElementWithRestrictions(elm, { isPortal });
    }
}
exports.fallbackElmHook = fallbackElmHook;
function updateElmHook(oldVnode, vnode) {
    // Attrs need to be applied to element before props
    // IE11 will wipe out value on radio inputs if value
    // is set before type=radio.
    attrs_1.default.update(oldVnode, vnode);
    props_1.default.update(oldVnode, vnode);
    computed_class_attr_1.default.update(oldVnode, vnode);
    computed_style_attr_1.default.update(oldVnode, vnode);
}
exports.updateElmHook = updateElmHook;
function insertCustomElmHook(vnode) {
    const vm = vm_1.getCustomElementVM(vnode.elm);
    vm_1.appendVM(vm);
}
exports.insertCustomElmHook = insertCustomElmHook;
function updateChildrenHook(oldVnode, vnode) {
    const { children, owner } = vnode;
    const fn = patch_1.hasDynamicChildren(children) ? snabbdom_1.updateDynamicChildren : snabbdom_1.updateStaticChildren;
    vm_1.runWithBoundaryProtection(owner, owner.owner, noop, () => {
        fn(vnode.elm, oldVnode.children, children);
    }, noop);
}
exports.updateChildrenHook = updateChildrenHook;
function allocateChildrenHook(vnode) {
    const elm = vnode.elm;
    const vm = vm_1.getCustomElementVM(elm);
    const { children } = vnode;
    vm.aChildren = children;
    if (language_1.isTrue(utils_1.useSyntheticShadow)) {
        // slow path
        vm_1.allocateInSlot(vm, children);
        // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!
        vnode.children = utils_1.EmptyArray;
    }
}
exports.allocateChildrenHook = allocateChildrenHook;
function createViewModelHook(vnode) {
    const elm = vnode.elm;
    if (language_1.hasOwnProperty.call(elm, utils_1.ViewModelReflection)) {
        // There is a possibility that a custom element is registered under tagName,
        // in which case, the initialization is already carry on, and there is nothing else
        // to do here since this hook is called right after invoking `document.createElement`.
        return;
    }
    const { mode, ctor, owner } = vnode;
    const def = def_1.getComponentDef(ctor);
    def_1.setElementProto(elm, def);
    if (language_1.isTrue(utils_1.useSyntheticShadow)) {
        const { shadowAttribute } = owner.context;
        // when running in synthetic shadow mode, we need to set the shadowToken value
        // into each element from the template, so they can be styled accordingly.
        setElementShadowToken(elm, shadowAttribute);
        patch_2.patchCustomElementProto(elm, { def });
    }
    vm_1.createVM(elm, ctor, {
        mode,
        owner,
    });
    const vm = vm_1.getCustomElementVM(elm);
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.isTrue(language_1.isArray(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);
    }
    if (process.env.NODE_ENV !== 'production') {
        restrictions_1.patchCustomElementWithRestrictions(elm, utils_1.EmptyObject);
    }
}
exports.createViewModelHook = createViewModelHook;
function createCustomElmHook(vnode) {
    events_1.default.create(vnode);
    // Attrs need to be applied to element before props
    // IE11 will wipe out value on radio inputs if value
    // is set before type=radio.
    attrs_1.default.create(vnode);
    props_1.default.create(vnode);
    static_class_attr_1.default.create(vnode);
    static_style_attr_1.default.create(vnode);
    computed_class_attr_1.default.create(vnode);
    computed_style_attr_1.default.create(vnode);
    context_1.default.create(vnode);
}
exports.createCustomElmHook = createCustomElmHook;
function createChildrenHook(vnode) {
    const { elm, children } = vnode;
    for (let j = 0; j < children.length; ++j) {
        const ch = children[j];
        if (ch != null) {
            ch.hook.create(ch);
            ch.hook.insert(ch, elm, null);
        }
    }
}
exports.createChildrenHook = createChildrenHook;
function rerenderCustomElmHook(vnode) {
    const vm = vm_1.getCustomElementVM(vnode.elm);
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.isTrue(language_1.isArray(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);
    }
    vm_1.rerenderVM(vm);
}
exports.rerenderCustomElmHook = rerenderCustomElmHook;
function updateCustomElmHook(oldVnode, vnode) {
    // Attrs need to be applied to element before props
    // IE11 will wipe out value on radio inputs if value
    // is set before type=radio.
    attrs_1.default.update(oldVnode, vnode);
    props_1.default.update(oldVnode, vnode);
    computed_class_attr_1.default.update(oldVnode, vnode);
    computed_style_attr_1.default.update(oldVnode, vnode);
}
exports.updateCustomElmHook = updateCustomElmHook;
function removeElmHook(vnode) {
    // this method only needs to search on child vnodes from template
    // to trigger the remove hook just in case some of those children
    // are custom elements.
    const { children, elm } = vnode;
    for (let j = 0, len = children.length; j < len; ++j) {
        const ch = children[j];
        if (!language_1.isNull(ch)) {
            ch.hook.remove(ch, elm);
        }
    }
}
exports.removeElmHook = removeElmHook;
function removeCustomElmHook(vnode) {
    // for custom elements we don't have to go recursively because the removeVM routine
    // will take care of disconnecting any child VM attached to its shadow as well.
    vm_1.removeVM(vm_1.getCustomElementVM(vnode.elm));
}
exports.removeCustomElmHook = removeCustomElmHook;
//# sourceMappingURL=hooks.js.map