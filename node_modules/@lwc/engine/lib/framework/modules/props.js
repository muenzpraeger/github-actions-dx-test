"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../../shared/assert"));
const language_1 = require("../../shared/language");
const fields_1 = require("../../shared/fields");
const utils_1 = require("../utils");
const base_bridge_element_1 = require("../base-bridge-element");
const attributes_1 = require("../attributes");
function isLiveBindingProp(sel, key) {
    // For special whitelisted properties, we check against the actual property value on the DOM element instead of
    // relying on tracked property values.
    return sel === 'input' && (key === 'value' || key === 'checked');
}
function update(oldVnode, vnode) {
    const props = vnode.data.props;
    if (language_1.isUndefined(props)) {
        return;
    }
    const oldProps = oldVnode.data.props;
    if (oldProps === props) {
        return;
    }
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(language_1.isUndefined(oldProps) || language_1.keys(oldProps).join(',') === language_1.keys(props).join(','), 'vnode.data.props cannot change shape.');
    }
    const elm = vnode.elm;
    const vm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);
    const isFirstPatch = language_1.isUndefined(oldProps);
    const isCustomElement = !language_1.isUndefined(vm);
    const { sel } = vnode;
    for (const key in props) {
        const cur = props[key];
        if (process.env.NODE_ENV !== 'production') {
            if (!(key in elm)) {
                // TODO: #1297 - Move this validation to the compiler
                assert_1.default.fail(`Unknown public property "${key}" of element <${sel}>. This is likely a typo on the corresponding attribute "${attributes_1.getAttrNameFromPropName(key)}".`);
            }
        }
        // if it is the first time this element is patched, or the current value is different to the previous value...
        if (isFirstPatch ||
            cur !== (isLiveBindingProp(sel, key) ? elm[key] : oldProps[key])) {
            if (isCustomElement) {
                base_bridge_element_1.prepareForPropUpdate(vm); // this is just in case the vnode is actually a custom element
            }
            elm[key] = cur;
        }
    }
}
const emptyVNode = { data: {} };
exports.default = {
    create: (vnode) => update(emptyVNode, vnode),
    update,
};
//# sourceMappingURL=props.js.map