"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * This module is responsible for producing the ComponentDef object that is always
 * accessible via `vm.def`. This is lazily created during the creation of the first
 * instance of a component class, and shared across all instances.
 *
 * This structure can be used to synthetically create proxies, and understand the
 * shape of a component. It is also used internally to apply extra optimizations.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const html_properties_1 = require("./html-properties");
const restrictions_1 = require("./restrictions");
const component_1 = require("./component");
const fields_1 = require("../shared/fields");
const utils_1 = require("./utils");
const invoker_1 = require("./invoker");
const vm_1 = require("./vm");
const watcher_1 = require("./watcher");
const dom_1 = require("../env/dom");
const restrictions_2 = require("./restrictions");
const attributes_1 = require("./attributes");
const GlobalEvent = Event; // caching global reference to avoid poisoning
/**
 * This operation is called with a descriptor of an standard html property
 * that a Custom Element can support (including AOM properties), which
 * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors
 * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.
 */
function createBridgeToElementDescriptor(propName, descriptor) {
    const { get, set, enumerable, configurable } = descriptor;
    if (!language_1.isFunction(get)) {
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard getter.`);
        }
        throw new TypeError();
    }
    if (!language_1.isFunction(set)) {
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard setter.`);
        }
        throw new TypeError();
    }
    return {
        enumerable,
        configurable,
        get() {
            const vm = vm_1.getComponentVM(this);
            if (process.env.NODE_ENV !== 'production') {
                assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
            }
            if (invoker_1.isBeingConstructed(vm)) {
                if (process.env.NODE_ENV !== 'production') {
                    const name = vm.elm.constructor.name;
                    assert_1.default.logError(`\`${name}\` constructor can't read the value of property \`${propName}\` because the owner component hasn't set the value yet. Instead, use the \`${name}\` constructor to set a default value for the property.`, vm.elm);
                }
                return;
            }
            watcher_1.observeMutation(this, propName);
            return get.call(vm.elm);
        },
        set(newValue) {
            const vm = vm_1.getComponentVM(this);
            if (process.env.NODE_ENV !== 'production') {
                assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${vm}.${propName}`);
                assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `Failed to construct '${component_1.getComponentAsString(this)}': The result must not have attributes.`);
                assert_1.default.invariant(!language_1.isObject(newValue) || language_1.isNull(newValue), `Invalid value "${newValue}" for "${propName}" of ${vm}. Value cannot be an object, must be a primitive value.`);
            }
            if (newValue !== vm.cmpProps[propName]) {
                vm.cmpProps[propName] = newValue;
                if (language_1.isFalse(vm.isDirty)) {
                    // perf optimization to skip this step if not in the DOM
                    watcher_1.notifyMutation(this, propName);
                }
            }
            return set.call(vm.elm, newValue);
        },
    };
}
function getLinkedElement(cmp) {
    return vm_1.getComponentVM(cmp).elm;
}
/**
 * This class is the base class for any LWC element.
 * Some elements directly extends this class, others implement it via inheritance.
 **/
function BaseLightningElement() {
    // This should be as performant as possible, while any initialization should be done lazily
    if (language_1.isNull(invoker_1.vmBeingConstructed)) {
        throw new ReferenceError();
    }
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue('cmpProps' in invoker_1.vmBeingConstructed, `${invoker_1.vmBeingConstructed} is not a vm.`);
        assert_1.default.invariant(invoker_1.vmBeingConstructed.elm instanceof HTMLElement, `Component creation requires a DOM element to be associated to ${invoker_1.vmBeingConstructed}.`);
    }
    const vm = invoker_1.vmBeingConstructed;
    const { elm, mode, def: { ctor }, } = vm;
    const component = this;
    vm.component = component;
    // interaction hooks
    // We are intentionally hiding this argument from the formal API of LWCElement because
    // we don't want folks to know about it just yet.
    if (arguments.length === 1) {
        const { callHook, setHook, getHook } = arguments[0];
        vm.callHook = callHook;
        vm.setHook = setHook;
        vm.getHook = getHook;
    }
    // attaching the shadowRoot
    const shadowRootOptions = {
        mode,
        delegatesFocus: !!ctor.delegatesFocus,
    };
    const cmpRoot = elm.attachShadow(shadowRootOptions);
    // linking elm, shadow root and component with the VM
    fields_1.setHiddenField(component, utils_1.ViewModelReflection, vm);
    fields_1.setInternalField(elm, utils_1.ViewModelReflection, vm);
    fields_1.setInternalField(cmpRoot, utils_1.ViewModelReflection, vm);
    // VM is now initialized
    vm.cmpRoot = cmpRoot;
    if (process.env.NODE_ENV !== 'production') {
        restrictions_2.patchComponentWithRestrictions(component);
        restrictions_2.patchShadowRootWithRestrictions(cmpRoot, utils_1.EmptyObject);
    }
}
exports.BaseLightningElement = BaseLightningElement;
// HTML Element - The Good Parts
BaseLightningElement.prototype = {
    constructor: BaseLightningElement,
    dispatchEvent(event) {
        const elm = getLinkedElement(this);
        const vm = vm_1.getComponentVM(this);
        if (process.env.NODE_ENV !== 'production') {
            if (arguments.length === 0) {
                throw new Error(`Failed to execute 'dispatchEvent' on ${component_1.getComponentAsString(this)}: 1 argument required, but only 0 present.`);
            }
            if (!(event instanceof GlobalEvent)) {
                throw new Error(`Failed to execute 'dispatchEvent' on ${component_1.getComponentAsString(this)}: parameter 1 is not of type 'Event'.`);
            }
            const { type: evtName } = event;
            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.dispatchEvent() should not be called during the construction of the custom element for ${component_1.getComponentAsString(this)} because no one is listening for the event "${evtName}" just yet.`);
            if (!/^[a-z][a-z0-9_]*$/.test(evtName)) {
                assert_1.default.logError(`Invalid event type "${evtName}" dispatched in element ${component_1.getComponentAsString(this)}. Event name must ${[
                    '1) Start with a lowercase letter',
                    '2) Contain only lowercase letters, numbers, and underscores',
                ].join(' ')}`, elm);
            }
        }
        return dom_1.dispatchEvent.call(elm, event);
    },
    addEventListener(type, listener, options) {
        const vm = vm_1.getComponentVM(this);
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
            assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${vm} by adding an event listener for "${type}".`);
            assert_1.default.invariant(language_1.isFunction(listener), `Invalid second argument for this.addEventListener() in ${vm} for event "${type}". Expected an EventListener but received ${listener}.`);
        }
        const wrappedListener = component_1.getWrappedComponentsListener(vm, listener);
        vm.elm.addEventListener(type, wrappedListener, options);
    },
    removeEventListener(type, listener, options) {
        const vm = vm_1.getComponentVM(this);
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        }
        const wrappedListener = component_1.getWrappedComponentsListener(vm, listener);
        vm.elm.removeEventListener(type, wrappedListener, options);
    },
    setAttributeNS(ns, attrName, _value) {
        const elm = getLinkedElement(this);
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm_1.getComponentVM(this)), `Failed to construct '${component_1.getComponentAsString(this)}': The result must not have attributes.`);
        }
        attributes_1.unlockAttribute(elm, attrName);
        // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch
        elm.setAttributeNS.apply(elm, arguments);
        attributes_1.lockAttribute(elm, attrName);
    },
    removeAttributeNS(ns, attrName) {
        const elm = getLinkedElement(this);
        attributes_1.unlockAttribute(elm, attrName);
        // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch
        elm.removeAttributeNS.apply(elm, arguments);
        attributes_1.lockAttribute(elm, attrName);
    },
    removeAttribute(attrName) {
        const elm = getLinkedElement(this);
        attributes_1.unlockAttribute(elm, attrName);
        // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch
        elm.removeAttribute.apply(elm, arguments);
        attributes_1.lockAttribute(elm, attrName);
    },
    setAttribute(attrName, _value) {
        const elm = getLinkedElement(this);
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm_1.getComponentVM(this)), `Failed to construct '${component_1.getComponentAsString(this)}': The result must not have attributes.`);
        }
        attributes_1.unlockAttribute(elm, attrName);
        // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch
        elm.setAttribute.apply(elm, arguments);
        attributes_1.lockAttribute(elm, attrName);
    },
    getAttribute(attrName) {
        const elm = getLinkedElement(this);
        attributes_1.unlockAttribute(elm, attrName);
        // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch
        const value = elm.getAttribute.apply(elm, arguments);
        attributes_1.lockAttribute(elm, attrName);
        return value;
    },
    getAttributeNS(ns, attrName) {
        const elm = getLinkedElement(this);
        attributes_1.unlockAttribute(elm, attrName);
        // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch
        const value = elm.getAttributeNS.apply(elm, arguments);
        attributes_1.lockAttribute(elm, attrName);
        return value;
    },
    getBoundingClientRect() {
        const elm = getLinkedElement(this);
        if (process.env.NODE_ENV !== 'production') {
            const vm = vm_1.getComponentVM(this);
            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.getBoundingClientRect() should not be called during the construction of the custom element for ${component_1.getComponentAsString(this)} because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks.`);
        }
        return elm.getBoundingClientRect();
    },
    /**
     * Returns the first element that is a descendant of node that
     * matches selectors.
     */
    // querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;
    // querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;
    querySelector(selectors) {
        const vm = vm_1.getComponentVM(this);
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.querySelector() cannot be called during the construction of the custom element for ${component_1.getComponentAsString(this)} because no children has been added to this element yet.`);
        }
        const { elm } = vm;
        return elm.querySelector(selectors);
    },
    /**
     * Returns all element descendants of node that
     * match selectors.
     */
    // querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>,
    // querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>,
    querySelectorAll(selectors) {
        const vm = vm_1.getComponentVM(this);
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.querySelectorAll() cannot be called during the construction of the custom element for ${component_1.getComponentAsString(this)} because no children has been added to this element yet.`);
        }
        const { elm } = vm;
        return elm.querySelectorAll(selectors);
    },
    /**
     * Returns all element descendants of node that
     * match the provided tagName.
     */
    getElementsByTagName(tagNameOrWildCard) {
        const vm = vm_1.getComponentVM(this);
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.getElementsByTagName() cannot be called during the construction of the custom element for ${component_1.getComponentAsString(this)} because no children has been added to this element yet.`);
        }
        const { elm } = vm;
        return elm.getElementsByTagName(tagNameOrWildCard);
    },
    /**
     * Returns all element descendants of node that
     * match the provide classnames.
     */
    getElementsByClassName(names) {
        const vm = vm_1.getComponentVM(this);
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.getElementsByClassName() cannot be called during the construction of the custom element for ${component_1.getComponentAsString(this)} because no children has been added to this element yet.`);
        }
        const { elm } = vm;
        return elm.getElementsByClassName(names);
    },
    get classList() {
        if (process.env.NODE_ENV !== 'production') {
            const vm = vm_1.getComponentVM(this);
            // TODO: #1290 - this still fails in dev but works in production, eventually, we should just throw in all modes
            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `Failed to construct ${vm}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`);
        }
        return getLinkedElement(this).classList;
    },
    get template() {
        const vm = vm_1.getComponentVM(this);
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        }
        return vm.cmpRoot;
    },
    get shadowRoot() {
        // From within the component instance, the shadowRoot is always
        // reported as "closed". Authors should rely on this.template instead.
        return null;
    },
    render() {
        const vm = vm_1.getComponentVM(this);
        return vm.def.template;
    },
    toString() {
        const vm = vm_1.getComponentVM(this);
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        }
        return `[object ${vm.def.name}]`;
    },
};
// Typescript is inferring the wrong function type for this particular
// overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
// @ts-ignore type-mismatch
const baseDescriptors = language_1.ArrayReduce.call(language_1.getOwnPropertyNames(html_properties_1.HTMLElementOriginalDescriptors), (descriptors, propName) => {
    descriptors[propName] = createBridgeToElementDescriptor(propName, html_properties_1.HTMLElementOriginalDescriptors[propName]);
    return descriptors;
}, language_1.create(null));
language_1.defineProperties(BaseLightningElement.prototype, baseDescriptors);
if (process.env.NODE_ENV !== 'production') {
    restrictions_1.patchLightningElementPrototypeWithRestrictions(BaseLightningElement.prototype);
}
language_1.freeze(BaseLightningElement);
language_1.seal(BaseLightningElement.prototype);
//# sourceMappingURL=base-lightning-element.js.map