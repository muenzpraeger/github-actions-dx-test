"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * This module is responsible for producing the ComponentDef object that is always
 * accessible via `vm.def`. This is lazily created during the creation of the first
 * instance of a component class, and shared across all instances.
 *
 * This structure can be used to synthetically create proxies, and understand the
 * shape of a component. It is also used internally to apply extra optimizations.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const fields_1 = require("../shared/fields");
const attributes_1 = require("./attributes");
const utils_1 = require("./utils");
const component_1 = require("./component");
const CtorToDefMap = new WeakMap();
function getCtorProto(Ctor, subclassComponentName) {
    let proto = language_1.getPrototypeOf(Ctor);
    if (language_1.isNull(proto)) {
        throw new ReferenceError(`Invalid prototype chain for ${subclassComponentName}, you must extend LightningElement.`);
    }
    // covering the cases where the ref is circular in AMD
    if (utils_1.isCircularModuleDependency(proto)) {
        const p = utils_1.resolveCircularModuleDependency(proto);
        if (process.env.NODE_ENV !== 'production') {
            if (language_1.isNull(p)) {
                throw new ReferenceError(`Circular module dependency for ${subclassComponentName}, must resolve to a constructor that extends LightningElement.`);
            }
        }
        // escape hatch for Locker and other abstractions to provide their own base class instead
        // of our Base class without having to leak it to user-land. If the circular function returns
        // itself, that's the signal that we have hit the end of the proto chain, which must always
        // be base.
        proto = p === proto ? base_lightning_element_1.BaseLightningElement : p;
    }
    return proto;
}
function createComponentDef(Ctor, meta, subclassComponentName) {
    if (process.env.NODE_ENV !== 'production') {
        // local to dev block
        const ctorName = Ctor.name;
        // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.
        // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a "name" property with string value, but found ${ctorName}.`);
        assert_1.default.isTrue(Ctor.constructor, `Missing ${ctorName}.constructor, ${ctorName} should have a "constructor" property.`);
    }
    const { name } = meta;
    let { template } = meta;
    let decoratorsMeta = register_1.getDecoratorsRegisteredMeta(Ctor);
    // TODO: #1295 - refactor tests that are using this declaration manually
    if (language_1.isUndefined(decoratorsMeta)) {
        register_1.registerDecorators(Ctor, {
            publicMethods: getOwnValue(Ctor, 'publicMethods'),
            publicProps: getOwnValue(Ctor, 'publicProps'),
            track: getOwnValue(Ctor, 'track'),
            wire: getOwnValue(Ctor, 'wire'),
        });
        decoratorsMeta = register_1.getDecoratorsRegisteredMeta(Ctor);
    }
    let { props, methods, wire, track } = decoratorsMeta || utils_1.EmptyObject;
    const proto = Ctor.prototype;
    let { connectedCallback, disconnectedCallback, renderedCallback, errorCallback, render, } = proto;
    const superProto = getCtorProto(Ctor, subclassComponentName);
    const superDef = superProto !== base_lightning_element_1.BaseLightningElement
        ? getComponentDef(superProto, subclassComponentName)
        : null;
    const SuperBridge = language_1.isNull(superDef) ? base_bridge_element_1.BaseBridgeElement : superDef.bridge;
    const bridge = base_bridge_element_1.HTMLBridgeElementFactory(SuperBridge, language_1.getOwnPropertyNames(props), language_1.getOwnPropertyNames(methods));
    if (!language_1.isNull(superDef)) {
        props = language_1.assign(language_1.create(null), superDef.props, props);
        methods = language_1.assign(language_1.create(null), superDef.methods, methods);
        wire = superDef.wire || wire ? language_1.assign(language_1.create(null), superDef.wire, wire) : undefined;
        track = language_1.assign(language_1.create(null), superDef.track, track);
        connectedCallback = connectedCallback || superDef.connectedCallback;
        disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;
        renderedCallback = renderedCallback || superDef.renderedCallback;
        errorCallback = errorCallback || superDef.errorCallback;
        render = render || superDef.render;
        template = template || superDef.template;
    }
    props = language_1.assign(language_1.create(null), HTML_PROPS, props);
    if (language_1.isUndefined(template)) {
        // default template
        template = secure_template_1.defaultEmptyTemplate;
    }
    const def = {
        ctor: Ctor,
        name,
        wire,
        track,
        props,
        methods,
        bridge,
        template,
        connectedCallback,
        disconnectedCallback,
        renderedCallback,
        errorCallback,
        render,
    };
    if (process.env.NODE_ENV !== 'production') {
        language_1.freeze(Ctor.prototype);
    }
    return def;
}
/**
 * EXPERIMENTAL: This function allows for the identification of LWC
 * constructors. This API is subject to change or being removed.
 */
function isComponentConstructor(ctor) {
    if (!language_1.isFunction(ctor)) {
        return false;
    }
    // Fast path: LightningElement is part of the prototype chain of the constructor.
    if (ctor.prototype instanceof base_lightning_element_1.BaseLightningElement) {
        return true;
    }
    // Slow path: LightningElement is not part of the prototype chain of the constructor, we need
    // climb up the constructor prototype chain to check in case there are circular dependencies
    // to resolve.
    let current = ctor;
    do {
        if (utils_1.isCircularModuleDependency(current)) {
            const circularResolved = utils_1.resolveCircularModuleDependency(current);
            // If the circular function returns itself, that's the signal that we have hit the end of the proto chain,
            // which must always be a valid base constructor.
            if (circularResolved === current) {
                return true;
            }
            current = circularResolved;
        }
        if (current === base_lightning_element_1.BaseLightningElement) {
            return true;
        }
    } while (!language_1.isNull(current) && (current = language_1.getPrototypeOf(current)));
    // Finally return false if the LightningElement is not part of the prototype chain.
    return false;
}
exports.isComponentConstructor = isComponentConstructor;
function getOwnValue(o, key) {
    const d = language_1.getOwnPropertyDescriptor(o, key);
    return d && d.value;
}
/**
 * EXPERIMENTAL: This function allows for the collection of internal
 * component metadata. This API is subject to change or being removed.
 */
function getComponentDef(Ctor, subclassComponentName) {
    let def = CtorToDefMap.get(Ctor);
    if (language_1.isUndefined(def)) {
        if (!isComponentConstructor(Ctor)) {
            throw new TypeError(`${Ctor} is not a valid component, or does not extends LightningElement from "lwc". You probably forgot to add the extend clause on the class declaration.`);
        }
        let meta = component_1.getComponentRegisteredMeta(Ctor);
        if (language_1.isUndefined(meta)) {
            // TODO: #1295 - remove this workaround after refactoring tests
            meta = {
                template: undefined,
                name: Ctor.name,
            };
        }
        def = createComponentDef(Ctor, meta, subclassComponentName || Ctor.name);
        CtorToDefMap.set(Ctor, def);
    }
    return def;
}
exports.getComponentDef = getComponentDef;
/**
 * EXPERIMENTAL: This function provides access to the component constructor,
 * given an HTMLElement. This API is subject to change or being removed.
 */
function getComponentConstructor(elm) {
    let ctor = null;
    if (elm instanceof HTMLElement) {
        const vm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);
        if (!language_1.isUndefined(vm)) {
            ctor = vm.def.ctor;
        }
    }
    return ctor;
}
exports.getComponentConstructor = getComponentConstructor;
// Only set prototype for public methods and properties
// No DOM Patching occurs here
function setElementProto(elm, def) {
    language_1.setPrototypeOf(elm, def.bridge.prototype);
}
exports.setElementProto = setElementProto;
const html_properties_1 = require("./html-properties");
const base_lightning_element_1 = require("./base-lightning-element");
const base_bridge_element_1 = require("./base-bridge-element");
const register_1 = require("./decorators/register");
const secure_template_1 = require("./secure-template");
// Typescript is inferring the wrong function type for this particular
// overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
// @ts-ignore type-mismatch
const HTML_PROPS = language_1.ArrayReduce.call(language_1.getOwnPropertyNames(html_properties_1.HTMLElementOriginalDescriptors), (props, propName) => {
    const attrName = attributes_1.getAttrNameFromPropName(propName);
    props[propName] = {
        config: 3,
        type: 'any',
        attr: attrName,
    };
    return props;
}, language_1.create(null));
//# sourceMappingURL=def.js.map