"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const element_1 = require("../env/element");
const language_1 = require("../shared/language");
var GlobalMeasurementPhase;
(function (GlobalMeasurementPhase) {
    GlobalMeasurementPhase["REHYDRATE"] = "lwc-rehydrate";
    GlobalMeasurementPhase["HYDRATE"] = "lwc-hydrate";
})(GlobalMeasurementPhase = exports.GlobalMeasurementPhase || (exports.GlobalMeasurementPhase = {}));
// Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.
// JSDom (used in Jest) for example doesn't implement the UserTiming APIs.
const isUserTimingSupported = typeof performance !== 'undefined' &&
    typeof performance.mark === 'function' &&
    typeof performance.clearMarks === 'function' &&
    typeof performance.measure === 'function' &&
    typeof performance.clearMeasures === 'function';
function getMarkName(phase, vm) {
    return `<${language_1.StringToLowerCase.call(element_1.tagNameGetter.call(vm.elm))} (${vm.idx})> - ${phase}`;
}
function start(markName) {
    performance.mark(markName);
}
function end(measureName, markName) {
    performance.measure(measureName, markName);
    // Clear the created marks and measure to avoid filling the performance entries buffer.
    // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.
    performance.clearMarks(markName);
    performance.clearMarks(measureName);
}
function noop() {
    /* do nothing */
}
exports.startMeasure = !isUserTimingSupported
    ? noop
    : function (phase, vm) {
        const markName = getMarkName(phase, vm);
        start(markName);
    };
exports.endMeasure = !isUserTimingSupported
    ? noop
    : function (phase, vm) {
        const markName = getMarkName(phase, vm);
        end(markName, markName);
    };
// Global measurements can be nested into each others (e.g. nested component creation via createElement). In those cases
// the VM is used to create unique mark names at each level.
exports.startGlobalMeasure = !isUserTimingSupported
    ? noop
    : function (phase, vm) {
        const markName = language_1.isUndefined(vm) ? phase : getMarkName(phase, vm);
        start(markName);
    };
exports.endGlobalMeasure = !isUserTimingSupported
    ? noop
    : function (phase, vm) {
        const markName = language_1.isUndefined(vm) ? phase : getMarkName(phase, vm);
        end(phase, markName);
    };
//# sourceMappingURL=performance-timing.js.map