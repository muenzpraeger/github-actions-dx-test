"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const invoker_1 = require("./invoker");
const language_1 = require("../shared/language");
const utils_1 = require("./utils");
const hooks_1 = require("./hooks");
const patch_1 = require("./patch");
const services_1 = require("./services");
const restrictions_1 = require("./restrictions");
const CHAR_S = 115;
const CHAR_V = 118;
const CHAR_G = 103;
const NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';
const SymbolIterator = Symbol.iterator;
const TextHook = {
    create: (vnode) => {
        vnode.elm = document.createTextNode(vnode.text);
        linkNodeToShadow(vnode);
        if (process.env.NODE_ENV !== 'production') {
            restrictions_1.markNodeFromVNode(vnode.elm);
        }
        hooks_1.createTextHook(vnode);
    },
    update: hooks_1.updateNodeHook,
    insert: hooks_1.insertNodeHook,
    move: hooks_1.insertNodeHook,
    remove: hooks_1.removeNodeHook,
};
const CommentHook = {
    create: (vnode) => {
        vnode.elm = document.createComment(vnode.text);
        linkNodeToShadow(vnode);
        if (process.env.NODE_ENV !== 'production') {
            restrictions_1.markNodeFromVNode(vnode.elm);
        }
        hooks_1.createCommentHook(vnode);
    },
    update: hooks_1.updateNodeHook,
    insert: hooks_1.insertNodeHook,
    move: hooks_1.insertNodeHook,
    remove: hooks_1.removeNodeHook,
};
// insert is called after update, which is used somewhere else (via a module)
// to mark the vm as inserted, that means we cannot use update as the main channel
// to rehydrate when dirty, because sometimes the element is not inserted just yet,
// which breaks some invariants. For that reason, we have the following for any
// Custom Element that is inserted via a template.
const ElementHook = {
    create: (vnode) => {
        const { data, sel, clonedElement } = vnode;
        const { ns } = data;
        // TODO: issue #1364 - supporting the ability to inject a cloned StyleElement
        // via a vnode this is used for style tags for native shadow
        if (language_1.isUndefined(clonedElement)) {
            vnode.elm = language_1.isUndefined(ns)
                ? document.createElement(sel)
                : document.createElementNS(ns, sel);
        }
        else {
            vnode.elm = clonedElement;
        }
        linkNodeToShadow(vnode);
        if (process.env.NODE_ENV !== 'production') {
            restrictions_1.markNodeFromVNode(vnode.elm);
        }
        hooks_1.fallbackElmHook(vnode);
        hooks_1.createElmHook(vnode);
    },
    update: (oldVnode, vnode) => {
        hooks_1.updateElmHook(oldVnode, vnode);
        hooks_1.updateChildrenHook(oldVnode, vnode);
    },
    insert: (vnode, parentNode, referenceNode) => {
        hooks_1.insertNodeHook(vnode, parentNode, referenceNode);
        hooks_1.createChildrenHook(vnode);
    },
    move: (vnode, parentNode, referenceNode) => {
        hooks_1.insertNodeHook(vnode, parentNode, referenceNode);
    },
    remove: (vnode, parentNode) => {
        hooks_1.removeNodeHook(vnode, parentNode);
        hooks_1.removeElmHook(vnode);
    },
};
const CustomElementHook = {
    create: (vnode) => {
        const { sel } = vnode;
        vnode.elm = document.createElement(sel);
        linkNodeToShadow(vnode);
        if (process.env.NODE_ENV !== 'production') {
            restrictions_1.markNodeFromVNode(vnode.elm);
        }
        hooks_1.createViewModelHook(vnode);
        hooks_1.allocateChildrenHook(vnode);
        hooks_1.createCustomElmHook(vnode);
    },
    update: (oldVnode, vnode) => {
        hooks_1.updateCustomElmHook(oldVnode, vnode);
        // in fallback mode, the allocation will always set children to
        // empty and delegate the real allocation to the slot elements
        hooks_1.allocateChildrenHook(vnode);
        // in fallback mode, the children will be always empty, so, nothing
        // will happen, but in native, it does allocate the light dom
        hooks_1.updateChildrenHook(oldVnode, vnode);
        // this will update the shadowRoot
        hooks_1.rerenderCustomElmHook(vnode);
    },
    insert: (vnode, parentNode, referenceNode) => {
        hooks_1.insertNodeHook(vnode, parentNode, referenceNode);
        hooks_1.createChildrenHook(vnode);
        hooks_1.insertCustomElmHook(vnode);
    },
    move: (vnode, parentNode, referenceNode) => {
        hooks_1.insertNodeHook(vnode, parentNode, referenceNode);
    },
    remove: (vnode, parentNode) => {
        hooks_1.removeNodeHook(vnode, parentNode);
        hooks_1.removeCustomElmHook(vnode);
    },
};
function linkNodeToShadow(vnode) {
    // TODO: #1164 - this should eventually be done by the polyfill directly
    vnode.elm.$shadowResolver$ = vnode.owner.cmpRoot.$shadowResolver$;
}
// TODO: #1136 - this should be done by the compiler, adding ns to every sub-element
function addNS(vnode) {
    const { data, children, sel } = vnode;
    data.ns = NamespaceAttributeForSVG;
    // TODO: #1275 - review why `sel` equal `foreignObject` should get this `ns`
    if (language_1.isArray(children) && sel !== 'foreignObject') {
        for (let j = 0, n = children.length; j < n; ++j) {
            const childNode = children[j];
            if (childNode != null && childNode.hook === ElementHook) {
                addNS(childNode);
            }
        }
    }
}
function addVNodeToChildLWC(vnode) {
    language_1.ArrayPush.call(invoker_1.vmBeingRendered.velements, vnode);
}
// [h]tml node
function h(sel, data, children) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(language_1.isString(sel), `h() 1st argument sel must be a string.`);
        assert_1.default.isTrue(language_1.isObject(data), `h() 2nd argument data must be an object.`);
        assert_1.default.isTrue(language_1.isArray(children), `h() 3rd argument children must be an array.`);
        assert_1.default.isTrue('key' in data, ` <${sel}> "key" attribute is invalid or missing for ${invoker_1.vmBeingRendered}. Key inside iterator is either undefined or null.`);
        // checking reserved internal data properties
        assert_1.default.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);
        assert_1.default.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);
        if (data.style && !language_1.isString(data.style)) {
            assert_1.default.logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, invoker_1.vmBeingRendered.elm);
        }
        language_1.forEach.call(children, (childVnode) => {
            if (childVnode != null) {
                assert_1.default.isTrue(childVnode &&
                    'sel' in childVnode &&
                    'data' in childVnode &&
                    'children' in childVnode &&
                    'text' in childVnode &&
                    'elm' in childVnode &&
                    'key' in childVnode, `${childVnode} is not a vnode.`);
            }
        });
    }
    const { key } = data;
    let text, elm;
    const vnode = {
        sel,
        data,
        children,
        text,
        elm,
        key,
        hook: ElementHook,
        owner: invoker_1.vmBeingRendered,
    };
    if (sel.length === 3 &&
        language_1.StringCharCodeAt.call(sel, 0) === CHAR_S &&
        language_1.StringCharCodeAt.call(sel, 1) === CHAR_V &&
        language_1.StringCharCodeAt.call(sel, 2) === CHAR_G) {
        addNS(vnode);
    }
    return vnode;
}
exports.h = h;
// [t]ab[i]ndex function
function ti(value) {
    // if value is greater than 0, we normalize to 0
    // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through
    // If value is less than -1, we don't care
    const shouldNormalize = value > 0 && !(language_1.isTrue(value) || language_1.isFalse(value));
    if (process.env.NODE_ENV !== 'production') {
        if (shouldNormalize) {
            assert_1.default.logError(`Invalid tabindex value \`${language_1.toString(value)}\` in template for ${invoker_1.vmBeingRendered}. This attribute must be set to 0 or -1.`, invoker_1.vmBeingRendered.elm);
        }
    }
    return shouldNormalize ? 0 : value;
}
exports.ti = ti;
// [s]lot element node
function s(slotName, data, children, slotset) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(language_1.isString(slotName), `s() 1st argument slotName must be a string.`);
        assert_1.default.isTrue(language_1.isObject(data), `s() 2nd argument data must be an object.`);
        assert_1.default.isTrue(language_1.isArray(children), `h() 3rd argument children must be an array.`);
    }
    if (!language_1.isUndefined(slotset) &&
        !language_1.isUndefined(slotset[slotName]) &&
        slotset[slotName].length !== 0) {
        children = slotset[slotName];
    }
    const vnode = h('slot', data, children);
    if (utils_1.useSyntheticShadow) {
        // the content of the slot has to be dynamic when in synthetic shadow mode because
        // the `vnode.children` might be the slotted content vs default content, in which case
        // the size and the keys are not matching.
        patch_1.markAsDynamicChildren(children);
    }
    return vnode;
}
exports.s = s;
// [c]ustom element node
function c(sel, Ctor, data, children) {
    if (utils_1.isCircularModuleDependency(Ctor)) {
        Ctor = utils_1.resolveCircularModuleDependency(Ctor);
    }
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(language_1.isString(sel), `c() 1st argument sel must be a string.`);
        assert_1.default.isTrue(language_1.isFunction(Ctor), `c() 2nd argument Ctor must be a function.`);
        assert_1.default.isTrue(language_1.isObject(data), `c() 3nd argument data must be an object.`);
        assert_1.default.isTrue(arguments.length === 3 || language_1.isArray(children), `c() 4nd argument data must be an array.`);
        // checking reserved internal data properties
        assert_1.default.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);
        assert_1.default.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);
        if (data.style && !language_1.isString(data.style)) {
            assert_1.default.logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, invoker_1.vmBeingRendered.elm);
        }
        if (arguments.length === 4) {
            language_1.forEach.call(children, (childVnode) => {
                if (childVnode != null) {
                    assert_1.default.isTrue(childVnode &&
                        'sel' in childVnode &&
                        'data' in childVnode &&
                        'children' in childVnode &&
                        'text' in childVnode &&
                        'elm' in childVnode &&
                        'key' in childVnode, `${childVnode} is not a vnode.`);
                }
            });
        }
    }
    const { key } = data;
    let text, elm;
    children = arguments.length === 3 ? utils_1.EmptyArray : children;
    const vnode = {
        sel,
        data,
        children,
        text,
        elm,
        key,
        hook: CustomElementHook,
        ctor: Ctor,
        owner: invoker_1.vmBeingRendered,
        mode: 'open',
    };
    addVNodeToChildLWC(vnode);
    return vnode;
}
exports.c = c;
// [i]terable node
function i(iterable, factory) {
    const list = [];
    // marking the list as generated from iteration so we can optimize the diffing
    patch_1.markAsDynamicChildren(list);
    if (language_1.isUndefined(iterable) || iterable === null) {
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.logError(`Invalid template iteration for value "${language_1.toString(iterable)}" in ${invoker_1.vmBeingRendered}. It must be an Array or an iterable Object.`, invoker_1.vmBeingRendered.elm);
        }
        return list;
    }
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isFalse(language_1.isUndefined(iterable[SymbolIterator]), `Invalid template iteration for value \`${language_1.toString(iterable)}\` in ${invoker_1.vmBeingRendered}. It must be an array-like object and not \`null\` nor \`undefined\`.`);
    }
    const iterator = iterable[SymbolIterator]();
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(iterator && language_1.isFunction(iterator.next), `Invalid iterator function for "${language_1.toString(iterable)}" in ${invoker_1.vmBeingRendered}.`);
    }
    let next = iterator.next();
    let j = 0;
    let { value, done: last } = next;
    let keyMap;
    let iterationError;
    if (process.env.NODE_ENV !== 'production') {
        keyMap = language_1.create(null);
    }
    while (last === false) {
        // implementing a look-back-approach because we need to know if the element is the last
        next = iterator.next();
        last = next.done;
        // template factory logic based on the previous collected value
        const vnode = factory(value, j, j === 0, last);
        if (language_1.isArray(vnode)) {
            language_1.ArrayPush.apply(list, vnode);
        }
        else {
            language_1.ArrayPush.call(list, vnode);
        }
        if (process.env.NODE_ENV !== 'production') {
            const vnodes = language_1.isArray(vnode) ? vnode : [vnode];
            language_1.forEach.call(vnodes, (childVnode) => {
                if (!language_1.isNull(childVnode) && language_1.isObject(childVnode) && !language_1.isUndefined(childVnode.sel)) {
                    const { key } = childVnode;
                    if (language_1.isString(key) || language_1.isNumber(key)) {
                        if (keyMap[key] === 1 && language_1.isUndefined(iterationError)) {
                            iterationError = `Duplicated "key" attribute value for "<${childVnode.sel}>" in ${invoker_1.vmBeingRendered} for item number ${j}. A key with value "${childVnode.key}" appears more than once in the iteration. Key values must be unique numbers or strings.`;
                        }
                        keyMap[key] = 1;
                    }
                    else if (language_1.isUndefined(iterationError)) {
                        iterationError = `Invalid "key" attribute value in "<${childVnode.sel}>" in ${invoker_1.vmBeingRendered} for item number ${j}. Set a unique "key" value on all iterated child elements.`;
                    }
                }
            });
        }
        // preparing next value
        j += 1;
        value = next.value;
    }
    if (process.env.NODE_ENV !== 'production') {
        if (!language_1.isUndefined(iterationError)) {
            assert_1.default.logError(iterationError, invoker_1.vmBeingRendered.elm);
        }
    }
    return list;
}
exports.i = i;
/**
 * [f]lattening
 */
function f(items) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(language_1.isArray(items), 'flattening api can only work with arrays.');
    }
    const len = items.length;
    const flattened = [];
    // all flattened nodes should be marked as dynamic because
    // flattened nodes are because of a conditional or iteration.
    // We have to mark as dynamic because this could switch from an
    // iterator to "static" text at any time.
    // TODO: #1276 - compiler should give us some sort of indicator to describe whether a vnode is dynamic or not
    patch_1.markAsDynamicChildren(flattened);
    for (let j = 0; j < len; j += 1) {
        const item = items[j];
        if (language_1.isArray(item)) {
            language_1.ArrayPush.apply(flattened, item);
        }
        else {
            language_1.ArrayPush.call(flattened, item);
        }
    }
    return flattened;
}
exports.f = f;
// [t]ext node
function t(text) {
    const data = utils_1.EmptyObject;
    let sel, children, key, elm;
    return {
        sel,
        data,
        children,
        text,
        elm,
        key,
        hook: TextHook,
        owner: invoker_1.vmBeingRendered,
    };
}
exports.t = t;
// comment node
function p(text) {
    const data = utils_1.EmptyObject;
    const sel = '!';
    let children, key, elm;
    return {
        sel,
        data,
        children,
        text,
        elm,
        key,
        hook: CommentHook,
        owner: invoker_1.vmBeingRendered,
    };
}
exports.p = p;
// [d]ynamic value to produce a text vnode
function d(value) {
    if (value == null) {
        return null;
    }
    return t(value);
}
exports.d = d;
// [b]ind function
function b(fn) {
    if (language_1.isNull(invoker_1.vmBeingRendered)) {
        throw new Error();
    }
    const vm = invoker_1.vmBeingRendered;
    return function (event) {
        invoker_1.invokeEventListener(vm, fn, vm.component, event);
    };
}
exports.b = b;
// [f]unction_[b]ind
function fb(fn) {
    if (language_1.isNull(invoker_1.vmBeingRendered)) {
        throw new Error();
    }
    const vm = invoker_1.vmBeingRendered;
    return function () {
        return invoker_1.invokeComponentCallback(vm, fn, language_1.ArraySlice.call(arguments));
    };
}
exports.fb = fb;
// [l]ocator_[l]istener function
function ll(originalHandler, id, context) {
    if (language_1.isNull(invoker_1.vmBeingRendered)) {
        throw new Error();
    }
    const vm = invoker_1.vmBeingRendered;
    // bind the original handler with b() so we can call it
    // after resolving the locator
    const eventListener = b(originalHandler);
    // create a wrapping handler to resolve locator, and
    // then invoke the original handler.
    return function (event) {
        // located service for the locator metadata
        const { context: { locator }, } = vm;
        if (!language_1.isUndefined(locator)) {
            const { locator: locatorService } = services_1.Services;
            if (locatorService) {
                locator.resolved = {
                    target: id,
                    host: locator.id,
                    targetContext: language_1.isFunction(context) && context(),
                    hostContext: language_1.isFunction(locator.context) && locator.context(),
                };
                // a registered `locator` service will be invoked with
                // access to the context.locator.resolved, which will contain:
                // outer id, outer context, inner id, and inner context
                services_1.invokeServiceHook(vm, locatorService);
            }
        }
        // invoke original event listener via b()
        eventListener(event);
    };
}
exports.ll = ll;
// [k]ey function
function k(compilerKey, obj) {
    switch (typeof obj) {
        case 'number':
        case 'string':
            return compilerKey + ':' + obj;
        case 'object':
            if (process.env.NODE_ENV !== 'production') {
                assert_1.default.fail(`Invalid key value "${obj}" in ${invoker_1.vmBeingRendered}. Key must be a string or number.`);
            }
    }
}
exports.k = k;
// [g]lobal [id] function
function gid(id) {
    if (language_1.isUndefined(id) || id === '') {
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.logError(`Invalid id value "${id}". The id attribute must contain a non-empty string.`, invoker_1.vmBeingRendered.elm);
        }
        return id;
    }
    // We remove attributes when they are assigned a value of null
    if (language_1.isNull(id)) {
        return null;
    }
    return `${id}-${invoker_1.vmBeingRendered.idx}`;
}
exports.gid = gid;
// [f]ragment [id] function
function fid(url) {
    if (language_1.isUndefined(url) || url === '') {
        if (process.env.NODE_ENV !== 'production') {
            if (language_1.isUndefined(url)) {
                assert_1.default.logError(`Undefined url value for "href" or "xlink:href" attribute. Expected a non-empty string.`, invoker_1.vmBeingRendered.elm);
            }
        }
        return url;
    }
    // We remove attributes when they are assigned a value of null
    if (language_1.isNull(url)) {
        return null;
    }
    // Apply transformation only for fragment-only-urls
    if (/^#/.test(url)) {
        return `${url}-${invoker_1.vmBeingRendered.idx}`;
    }
    return url;
}
exports.fid = fid;
//# sourceMappingURL=api.js.map