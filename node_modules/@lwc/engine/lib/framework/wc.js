"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const language_1 = require("../shared/language");
const vm_1 = require("./vm");
const utils_1 = require("./utils");
const def_1 = require("./def");
const attributes_1 = require("./attributes");
const patch_1 = require("./patch");
const restrictions_1 = require("./restrictions");
/**
 * This function builds a Web Component class from a LWC constructor
 * so it can be registered as a new element via customElements.define()
 * at any given time. E.g.:
 *
 *      import { buildCustomElementConstructor } from 'lwc';
 *      import Foo from 'ns/foo';
 *      const WC = buildCustomElementConstructor(Foo);
 *      customElements.define('x-foo', Foo);
 *      const elm = document.createElement('x-foo');
 *
 */
function buildCustomElementConstructor(Ctor, options) {
    var _a;
    const { props, bridge: BaseElement } = def_1.getComponentDef(Ctor);
    const normalizedOptions = {
        mode: 'open',
        isRoot: true,
        owner: null,
    };
    if (language_1.isObject(options) && !language_1.isNull(options)) {
        const { mode } = options;
        if (mode === 'closed') {
            normalizedOptions.mode = mode;
        }
    }
    return _a = class extends BaseElement {
            constructor() {
                super();
                if (language_1.isTrue(utils_1.useSyntheticShadow)) {
                    const def = def_1.getComponentDef(Ctor);
                    patch_1.patchCustomElementProto(this, {
                        def,
                    });
                }
                vm_1.createVM(this, Ctor, normalizedOptions);
                if (process.env.NODE_ENV !== 'production') {
                    restrictions_1.patchCustomElementWithRestrictions(this, utils_1.EmptyObject);
                }
            }
            connectedCallback() {
                const vm = vm_1.getCustomElementVM(this);
                vm_1.appendRootVM(vm);
            }
            disconnectedCallback() {
                const vm = vm_1.getCustomElementVM(this);
                vm_1.removeRootVM(vm);
            }
            attributeChangedCallback(attrName, oldValue, newValue) {
                if (oldValue === newValue) {
                    // ignoring similar values for better perf
                    return;
                }
                const propName = attributes_1.getPropNameFromAttrName(attrName);
                if (language_1.isUndefined(props[propName])) {
                    // ignoring unknown attributes
                    return;
                }
                if (!attributes_1.isAttributeLocked(this, attrName)) {
                    // ignoring changes triggered by the engine itself during:
                    // * diffing when public props are attempting to reflect to the DOM
                    // * component via `this.setAttribute()`, should never update the prop.
                    // Both cases, the the setAttribute call is always wrap by the unlocking
                    // of the attribute to be changed
                    return;
                }
                // reflect attribute change to the corresponding props when changed
                // from outside.
                this[propName] = newValue;
            }
        },
        // collecting all attribute names from all public props to apply
        // the reflection from attributes to props via attributeChangedCallback.
        _a.observedAttributes = language_1.ArrayMap.call(language_1.getOwnPropertyNames(props), propName => props[propName].attr),
        _a;
}
exports.buildCustomElementConstructor = buildCustomElementConstructor;
//# sourceMappingURL=wc.js.map