"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const api = __importStar(require("./api"));
const utils_1 = require("./utils");
const element_1 = require("../env/element");
const CachedStyleFragments = language_1.create(null);
function createStyleElement(styleContent) {
    const elm = document.createElement('style');
    elm.type = 'text/css';
    elm.textContent = styleContent;
    return elm;
}
function getCachedStyleElement(styleContent) {
    let fragment = CachedStyleFragments[styleContent];
    if (language_1.isUndefined(fragment)) {
        fragment = document.createDocumentFragment();
        const styleElm = createStyleElement(styleContent);
        fragment.appendChild(styleElm);
        CachedStyleFragments[styleContent] = fragment;
    }
    return fragment.cloneNode(true).firstChild;
}
const globalStyleParent = document.head || document.body || document;
const InsertedGlobalStyleContent = language_1.create(null);
function insertGlobalStyle(styleContent) {
    // inserts the global style when needed, otherwise does nothing
    if (language_1.isUndefined(InsertedGlobalStyleContent[styleContent])) {
        InsertedGlobalStyleContent[styleContent] = true;
        const elm = createStyleElement(styleContent);
        globalStyleParent.appendChild(elm);
    }
}
function createStyleVNode(elm) {
    const vnode = api.h('style', {
        key: 'style',
    }, utils_1.EmptyArray);
    // TODO: issue #1364 - supporting the ability to inject a cloned StyleElement
    // forcing the diffing algo to use the cloned style for native shadow
    vnode.clonedElement = elm;
    return vnode;
}
/**
 * Reset the styling token applied to the host element.
 */
function resetStyleAttributes(vm) {
    const { context, elm } = vm;
    // Remove the style attribute currently applied to the host element.
    const oldHostAttribute = context.hostAttribute;
    if (!language_1.isUndefined(oldHostAttribute)) {
        element_1.removeAttribute.call(elm, oldHostAttribute);
    }
    // Reset the scoping attributes associated to the context.
    context.hostAttribute = context.shadowAttribute = undefined;
}
exports.resetStyleAttributes = resetStyleAttributes;
/**
 * Apply/Update the styling token applied to the host element.
 */
function applyStyleAttributes(vm, hostAttribute, shadowAttribute) {
    const { context, elm } = vm;
    // Remove the style attribute currently applied to the host element.
    element_1.setAttribute.call(elm, hostAttribute, '');
    context.hostAttribute = hostAttribute;
    context.shadowAttribute = shadowAttribute;
}
exports.applyStyleAttributes = applyStyleAttributes;
function collectStylesheets(stylesheets, hostSelector, shadowSelector, isNative, aggregatorFn) {
    language_1.forEach.call(stylesheets, sheet => {
        if (language_1.isArray(sheet)) {
            collectStylesheets(sheet, hostSelector, shadowSelector, isNative, aggregatorFn);
        }
        else {
            aggregatorFn(sheet(hostSelector, shadowSelector, isNative));
        }
    });
}
function evaluateCSS(vm, stylesheets, hostAttribute, shadowAttribute) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.isTrue(language_1.isArray(stylesheets), `Invalid stylesheets.`);
    }
    if (utils_1.useSyntheticShadow) {
        const hostSelector = `[${hostAttribute}]`;
        const shadowSelector = `[${shadowAttribute}]`;
        collectStylesheets(stylesheets, hostSelector, shadowSelector, false, textContent => {
            insertGlobalStyle(textContent);
        });
        return null;
    }
    else {
        // Native shadow in place, we need to act accordingly by using the `:host` selector, and an
        // empty shadow selector since it is not really needed.
        let buffer = '';
        collectStylesheets(stylesheets, language_1.emptyString, language_1.emptyString, true, textContent => {
            buffer += textContent;
        });
        return createStyleVNode(getCachedStyleElement(buffer));
    }
}
exports.evaluateCSS = evaluateCSS;
//# sourceMappingURL=stylesheet.js.map