"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const TargetToReactiveRecordMap = new WeakMap();
function notifyMutation(target, key) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(!invoker_1.isRendering, `Mutating property ${language_1.toString(key)} of ${language_1.toString(target)} is not allowed during the rendering life-cycle of ${invoker_1.vmBeingRendered}.`);
    }
    const reactiveRecord = TargetToReactiveRecordMap.get(target);
    if (!language_1.isUndefined(reactiveRecord)) {
        const value = reactiveRecord[key];
        if (value) {
            const len = value.length;
            for (let i = 0; i < len; i += 1) {
                const vm = value[i];
                if (process.env.NODE_ENV !== 'production') {
                    assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
                }
                if (language_1.isFalse(vm.isDirty)) {
                    component_1.markComponentAsDirty(vm);
                    vm_1.scheduleRehydration(vm);
                }
            }
        }
    }
}
exports.notifyMutation = notifyMutation;
function observeMutation(target, key) {
    if (language_1.isNull(invoker_1.vmBeingRendered)) {
        return; // nothing to subscribe to
    }
    const vm = invoker_1.vmBeingRendered;
    let reactiveRecord = TargetToReactiveRecordMap.get(target);
    if (language_1.isUndefined(reactiveRecord)) {
        const newRecord = language_1.create(null);
        reactiveRecord = newRecord;
        TargetToReactiveRecordMap.set(target, newRecord);
    }
    let value = reactiveRecord[key];
    if (language_1.isUndefined(value)) {
        value = [];
        reactiveRecord[key] = value;
    }
    else if (value[0] === vm) {
        return; // perf optimization considering that most subscriptions will come from the same vm
    }
    if (language_1.ArrayIndexOf.call(value, vm) === -1) {
        language_1.ArrayPush.call(value, vm);
        // we keep track of the sets that vm is listening from to be able to do some clean up later on
        language_1.ArrayPush.call(vm.deps, value);
    }
}
exports.observeMutation = observeMutation;
const vm_1 = require("./vm");
const component_1 = require("./component");
const invoker_1 = require("./invoker");
//# sourceMappingURL=watcher.js.map