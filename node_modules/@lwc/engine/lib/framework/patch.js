"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const element_1 = require("../env/element");
const language_1 = require("../shared/language");
const utils_1 = require("./utils");
// TODO: #1164 - eventually the engine should not do any of this work,
// it should just interact with the DOM, and the polyfill should
// take care of all these operation
const { PatchedElement, PatchedSlotElement, PatchedNode } = utils_1.useSyntheticShadow
    ? Element.prototype.$lwcPolyfill$
    : {};
// Using a WeakMap instead of a WeakSet because this one works in IE11 :(
const FromIteration = new WeakMap();
// dynamic children means it was generated by an iteration
// in a template, and will require a more complex diffing algo.
function markAsDynamicChildren(children) {
    FromIteration.set(children, 1);
}
exports.markAsDynamicChildren = markAsDynamicChildren;
function hasDynamicChildren(children) {
    return FromIteration.has(children);
}
exports.hasDynamicChildren = hasDynamicChildren;
let TextNodeProto;
// this method is supposed to be invoked when in fallback mode only
// to patch text nodes generated by a template.
function patchTextNodeProto(text) {
    if (language_1.isUndefined(TextNodeProto)) {
        TextNodeProto = PatchedNode(text).prototype;
    }
    language_1.setPrototypeOf(text, TextNodeProto);
}
exports.patchTextNodeProto = patchTextNodeProto;
let CommentNodeProto;
// this method is supposed to be invoked when in fallback mode only
// to patch comment nodes generated by a template.
function patchCommentNodeProto(comment) {
    if (language_1.isUndefined(CommentNodeProto)) {
        CommentNodeProto = PatchedNode(comment).prototype;
    }
    language_1.setPrototypeOf(comment, CommentNodeProto);
}
exports.patchCommentNodeProto = patchCommentNodeProto;
const TagToProtoCache = language_1.create(null);
function getPatchedElementClass(elm) {
    switch (element_1.tagNameGetter.call(elm)) {
        case 'SLOT':
            return PatchedSlotElement(elm);
    }
    return PatchedElement(elm);
}
// this method is supposed to be invoked when in fallback mode only
// to patch elements generated by a template.
function patchElementProto(elm, options) {
    const { sel } = options;
    let proto = TagToProtoCache[sel];
    if (language_1.isUndefined(proto)) {
        proto = TagToProtoCache[sel] = getPatchedElementClass(elm).prototype;
    }
    language_1.setPrototypeOf(elm, proto);
}
exports.patchElementProto = patchElementProto;
function patchCustomElementProto(elm, options) {
    const { def } = options;
    let patchedBridge = def.patchedBridge;
    if (language_1.isUndefined(patchedBridge)) {
        patchedBridge = def.patchedBridge = PatchedElement(elm);
    }
    // temporary patching the proto, eventually this should be just more nodes in the proto chain
    language_1.setPrototypeOf(elm, patchedBridge.prototype);
}
exports.patchCustomElementProto = patchCustomElementProto;
//# sourceMappingURL=patch.js.map