"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * This module is responsible for creating the base bridge class BaseBridgeElement
 * that represents the HTMLElement extension used for any LWC inserted in the DOM.
 */
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const vm_1 = require("./vm");
const html_properties_1 = require("./html-properties");
const membrane_1 = require("./membrane");
function prepareForPropUpdate(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
}
exports.prepareForPropUpdate = prepareForPropUpdate;
// A bridge descriptor is a descriptor whose job is just to get the component instance
// from the element instance, and get the value or set a new value on the component.
// This means that across different elements, similar names can get the exact same
// descriptor, so we can cache them:
const cachedGetterByKey = language_1.create(null);
const cachedSetterByKey = language_1.create(null);
function createGetter(key) {
    let fn = cachedGetterByKey[key];
    if (language_1.isUndefined(fn)) {
        fn = cachedGetterByKey[key] = function () {
            const vm = vm_1.getCustomElementVM(this);
            const { getHook } = vm;
            return getHook(vm.component, key);
        };
    }
    return fn;
}
function createSetter(key) {
    let fn = cachedSetterByKey[key];
    if (language_1.isUndefined(fn)) {
        fn = cachedSetterByKey[key] = function (newValue) {
            const vm = vm_1.getCustomElementVM(this);
            const { setHook } = vm;
            newValue = membrane_1.reactiveMembrane.getReadOnlyProxy(newValue);
            setHook(vm.component, key, newValue);
        };
    }
    return fn;
}
function createMethodCaller(methodName) {
    return function () {
        const vm = vm_1.getCustomElementVM(this);
        const { callHook, component } = vm;
        const fn = component[methodName];
        return callHook(vm.component, fn, language_1.ArraySlice.call(arguments));
    };
}
function HTMLBridgeElementFactory(SuperClass, props, methods) {
    let HTMLBridgeElement;
    /**
     * Modern browsers will have all Native Constructors as regular Classes
     * and must be instantiated with the new keyword. In older browsers,
     * specifically IE11, those are objects with a prototype property defined,
     * since they are not supposed to be extended or instantiated with the
     * new keyword. This forking logic supports both cases, specifically because
     * wc.ts relies on the construction path of the bridges to create new
     * fully qualifying web components.
     */
    if (language_1.isFunction(SuperClass)) {
        HTMLBridgeElement = class extends SuperClass {
        };
    }
    else {
        HTMLBridgeElement = function () {
            // Bridge classes are not supposed to be instantiated directly in
            // browsers that do not support web components.
            throw new TypeError('Illegal constructor');
        };
        // prototype inheritance dance
        language_1.setPrototypeOf(HTMLBridgeElement, SuperClass);
        language_1.setPrototypeOf(HTMLBridgeElement.prototype, SuperClass.prototype);
        language_1.defineProperty(HTMLBridgeElement.prototype, 'constructor', {
            writable: true,
            configurable: true,
            value: HTMLBridgeElement,
        });
    }
    const descriptors = language_1.create(null);
    // expose getters and setters for each public props on the new Element Bridge
    for (let i = 0, len = props.length; i < len; i += 1) {
        const propName = props[i];
        descriptors[propName] = {
            get: createGetter(propName),
            set: createSetter(propName),
            enumerable: true,
            configurable: true,
        };
    }
    // expose public methods as props on the new Element Bridge
    for (let i = 0, len = methods.length; i < len; i += 1) {
        const methodName = methods[i];
        descriptors[methodName] = {
            value: createMethodCaller(methodName),
            writable: true,
            configurable: true,
        };
    }
    language_1.defineProperties(HTMLBridgeElement.prototype, descriptors);
    return HTMLBridgeElement;
}
exports.HTMLBridgeElementFactory = HTMLBridgeElementFactory;
exports.BaseBridgeElement = HTMLBridgeElementFactory(HTMLElement, language_1.getOwnPropertyNames(html_properties_1.HTMLElementOriginalDescriptors), []);
language_1.freeze(exports.BaseBridgeElement);
language_1.seal(exports.BaseBridgeElement.prototype);
//# sourceMappingURL=base-bridge-element.js.map