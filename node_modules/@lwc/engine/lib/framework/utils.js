"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const language_1 = require("../shared/language");
const fields_1 = require("../shared/fields");
let nextTickCallbackQueue = [];
exports.SPACE_CHAR = 32;
exports.EmptyObject = language_1.seal(language_1.create(null));
exports.EmptyArray = language_1.seal([]);
exports.ViewModelReflection = fields_1.createFieldName('ViewModel');
function flushCallbackQueue() {
    if (process.env.NODE_ENV !== 'production') {
        if (nextTickCallbackQueue.length === 0) {
            throw new Error(`Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.`);
        }
    }
    const callbacks = nextTickCallbackQueue;
    nextTickCallbackQueue = []; // reset to a new queue
    for (let i = 0, len = callbacks.length; i < len; i += 1) {
        callbacks[i]();
    }
}
function addCallbackToNextTick(callback) {
    if (process.env.NODE_ENV !== 'production') {
        if (!language_1.isFunction(callback)) {
            throw new Error(`Internal Error: addCallbackToNextTick() can only accept a function callback`);
        }
    }
    if (nextTickCallbackQueue.length === 0) {
        Promise.resolve().then(flushCallbackQueue);
    }
    language_1.ArrayPush.call(nextTickCallbackQueue, callback);
}
exports.addCallbackToNextTick = addCallbackToNextTick;
function isCircularModuleDependency(value) {
    return language_1.hasOwnProperty.call(value, '__circular__');
}
exports.isCircularModuleDependency = isCircularModuleDependency;
/**
 * When LWC is used in the context of an Aura application, the compiler produces AMD
 * modules, that doesn't resolve properly circular dependencies between modules. In order
 * to circumvent this issue, the module loader returns a factory with a symbol attached
 * to it.
 *
 * This method returns the resolved value if it received a factory as argument. Otherwise
 * it returns the original value.
 */
function resolveCircularModuleDependency(fn) {
    if (process.env.NODE_ENV !== 'production') {
        if (!language_1.isFunction(fn)) {
            throw new TypeError(`Circular module dependency must be a function.`);
        }
    }
    return fn();
}
exports.resolveCircularModuleDependency = resolveCircularModuleDependency;
exports.useSyntheticShadow = language_1.hasOwnProperty.call(Element.prototype, '$shadowToken$');
//# sourceMappingURL=utils.js.map