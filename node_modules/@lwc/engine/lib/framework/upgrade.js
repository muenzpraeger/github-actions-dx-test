"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const vm_1 = require("./vm");
const utils_1 = require("./utils");
const fields_1 = require("../shared/fields");
const patch_1 = require("./patch");
const def_1 = require("./def");
const restrictions_1 = require("./restrictions");
const performance_timing_1 = require("./performance-timing");
const node_1 = require("../env/node");
const ConnectingSlot = fields_1.createFieldName('connecting');
const DisconnectingSlot = fields_1.createFieldName('disconnecting');
function callNodeSlot(node, slot) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(node, `callNodeSlot() should not be called for a non-object`);
    }
    const fn = fields_1.getInternalField(node, slot);
    if (!language_1.isUndefined(fn)) {
        fn();
    }
    return node; // for convenience
}
// monkey patching Node methods to be able to detect the insertions and removal of
// root elements created via createElement.
language_1.assign(Node.prototype, {
    appendChild(newChild) {
        const appendedNode = node_1.appendChild.call(this, newChild);
        return callNodeSlot(appendedNode, ConnectingSlot);
    },
    insertBefore(newChild, referenceNode) {
        const insertedNode = node_1.insertBefore.call(this, newChild, referenceNode);
        return callNodeSlot(insertedNode, ConnectingSlot);
    },
    removeChild(oldChild) {
        const removedNode = node_1.removeChild.call(this, oldChild);
        return callNodeSlot(removedNode, DisconnectingSlot);
    },
    replaceChild(newChild, oldChild) {
        const replacedNode = node_1.replaceChild.call(this, newChild, oldChild);
        callNodeSlot(replacedNode, DisconnectingSlot);
        callNodeSlot(newChild, ConnectingSlot);
        return replacedNode;
    },
});
/**
 * EXPERIMENTAL: This function is almost identical to document.createElement
 * (https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)
 * with the slightly difference that in the options, you can pass the `is`
 * property set to a Constructor instead of just a string value. The intent
 * is to allow the creation of an element controlled by LWC without having
 * to register the element as a custom element. E.g.:
 *
 * const el = createElement('x-foo', { is: FooCtor });
 *
 * If the value of `is` attribute is not a constructor,
 * then it throws a TypeError.
 */
function createElement(sel, options) {
    if (!language_1.isObject(options) || language_1.isNull(options)) {
        throw new TypeError(`"createElement" function expects an object as second parameter but received "${language_1.toString(options)}".`);
    }
    let Ctor = options.is;
    if (!language_1.isFunction(Ctor)) {
        throw new TypeError(`"createElement" function expects a "is" option with a valid component constructor.`);
    }
    const mode = options.mode !== 'closed' ? 'open' : 'closed';
    // Create element with correct tagName
    const element = document.createElement(sel);
    if (!language_1.isUndefined(fields_1.getInternalField(element, utils_1.ViewModelReflection))) {
        // There is a possibility that a custom element is registered under tagName,
        // in which case, the initialization is already carry on, and there is nothing else
        // to do here.
        return element;
    }
    if (utils_1.isCircularModuleDependency(Ctor)) {
        Ctor = utils_1.resolveCircularModuleDependency(Ctor);
    }
    const def = def_1.getComponentDef(Ctor);
    def_1.setElementProto(element, def);
    if (language_1.isTrue(utils_1.useSyntheticShadow)) {
        patch_1.patchCustomElementProto(element, {
            def,
        });
    }
    if (process.env.NODE_ENV !== 'production') {
        restrictions_1.patchCustomElementWithRestrictions(element, utils_1.EmptyObject);
    }
    // In case the element is not initialized already, we need to carry on the manual creation
    vm_1.createVM(element, Ctor, { mode, isRoot: true, owner: null });
    // Handle insertion and removal from the DOM manually
    fields_1.setInternalField(element, ConnectingSlot, () => {
        const vm = vm_1.getCustomElementVM(element);
        performance_timing_1.startGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.HYDRATE, vm);
        if (vm.state === vm_1.VMState.connected) {
            // usually means moving the element from one place to another, which is observable via life-cycle hooks
            vm_1.removeRootVM(vm);
        }
        vm_1.appendRootVM(vm);
        performance_timing_1.endGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.HYDRATE, vm);
    });
    fields_1.setInternalField(element, DisconnectingSlot, () => {
        const vm = vm_1.getCustomElementVM(element);
        vm_1.removeRootVM(vm);
    });
    return element;
}
exports.createElement = createElement;
//# sourceMappingURL=upgrade.js.map