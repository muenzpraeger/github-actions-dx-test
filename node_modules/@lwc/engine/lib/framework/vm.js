"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const def_1 = require("./def");
const component_1 = require("./component");
const patch_1 = require("./patch");
const language_1 = require("../shared/language");
const fields_1 = require("../shared/fields");
const utils_1 = require("./utils");
const services_1 = require("./services");
const invoker_1 = require("./invoker");
const dom_1 = require("../env/dom");
const performance_timing_1 = require("./performance-timing");
const element_1 = require("../env/element");
const node_1 = require("../env/node");
const snabbdom_1 = require("../3rdparty/snabbdom/snabbdom");
// Object of type ShadowRoot for instance checks
const GlobalShadowRoot = window.ShadowRoot;
var VMState;
(function (VMState) {
    VMState[VMState["created"] = 0] = "created";
    VMState[VMState["connected"] = 1] = "connected";
    VMState[VMState["disconnected"] = 2] = "disconnected";
})(VMState = exports.VMState || (exports.VMState = {}));
let idx = 0;
function callHook(cmp, fn, args = []) {
    return fn.apply(cmp, args);
}
function setHook(cmp, prop, newValue) {
    cmp[prop] = newValue;
}
function getHook(cmp, prop) {
    return cmp[prop];
}
function rerenderVM(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    rehydrate(vm);
}
exports.rerenderVM = rerenderVM;
function appendRootVM(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    runConnectedCallback(vm);
    rehydrate(vm);
}
exports.appendRootVM = appendRootVM;
function appendVM(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.isTrue(vm.state === VMState.created, `${vm} cannot be recycled.`);
    }
    runConnectedCallback(vm);
    rehydrate(vm);
}
exports.appendVM = appendVM;
// just in case the component comes back, with this we guarantee re-rendering it
// while preventing any attempt to rehydration until after reinsertion.
function resetComponentStateWhenRemoved(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    const { state } = vm;
    if (state !== VMState.disconnected) {
        runDisconnectedCallback(vm);
        // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)
        runShadowChildNodesDisconnectedCallback(vm);
        runLightChildNodesDisconnectedCallback(vm);
    }
}
// this method is triggered by the diffing algo only when a vnode from the
// old vnode.children is removed from the DOM.
function removeVM(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.isTrue(vm.state === VMState.connected || vm.state === VMState.disconnected, `${vm} must have been connected.`);
    }
    resetComponentStateWhenRemoved(vm);
}
exports.removeVM = removeVM;
// this method is triggered by the removal of a root element from the DOM.
function removeRootVM(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    resetComponentStateWhenRemoved(vm);
}
exports.removeRootVM = removeRootVM;
function createVM(elm, Ctor, options) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(elm instanceof HTMLElement, `VM creation requires a DOM element instead of ${elm}.`);
    }
    const def = def_1.getComponentDef(Ctor);
    const { isRoot, mode, owner } = options;
    idx += 1;
    const uninitializedVm = {
        // component creation index is defined once, and never reset, it can
        // be preserved from one insertion to another without any issue
        idx,
        state: VMState.created,
        isScheduled: false,
        isDirty: true,
        isRoot: language_1.isTrue(isRoot),
        mode,
        def,
        owner,
        elm,
        data: utils_1.EmptyObject,
        context: language_1.create(null),
        cmpTemplate: undefined,
        cmpProps: language_1.create(null),
        cmpTrack: language_1.create(null),
        cmpSlots: utils_1.useSyntheticShadow ? language_1.create(null) : undefined,
        callHook,
        setHook,
        getHook,
        component: undefined,
        children: utils_1.EmptyArray,
        aChildren: utils_1.EmptyArray,
        velements: utils_1.EmptyArray,
        // used to track down all object-key pairs that makes this vm reactive
        deps: [],
    };
    if (process.env.NODE_ENV !== 'production') {
        uninitializedVm.toString = () => {
            return `[object:vm ${def.name} (${uninitializedVm.idx})]`;
        };
    }
    // create component instance associated to the vm and the element
    component_1.createComponent(uninitializedVm, Ctor);
    // link component to the wire service
    const initializedVm = uninitializedVm;
    component_1.linkComponent(initializedVm);
}
exports.createVM = createVM;
function rehydrate(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.isTrue(vm.elm instanceof HTMLElement, `rehydration can only happen after ${vm} was patched the first time.`);
    }
    if (language_1.isTrue(vm.isDirty)) {
        const children = component_1.renderComponent(vm);
        patchShadowRoot(vm, children);
    }
}
function patchShadowRoot(vm, newCh) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    const { cmpRoot, children: oldCh } = vm;
    vm.children = newCh; // caching the new children collection
    if (newCh.length > 0 || oldCh.length > 0) {
        // patch function mutates vnodes by adding the element reference,
        // however, if patching fails it contains partial changes.
        if (oldCh !== newCh) {
            const fn = patch_1.hasDynamicChildren(newCh) ? snabbdom_1.updateDynamicChildren : snabbdom_1.updateStaticChildren;
            runWithBoundaryProtection(vm, vm, () => {
                // pre
                if (process.env.NODE_ENV !== 'production') {
                    performance_timing_1.startMeasure('patch', vm);
                }
            }, () => {
                // job
                fn(cmpRoot, oldCh, newCh);
            }, () => {
                // post
                if (process.env.NODE_ENV !== 'production') {
                    performance_timing_1.endMeasure('patch', vm);
                }
            });
        }
    }
    if (vm.state === VMState.connected) {
        // If the element is connected, that means connectedCallback was already issued, and
        // any successive rendering should finish with the call to renderedCallback, otherwise
        // the connectedCallback will take care of calling it in the right order at the end of
        // the current rehydration process.
        runRenderedCallback(vm);
    }
}
function runRenderedCallback(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    const { rendered } = services_1.Services;
    if (rendered) {
        services_1.invokeServiceHook(vm, rendered);
    }
    const { renderedCallback } = vm.def;
    if (!language_1.isUndefined(renderedCallback)) {
        if (process.env.NODE_ENV !== 'production') {
            performance_timing_1.startMeasure('renderedCallback', vm);
        }
        invoker_1.invokeComponentCallback(vm, renderedCallback);
        if (process.env.NODE_ENV !== 'production') {
            performance_timing_1.endMeasure('renderedCallback', vm);
        }
    }
}
let rehydrateQueue = [];
function flushRehydrationQueue() {
    performance_timing_1.startGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.REHYDRATE);
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(rehydrateQueue.length, `If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${rehydrateQueue}.`);
    }
    const vms = rehydrateQueue.sort((a, b) => a.idx - b.idx);
    rehydrateQueue = []; // reset to a new queue
    for (let i = 0, len = vms.length; i < len; i += 1) {
        const vm = vms[i];
        try {
            rehydrate(vm);
        }
        catch (error) {
            if (i + 1 < len) {
                // pieces of the queue are still pending to be rehydrated, those should have priority
                if (rehydrateQueue.length === 0) {
                    utils_1.addCallbackToNextTick(flushRehydrationQueue);
                }
                language_1.ArrayUnshift.apply(rehydrateQueue, language_1.ArraySlice.call(vms, i + 1));
            }
            // we need to end the measure before throwing.
            performance_timing_1.endGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.REHYDRATE);
            // re-throwing the original error will break the current tick, but since the next tick is
            // already scheduled, it should continue patching the rest.
            throw error; // eslint-disable-line no-unsafe-finally
        }
    }
    performance_timing_1.endGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.REHYDRATE);
}
function runConnectedCallback(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    const { state } = vm;
    if (state === VMState.connected) {
        return; // nothing to do since it was already connected
    }
    vm.state = VMState.connected;
    // reporting connection
    const { connected } = services_1.Services;
    if (connected) {
        services_1.invokeServiceHook(vm, connected);
    }
    const { connectedCallback } = vm.def;
    if (!language_1.isUndefined(connectedCallback)) {
        if (process.env.NODE_ENV !== 'production') {
            performance_timing_1.startMeasure('connectedCallback', vm);
        }
        invoker_1.invokeComponentCallback(vm, connectedCallback);
        if (process.env.NODE_ENV !== 'production') {
            performance_timing_1.endMeasure('connectedCallback', vm);
        }
    }
}
function runDisconnectedCallback(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.isTrue(vm.state !== VMState.disconnected, `${vm} must be inserted.`);
    }
    if (language_1.isFalse(vm.isDirty)) {
        // this guarantees that if the component is reused/reinserted,
        // it will be re-rendered because we are disconnecting the reactivity
        // linking, so mutations are not automatically reflected on the state
        // of disconnected components.
        vm.isDirty = true;
    }
    component_1.clearReactiveListeners(vm);
    vm.state = VMState.disconnected;
    // reporting disconnection
    const { disconnected } = services_1.Services;
    if (disconnected) {
        services_1.invokeServiceHook(vm, disconnected);
    }
    const { disconnectedCallback } = vm.def;
    if (!language_1.isUndefined(disconnectedCallback)) {
        if (process.env.NODE_ENV !== 'production') {
            performance_timing_1.startMeasure('disconnectedCallback', vm);
        }
        invoker_1.invokeComponentCallback(vm, disconnectedCallback);
        if (process.env.NODE_ENV !== 'production') {
            performance_timing_1.endMeasure('disconnectedCallback', vm);
        }
    }
}
function runShadowChildNodesDisconnectedCallback(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    const { velements: vCustomElementCollection } = vm;
    // reporting disconnection for every child in inverse order since they are inserted in reserved order
    for (let i = vCustomElementCollection.length - 1; i >= 0; i -= 1) {
        const elm = vCustomElementCollection[i].elm;
        // There are two cases where the element could be undefined:
        // * when there is an error during the construction phase, and an
        //   error boundary picks it, there is a possibility that the VCustomElement
        //   is not properly initialized, and therefore is should be ignored.
        // * when slotted custom element is not used by the element where it is slotted
        //   into it, as a result, the custom element was never initialized.
        if (!language_1.isUndefined(elm)) {
            const childVM = getCustomElementVM(elm);
            resetComponentStateWhenRemoved(childVM);
        }
    }
}
function runLightChildNodesDisconnectedCallback(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    const { aChildren: adoptedChildren } = vm;
    recursivelyDisconnectChildren(adoptedChildren);
}
/**
 * The recursion doesn't need to be a complete traversal of the vnode graph,
 * instead it can be partial, when a custom element vnode is found, we don't
 * need to continue into its children because by attempting to disconnect the
 * custom element itself will trigger the removal of anything slotted or anything
 * defined on its shadow.
 */
function recursivelyDisconnectChildren(vnodes) {
    for (let i = 0, len = vnodes.length; i < len; i += 1) {
        const vnode = vnodes[i];
        if (!language_1.isNull(vnode) && language_1.isArray(vnode.children) && !language_1.isUndefined(vnode.elm)) {
            // vnode is a VElement with children
            if (language_1.isUndefined(vnode.ctor)) {
                // it is a VElement, just keep looking (recursively)
                recursivelyDisconnectChildren(vnode.children);
            }
            else {
                // it is a VCustomElement, disconnect it and ignore its children
                resetComponentStateWhenRemoved(getCustomElementVM(vnode.elm));
            }
        }
    }
}
// This is a super optimized mechanism to remove the content of the shadowRoot
// without having to go into snabbdom. Especially useful when the reset is a consequence
// of an error, in which case the children VNodes might not be representing the current
// state of the DOM
function resetShadowRoot(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    vm.children = utils_1.EmptyArray;
    dom_1.ShadowRootInnerHTMLSetter.call(vm.cmpRoot, '');
    // disconnecting any known custom element inside the shadow of the this vm
    runShadowChildNodesDisconnectedCallback(vm);
}
exports.resetShadowRoot = resetShadowRoot;
function scheduleRehydration(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    if (!vm.isScheduled) {
        vm.isScheduled = true;
        if (rehydrateQueue.length === 0) {
            utils_1.addCallbackToNextTick(flushRehydrationQueue);
        }
        language_1.ArrayPush.call(rehydrateQueue, vm);
    }
}
exports.scheduleRehydration = scheduleRehydration;
function getErrorBoundaryVMFromOwnElement(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    const { elm } = vm;
    return getErrorBoundaryVM(elm);
}
function getErrorBoundaryVM(startingElement) {
    let elm = startingElement;
    let vm;
    while (!language_1.isNull(elm)) {
        vm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);
        if (!language_1.isUndefined(vm) && !language_1.isUndefined(vm.def.errorCallback)) {
            return vm;
        }
        elm = getParentOrHostElement(elm);
    }
}
/**
 * Returns the component stack. Used for errors messages only.
 *
 * @param {Element} startingElement
 *
 * @return {string} The component stack for errors.
 */
function getErrorComponentStack(startingElement) {
    const wcStack = [];
    let elm = startingElement;
    do {
        const currentVm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);
        if (!language_1.isUndefined(currentVm)) {
            const tagName = element_1.tagNameGetter.call(elm);
            const is = elm.getAttribute('is');
            language_1.ArrayPush.call(wcStack, `<${language_1.StringToLowerCase.call(tagName)}${is ? ' is="${is}' : ''}>`);
        }
        elm = getParentOrHostElement(elm);
    } while (!language_1.isNull(elm));
    return wcStack.reverse().join('\n\t');
}
exports.getErrorComponentStack = getErrorComponentStack;
/**
 * Finds the parent of the specified element. If shadow DOM is enabled, finds
 * the host of the shadow root to escape the shadow boundary.
 */
function getParentOrHostElement(elm) {
    const parentElement = node_1.parentElementGetter.call(elm);
    // If parentElement is a shadow root, find the host instead
    return language_1.isNull(parentElement) ? getHostElement(elm) : parentElement;
}
/**
 * Finds the host element, if it exists.
 */
function getHostElement(elm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(language_1.isNull(node_1.parentElementGetter.call(elm)), `getHostElement should only be called if the parent element of ${elm} is null`);
    }
    const parentNode = node_1.parentNodeGetter.call(elm);
    return parentNode instanceof GlobalShadowRoot
        ? dom_1.ShadowRootHostGetter.call(parentNode)
        : null;
}
/**
 * EXPERIMENTAL: This function detects whether or not a Node is
 * controlled by a LWC template. This API is subject to
 * change or being removed.
 */
function isNodeFromTemplate(node) {
    if (language_1.isFalse(node instanceof Node)) {
        return false;
    }
    // TODO: #1250 - skipping the shadowRoot instances itself makes no sense, we need to revisit this with locker
    if (node instanceof GlobalShadowRoot) {
        return false;
    }
    if (utils_1.useSyntheticShadow) {
        // TODO: #1252 - old behavior that is still used by some pieces of the platform, specifically, nodes inserted
        // manually on places where `lwc:dom="manual"` directive is not used, will be considered global elements.
        if (language_1.isUndefined(node.$shadowResolver$)) {
            return false;
        }
    }
    const root = node.getRootNode();
    return root instanceof GlobalShadowRoot;
}
exports.isNodeFromTemplate = isNodeFromTemplate;
function getCustomElementVM(elm) {
    if (process.env.NODE_ENV !== 'production') {
        const vm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    return fields_1.getInternalField(elm, utils_1.ViewModelReflection);
}
exports.getCustomElementVM = getCustomElementVM;
function getComponentVM(component) {
    if (process.env.NODE_ENV !== 'production') {
        const vm = fields_1.getHiddenField(component, utils_1.ViewModelReflection);
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    return fields_1.getHiddenField(component, utils_1.ViewModelReflection);
}
exports.getComponentVM = getComponentVM;
function getShadowRootVM(root) {
    // TODO: #1299 - use a weak map instead of an internal field
    if (process.env.NODE_ENV !== 'production') {
        const vm = fields_1.getInternalField(root, utils_1.ViewModelReflection);
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    return fields_1.getInternalField(root, utils_1.ViewModelReflection);
}
exports.getShadowRootVM = getShadowRootVM;
// slow path routine
// NOTE: we should probably more this routine to the synthetic shadow folder
// and get the allocation to be cached by in the elm instead of in the VM
function allocateInSlot(vm, children) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.invariant(language_1.isObject(vm.cmpSlots), `When doing manual allocation, there must be a cmpSlots object available.`);
    }
    const { cmpSlots: oldSlots } = vm;
    const cmpSlots = (vm.cmpSlots = language_1.create(null));
    for (let i = 0, len = children.length; i < len; i += 1) {
        const vnode = children[i];
        if (language_1.isNull(vnode)) {
            continue;
        }
        const { data } = vnode;
        const slotName = ((data.attrs && data.attrs.slot) || '');
        const vnodes = (cmpSlots[slotName] = cmpSlots[slotName] || []);
        // re-keying the vnodes is necessary to avoid conflicts with default content for the slot
        // which might have similar keys. Each vnode will always have a key that
        // starts with a numeric character from compiler. In this case, we add a unique
        // notation for slotted vnodes keys, e.g.: `@foo:1:1`
        vnode.key = `@${slotName}:${vnode.key}`;
        language_1.ArrayPush.call(vnodes, vnode);
    }
    if (language_1.isFalse(vm.isDirty)) {
        // We need to determine if the old allocation is really different from the new one
        // and mark the vm as dirty
        const oldKeys = language_1.keys(oldSlots);
        if (oldKeys.length !== language_1.keys(cmpSlots).length) {
            component_1.markComponentAsDirty(vm);
            return;
        }
        for (let i = 0, len = oldKeys.length; i < len; i += 1) {
            const key = oldKeys[i];
            if (language_1.isUndefined(cmpSlots[key]) || oldSlots[key].length !== cmpSlots[key].length) {
                component_1.markComponentAsDirty(vm);
                return;
            }
            const oldVNodes = oldSlots[key];
            const vnodes = cmpSlots[key];
            for (let j = 0, a = cmpSlots[key].length; j < a; j += 1) {
                if (oldVNodes[j] !== vnodes[j]) {
                    component_1.markComponentAsDirty(vm);
                    return;
                }
            }
        }
    }
}
exports.allocateInSlot = allocateInSlot;
function runWithBoundaryProtection(vm, owner, pre, job, post) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    let error;
    pre();
    try {
        job();
    }
    catch (e) {
        error = Object(e);
    }
    finally {
        post();
        if (!language_1.isUndefined(error)) {
            error.wcStack = error.wcStack || getErrorComponentStack(vm.elm);
            const errorBoundaryVm = language_1.isNull(owner)
                ? undefined
                : getErrorBoundaryVMFromOwnElement(owner);
            if (language_1.isUndefined(errorBoundaryVm)) {
                throw error; // eslint-disable-line no-unsafe-finally
            }
            resetShadowRoot(vm); // remove offenders
            if (process.env.NODE_ENV !== 'production') {
                performance_timing_1.startMeasure('errorCallback', errorBoundaryVm);
            }
            // error boundaries must have an ErrorCallback
            const errorCallback = errorBoundaryVm.def.errorCallback;
            invoker_1.invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);
            if (process.env.NODE_ENV !== 'production') {
                performance_timing_1.endMeasure('errorCallback', errorBoundaryVm);
            }
        }
    }
}
exports.runWithBoundaryProtection = runWithBoundaryProtection;
//# sourceMappingURL=vm.js.map