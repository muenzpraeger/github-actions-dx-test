"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const context_1 = require("./context");
const template_1 = require("./template");
const language_1 = require("../shared/language");
const vm_1 = require("./vm");
const performance_timing_1 = require("./performance-timing");
exports.isRendering = false;
exports.vmBeingRendered = null;
exports.vmBeingConstructed = null;
function isBeingConstructed(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpProps' in vm, `${vm} is not a vm.`);
    }
    return exports.vmBeingConstructed === vm;
}
exports.isBeingConstructed = isBeingConstructed;
function invokeComponentCallback(vm, fn, args) {
    const { component, callHook, context, owner } = vm;
    const ctx = context_1.currentContext;
    let result;
    vm_1.runWithBoundaryProtection(vm, owner, () => {
        // pre
        context_1.establishContext(context);
    }, () => {
        // job
        result = callHook(component, fn, args);
    }, () => {
        // post
        context_1.establishContext(ctx);
    });
    return result;
}
exports.invokeComponentCallback = invokeComponentCallback;
function invokeComponentConstructor(vm, Ctor) {
    const vmBeingConstructedInception = exports.vmBeingConstructed;
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpProps' in vm, `${vm} is not a vm.`);
    }
    const { context } = vm;
    const ctx = context_1.currentContext;
    context_1.establishContext(context);
    let error;
    if (process.env.NODE_ENV !== 'production') {
        performance_timing_1.startMeasure('constructor', vm);
    }
    exports.vmBeingConstructed = vm;
    /**
     * Constructors don't need to be wrapped with a boundary because for root elements
     * it should throw, while elements from template are already wrapped by a boundary
     * associated to the diffing algo.
     */
    try {
        // job
        const result = new Ctor();
        // Check indirectly if the constructor result is an instance of LightningElement. Using
        // the "instanceof" operator would not work here since Locker Service provides its own
        // implementation of LightningElement, so we indirectly check if the base constructor is
        // invoked by accessing the component on the vm.
        if (exports.vmBeingConstructed.component !== result) {
            throw new TypeError('Invalid component constructor, the class should extend LightningElement.');
        }
    }
    catch (e) {
        error = Object(e);
    }
    finally {
        context_1.establishContext(ctx);
        if (process.env.NODE_ENV !== 'production') {
            performance_timing_1.endMeasure('constructor', vm);
        }
        exports.vmBeingConstructed = vmBeingConstructedInception;
        if (!language_1.isUndefined(error)) {
            error.wcStack = vm_1.getErrorComponentStack(vm.elm);
            // re-throwing the original error annotated after restoring the context
            throw error; // eslint-disable-line no-unsafe-finally
        }
    }
}
exports.invokeComponentConstructor = invokeComponentConstructor;
function invokeComponentRenderMethod(vm) {
    const { def: { render }, callHook, component, context, owner, } = vm;
    const ctx = context_1.currentContext;
    const isRenderingInception = exports.isRendering;
    const vmBeingRenderedInception = exports.vmBeingRendered;
    exports.isRendering = true;
    exports.vmBeingRendered = vm;
    let result;
    vm_1.runWithBoundaryProtection(vm, owner, () => {
        // pre
        context_1.establishContext(context);
        if (process.env.NODE_ENV !== 'production') {
            performance_timing_1.startMeasure('render', vm);
        }
        exports.isRendering = true;
        exports.vmBeingRendered = vm;
    }, () => {
        // job
        const html = callHook(component, render);
        result = template_1.evaluateTemplate(vm, html);
    }, () => {
        context_1.establishContext(ctx);
        // post
        if (process.env.NODE_ENV !== 'production') {
            performance_timing_1.endMeasure('render', vm);
        }
        exports.isRendering = isRenderingInception;
        exports.vmBeingRendered = vmBeingRenderedInception;
    });
    return result || [];
}
exports.invokeComponentRenderMethod = invokeComponentRenderMethod;
function invokeEventListener(vm, fn, thisValue, event) {
    const { callHook, owner, context } = vm;
    const ctx = context_1.currentContext;
    vm_1.runWithBoundaryProtection(vm, owner, () => {
        // pre
        context_1.establishContext(context);
    }, () => {
        // job
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isTrue(language_1.isFunction(fn), `Invalid event handler for event '${event.type}' on ${vm}.`);
        }
        callHook(thisValue, fn, [event]);
    }, () => {
        // post
        context_1.establishContext(ctx);
    });
}
exports.invokeEventListener = invokeEventListener;
//# sourceMappingURL=invoker.js.map