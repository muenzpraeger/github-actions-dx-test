"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const api = __importStar(require("./api"));
const vm_1 = require("./vm");
const utils_1 = require("./utils");
const secure_template_1 = require("./secure-template");
exports.registerTemplate = secure_template_1.registerTemplate;
const stylesheet_1 = require("./stylesheet");
const EmptySlots = language_1.create(null);
function validateSlots(vm, html) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const { cmpSlots = EmptySlots } = vm;
    const { slots = utils_1.EmptyArray } = html;
    for (const slotName in cmpSlots) {
        // eslint-disable-next-line no-production-assert
        assert_1.default.isTrue(language_1.isArray(cmpSlots[slotName]), `Slots can only be set to an array, instead received ${language_1.toString(cmpSlots[slotName])} for slot "${slotName}" in ${vm}.`);
        if (slotName !== '' && language_1.ArrayIndexOf.call(slots, slotName) === -1) {
            // TODO: #1297 - this should never really happen because the compiler should always validate
            // eslint-disable-next-line no-production-assert
            assert_1.default.logError(`Ignoring unknown provided slot name "${slotName}" in ${vm}. Check for a typo on the slot attribute.`, vm.elm);
        }
    }
}
function validateFields(vm, html) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const { component } = vm;
    // validating identifiers used by template that should be provided by the component
    const { ids = [] } = html;
    language_1.forEach.call(ids, (propName) => {
        if (!(propName in component)) {
            // eslint-disable-next-line no-production-assert
            assert_1.default.logError(`The template rendered by ${vm} references \`this.${propName}\`, which is not declared. Check for a typo in the template.`, vm.elm);
        }
    });
}
function evaluateTemplate(vm, html) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.isTrue(language_1.isFunction(html), `evaluateTemplate() second argument must be an imported template instead of ${language_1.toString(html)}`);
    }
    const { component, context, cmpSlots, cmpTemplate } = vm;
    // reset the cache memoizer for template when needed
    if (html !== cmpTemplate) {
        // perf opt: do not reset the shadow root during the first rendering (there is nothing to reset)
        if (!language_1.isUndefined(cmpTemplate)) {
            // It is important to reset the content to avoid reusing similar elements generated from a different
            // template, because they could have similar IDs, and snabbdom just rely on the IDs.
            vm_1.resetShadowRoot(vm);
        }
        // Check that the template was built by the compiler
        if (!secure_template_1.isTemplateRegistered(html)) {
            throw new TypeError(`Invalid template returned by the render() method on ${vm}. It must return an imported template (e.g.: \`import html from "./${vm.def.name}.html"\`), instead, it has returned: ${language_1.toString(html)}.`);
        }
        vm.cmpTemplate = html;
        // Populate context with template information
        context.tplCache = language_1.create(null);
        stylesheet_1.resetStyleAttributes(vm);
        const { stylesheets, stylesheetTokens } = html;
        if (language_1.isUndefined(stylesheets) || stylesheets.length === 0) {
            context.styleVNode = null;
        }
        else if (!language_1.isUndefined(stylesheetTokens)) {
            const { hostAttribute, shadowAttribute } = stylesheetTokens;
            stylesheet_1.applyStyleAttributes(vm, hostAttribute, shadowAttribute);
            // Caching style vnode so it can be reused on every render
            context.styleVNode = stylesheet_1.evaluateCSS(vm, stylesheets, hostAttribute, shadowAttribute);
        }
        if (process.env.NODE_ENV !== 'production') {
            // one time operation for any new template returned by render()
            // so we can warn if the template is attempting to use a binding
            // that is not provided by the component instance.
            validateFields(vm, html);
        }
    }
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(language_1.isObject(context.tplCache), `vm.context.tplCache must be an object associated to ${cmpTemplate}.`);
        // validating slots in every rendering since the allocated content might change over time
        validateSlots(vm, html);
    }
    // right before producing the vnodes, we clear up all internal references
    // to custom elements from the template.
    vm.velements = [];
    // invoke the selected template.
    const vnodes = html.call(undefined, api, component, cmpSlots, context.tplCache);
    const { styleVNode } = context;
    if (!language_1.isNull(styleVNode)) {
        language_1.ArrayUnshift.call(vnodes, styleVNode);
    }
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(language_1.isArray(vnodes), `Compiler should produce html functions that always return an array.`);
    }
    return vnodes;
}
exports.evaluateTemplate = evaluateTemplate;
//# sourceMappingURL=template.js.map