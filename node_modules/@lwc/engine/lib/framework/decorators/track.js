"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../../shared/assert"));
const language_1 = require("../../shared/language");
const invoker_1 = require("../invoker");
const watcher_1 = require("../watcher");
const vm_1 = require("../vm");
const membrane_1 = require("../membrane");
function track(target, prop, descriptor) {
    if (arguments.length === 1) {
        return membrane_1.reactiveMembrane.getProxy(target);
    }
    if (process.env.NODE_ENV !== 'production') {
        if (arguments.length !== 3) {
            assert_1.default.fail(`@track decorator can only be used with one argument to return a trackable object, or as a decorator function.`);
        }
        if (!language_1.isUndefined(descriptor)) {
            const { get, set, configurable, writable } = descriptor;
            assert_1.default.isTrue(!get && !set, `Compiler Error: A @track decorator can only be applied to a public field.`);
            assert_1.default.isTrue(configurable !== false, `Compiler Error: A @track decorator can only be applied to a configurable property.`);
            assert_1.default.isTrue(writable !== false, `Compiler Error: A @track decorator can only be applied to a writable property.`);
        }
    }
    return createTrackedPropertyDescriptor(target, prop, language_1.isUndefined(descriptor) ? true : descriptor.enumerable === true);
}
exports.default = track;
function createTrackedPropertyDescriptor(Ctor, key, enumerable) {
    return {
        get() {
            const vm = vm_1.getComponentVM(this);
            if (process.env.NODE_ENV !== 'production') {
                assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
            }
            watcher_1.observeMutation(this, key);
            return vm.cmpTrack[key];
        },
        set(newValue) {
            const vm = vm_1.getComponentVM(this);
            if (process.env.NODE_ENV !== 'production') {
                assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${vm}.${String(key)}`);
            }
            const reactiveOrAnyValue = membrane_1.reactiveMembrane.getProxy(newValue);
            if (reactiveOrAnyValue !== vm.cmpTrack[key]) {
                vm.cmpTrack[key] = reactiveOrAnyValue;
                if (language_1.isFalse(vm.isDirty)) {
                    // perf optimization to skip this step if the track property is on a component that is already dirty
                    watcher_1.notifyMutation(this, key);
                }
            }
        },
        enumerable,
        configurable: true,
    };
}
exports.createTrackedPropertyDescriptor = createTrackedPropertyDescriptor;
//# sourceMappingURL=track.js.map