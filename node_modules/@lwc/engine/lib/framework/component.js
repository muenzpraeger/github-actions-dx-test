"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const invoker_1 = require("./invoker");
const language_1 = require("../shared/language");
const services_1 = require("./services");
const vm_1 = require("./vm");
const element_1 = require("../env/element");
const signedComponentToMetaMap = new Map();
/**
 * INTERNAL: This function can only be invoked by compiled code. The compiler
 * will prevent this function from being imported by userland code.
 */
function registerComponent(Ctor, { name, tmpl: template }) {
    signedComponentToMetaMap.set(Ctor, { name, template });
    // chaining this method as a way to wrap existing
    // assignment of component constructor easily, without too much transformation
    return Ctor;
}
exports.registerComponent = registerComponent;
function getComponentRegisteredMeta(Ctor) {
    return signedComponentToMetaMap.get(Ctor);
}
exports.getComponentRegisteredMeta = getComponentRegisteredMeta;
function createComponent(uninitializedVm, Ctor) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(uninitializedVm && 'cmpProps' in uninitializedVm, `${uninitializedVm} is not a vm.`);
    }
    // create the component instance
    invoker_1.invokeComponentConstructor(uninitializedVm, Ctor);
    const initializedVm = uninitializedVm;
    if (language_1.isUndefined(initializedVm.component)) {
        throw new ReferenceError(`Invalid construction for ${Ctor}, you must extend LightningElement.`);
    }
}
exports.createComponent = createComponent;
function linkComponent(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    // wiring service
    const { def: { wire }, } = vm;
    if (wire) {
        const { wiring } = services_1.Services;
        if (wiring) {
            services_1.invokeServiceHook(vm, wiring);
        }
    }
}
exports.linkComponent = linkComponent;
function clearReactiveListeners(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    const { deps } = vm;
    const len = deps.length;
    if (len > 0) {
        for (let i = 0; i < len; i += 1) {
            const set = deps[i];
            const pos = language_1.ArrayIndexOf.call(deps[i], vm);
            if (process.env.NODE_ENV !== 'production') {
                assert_1.default.invariant(pos > -1, `when clearing up deps, the vm must be part of the collection.`);
            }
            language_1.ArraySplice.call(set, pos, 1);
        }
        deps.length = 0;
    }
}
exports.clearReactiveListeners = clearReactiveListeners;
function renderComponent(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.invariant(vm.isDirty, `${vm} is not dirty.`);
    }
    clearReactiveListeners(vm);
    const vnodes = invoker_1.invokeComponentRenderMethod(vm);
    vm.isDirty = false;
    vm.isScheduled = false;
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(language_1.isArray(vnodes), `${vm}.render() should always return an array of vnodes instead of ${vnodes}`);
    }
    return vnodes;
}
exports.renderComponent = renderComponent;
function markComponentAsDirty(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.isFalse(vm.isDirty, `markComponentAsDirty() for ${vm} should not be called when the component is already dirty.`);
        assert_1.default.isFalse(invoker_1.isRendering, `markComponentAsDirty() for ${vm} cannot be called during rendering of ${invoker_1.vmBeingRendered}.`);
    }
    vm.isDirty = true;
}
exports.markComponentAsDirty = markComponentAsDirty;
const cmpEventListenerMap = new WeakMap();
function getWrappedComponentsListener(vm, listener) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
    }
    if (!language_1.isFunction(listener)) {
        throw new TypeError(); // avoiding problems with non-valid listeners
    }
    let wrappedListener = cmpEventListenerMap.get(listener);
    if (language_1.isUndefined(wrappedListener)) {
        wrappedListener = function (event) {
            invoker_1.invokeEventListener(vm, listener, undefined, event);
        };
        cmpEventListenerMap.set(listener, wrappedListener);
    }
    return wrappedListener;
}
exports.getWrappedComponentsListener = getWrappedComponentsListener;
function getComponentAsString(component) {
    if (process.env.NODE_ENV === 'production') {
        throw new ReferenceError();
    }
    const vm = vm_1.getComponentVM(component);
    return `<${language_1.StringToLowerCase.call(element_1.tagNameGetter.call(vm.elm))}>`;
}
exports.getComponentAsString = getComponentAsString;
//# sourceMappingURL=component.js.map