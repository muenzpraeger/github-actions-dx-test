declare const freeze: {
    <T>(a: T[]): readonly T[];
    <T extends Function>(f: T): T;
    <T>(o: T): Readonly<T>;
}, seal: <T>(o: T) => T, keys: {
    (o: object): string[];
    (o: {}): string[];
}, create: {
    (o: object | null): any;
    (o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;
}, assign: {
    <T, U>(target: T, source: U): T & U;
    <T, U, V>(target: T, source1: U, source2: V): T & U & V;
    <T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;
    (target: object, ...sources: any[]): any;
}, defineProperty: (o: any, p: string | number | symbol, attributes: PropertyDescriptor & ThisType<any>) => any, getPrototypeOf: (o: any) => any, setPrototypeOf: (o: any, proto: object | null) => any, getOwnPropertyDescriptor: (o: any, p: string | number | symbol) => PropertyDescriptor | undefined, getOwnPropertyNames: (o: any) => string[], defineProperties: (o: any, properties: PropertyDescriptorMap & ThisType<any>) => any, hasOwnProperty: (v: string | number | symbol) => boolean;
declare const isArray: (arg: any) => arg is any[];
declare const ArraySlice: (start?: number | undefined, end?: number | undefined) => any[], ArraySplice: {
    (start: number, deleteCount?: number | undefined): any[];
    (start: number, deleteCount: number, ...items: any[]): any[];
}, ArrayUnshift: (...items: any[]) => number, ArrayIndexOf: (searchElement: any, fromIndex?: number | undefined) => number, ArrayPush: (...items: any[]) => number, ArrayMap: <U>(callbackfn: (value: any, index: number, array: any[]) => U, thisArg?: any) => U[], ArrayJoin: (separator?: string | undefined) => string, forEach: (callbackfn: (value: any, index: number, array: any[]) => void, thisArg?: any) => void, ArrayReduce: {
    (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any;
    (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any;
    <U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U;
};
declare const StringReplace: {
    (searchValue: string | RegExp, replaceValue: string): string;
    (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
    (searchValue: {
        [Symbol.replace](string: string, replaceValue: string): string;
    }, replaceValue: string): string;
    (searchValue: {
        [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
    }, replacer: (substring: string, ...args: any[]) => string): string;
}, StringToLowerCase: () => string, StringCharCodeAt: (index: number) => number, StringSlice: (start?: number | undefined, end?: number | undefined) => string;
export { StringToLowerCase, StringReplace, StringCharCodeAt, StringSlice, freeze, seal, keys, create, assign, defineProperty, defineProperties, getPrototypeOf, setPrototypeOf, getOwnPropertyDescriptor, getOwnPropertyNames, hasOwnProperty, ArrayReduce, ArraySlice, ArraySplice, ArrayUnshift, ArrayMap, ArrayJoin, isArray, ArrayIndexOf, ArrayPush, forEach, };
export declare function isUndefined(obj: any): obj is undefined;
export declare function isNull(obj: any): obj is null;
export declare function isTrue(obj: any): obj is true;
export declare function isFalse(obj: any): obj is false;
export declare function isFunction(obj: any): obj is Function;
export declare function isObject(obj: any): obj is object;
export declare function isString(obj: any): obj is string;
export declare function isNumber(obj: any): obj is number;
export declare function toString(obj: any): string;
export declare function getPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined;
export declare const emptyString = "";
