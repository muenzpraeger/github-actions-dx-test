"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const language_1 = require("./language");
/**
 * In IE11, symbols are expensive.
 * Due to the nature of the symbol polyfill. This method abstract the
 * creation of symbols, so we can fallback to string when native symbols
 * are not supported. Note that we can't use typeof since it will fail when transpiling.
 */
const hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
function createFieldName(key) {
    // @ts-ignore: using a string as a symbol for perf reasons
    return hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${key}$$`;
}
exports.createFieldName = createFieldName;
function setInternalField(o, fieldName, value) {
    // TODO: #1299 - use a weak map instead
    language_1.defineProperty(o, fieldName, {
        value,
    });
}
exports.setInternalField = setInternalField;
function getInternalField(o, fieldName) {
    return o[fieldName];
}
exports.getInternalField = getInternalField;
/**
 * Store fields that should be hidden from outside world
 * hiddenFieldsMap is a WeakMap.
 * It stores a hash of any given objects associative relationships.
 * The hash uses the fieldName as the key, the value represents the other end of the association.
 *
 * For example, if the association is
 *              ViewModel
 * Component-A --------------> VM-1
 * then,
 * hiddenFieldsMap : (Component-A, { Symbol(ViewModel) : VM-1 })
 *
 */
const hiddenFieldsMap = new WeakMap();
exports.setHiddenField = hasNativeSymbolsSupport
    ? (o, fieldName, value) => {
        let valuesByField = hiddenFieldsMap.get(o);
        if (language_1.isUndefined(valuesByField)) {
            valuesByField = language_1.create(null);
            hiddenFieldsMap.set(o, valuesByField);
        }
        valuesByField[fieldName] = value;
    }
    : setInternalField; // Fall back to symbol based approach in compat mode
exports.getHiddenField = hasNativeSymbolsSupport
    ? (o, fieldName) => {
        const valuesByField = hiddenFieldsMap.get(o);
        return !language_1.isUndefined(valuesByField) && valuesByField[fieldName];
    }
    : getInternalField; // Fall back to symbol based approach in compat mode
//# sourceMappingURL=fields.js.map