"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const document_1 = require("../../env/document");
const language_1 = require("../../shared/language");
const node_1 = require("../../faux-shadow/node");
const node_2 = require("../../env/node");
const retarget_1 = require("../../3rdparty/polymer/retarget");
const path_composer_1 = require("../../3rdparty/polymer/path-composer");
const static_node_list_1 = require("../../shared/static-node-list");
const static_html_collection_1 = require("../../shared/static-html-collection");
const utils_1 = require("../../shared/utils");
const node_collection_util_1 = require("../../shared/node-collection-util");
let skipGlobalPatching;
function isGlobalPatchingSkipped(node) {
    if (language_1.isUndefined(skipGlobalPatching)) {
        const ownerDocument = utils_1.getOwnerDocument(node);
        skipGlobalPatching =
            ownerDocument.body.getAttribute('data-global-patching-bypass') === 'temporary-bypass';
    }
    return language_1.isTrue(skipGlobalPatching);
}
function apply() {
    function elemFromPoint(left, top) {
        const element = document_1.elementFromPoint.call(this, left, top);
        if (language_1.isNull(element)) {
            return element;
        }
        return retarget_1.retarget(this, path_composer_1.pathComposer(element, true));
    }
    // https://github.com/Microsoft/TypeScript/issues/14139
    Document.prototype.elementFromPoint = elemFromPoint;
    // Go until we reach to top of the LWC tree
    language_1.defineProperty(Document.prototype, 'activeElement', {
        get() {
            let node = document_1.DocumentPrototypeActiveElement.call(this);
            if (language_1.isNull(node)) {
                return node;
            }
            while (!language_1.isUndefined(node_1.getNodeOwnerKey(node))) {
                node = node_2.parentElementGetter.call(node);
                if (language_1.isNull(node)) {
                    return null;
                }
            }
            if (node.tagName === 'HTML') {
                // IE 11. Active element should never be html element
                node = this.body;
            }
            return node;
        },
        enumerable: true,
        configurable: true,
    });
    // The following patched methods hide shadowed elements from global
    // traversing mechanisms. They are simplified for performance reasons to
    // filter by ownership and do not account for slotted elements. This
    // compromise is fine for our synthetic shadow dom because root elements
    // cannot have slotted elements.
    // Another compromise here is that all these traversing methods will return
    // static HTMLCollection or static NodeList. We decided that this compromise
    // is not a big problem considering the amount of code that is relying on
    // the liveliness of these results are rare.
    language_1.defineProperty(Document.prototype, 'getElementById', {
        value() {
            const elm = document_1.getElementById.apply(this, language_1.ArraySlice.call(arguments));
            if (language_1.isNull(elm)) {
                return null;
            }
            return language_1.isUndefined(node_1.getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    language_1.defineProperty(Document.prototype, 'querySelector', {
        value() {
            const elements = document_1.querySelectorAll.apply(this, language_1.ArraySlice.call(arguments));
            const filtered = node_collection_util_1.collectionFind(elements, elm => language_1.isUndefined(node_1.getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
            return !language_1.isUndefined(filtered) ? filtered : null;
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    language_1.defineProperty(Document.prototype, 'querySelectorAll', {
        value() {
            const elements = document_1.querySelectorAll.apply(this, language_1.ArraySlice.call(arguments));
            const filtered = node_collection_util_1.collectionFilter(elements, elm => language_1.isUndefined(node_1.getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
            return static_node_list_1.createStaticNodeList(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    language_1.defineProperty(Document.prototype, 'getElementsByClassName', {
        value() {
            const elements = document_1.getElementsByClassName.apply(this, language_1.ArraySlice.call(arguments));
            const filtered = node_collection_util_1.collectionFilter(elements, elm => language_1.isUndefined(node_1.getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
            return static_html_collection_1.createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    language_1.defineProperty(Document.prototype, 'getElementsByTagName', {
        value() {
            const elements = document_1.getElementsByTagName.apply(this, language_1.ArraySlice.call(arguments));
            const filtered = node_collection_util_1.collectionFilter(elements, elm => language_1.isUndefined(node_1.getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
            return static_html_collection_1.createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    language_1.defineProperty(Document.prototype, 'getElementsByTagNameNS', {
        value() {
            const elements = document_1.getElementsByTagNameNS.apply(this, language_1.ArraySlice.call(arguments));
            const filtered = node_collection_util_1.collectionFilter(elements, elm => language_1.isUndefined(node_1.getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
            return static_html_collection_1.createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    language_1.defineProperty(
    // In Firefox v57 and lower, getElementsByName is defined on HTMLDocument.prototype
    language_1.getOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName')
        ? HTMLDocument.prototype
        : Document.prototype, 'getElementsByName', {
        value() {
            const elements = document_1.getElementsByName.apply(this, language_1.ArraySlice.call(arguments));
            const filtered = node_collection_util_1.collectionFilter(elements, elm => language_1.isUndefined(node_1.getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
            return static_node_list_1.createStaticNodeList(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
}
exports.default = apply;
//# sourceMappingURL=polyfill.js.map