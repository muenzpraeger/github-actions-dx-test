"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const language_1 = require("../../shared/language");
const node_1 = require("../../faux-shadow/node");
const shadow_root_1 = require("../../faux-shadow/shadow-root");
const OriginalMutationObserver = window.MutationObserver;
const { disconnect: originalDisconnect, observe: originalObserve, takeRecords: originalTakeRecords, } = OriginalMutationObserver.prototype;
// Internal fields to maintain relationships
const wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
const observerLookupField = '$$lwcNodeObservers$$';
const observerToNodesMap = new WeakMap();
/**
 * Retarget the mutation record's target value to its shadowRoot
 * @param {MutationRecord} originalRecord
 */
function retargetMutationRecord(originalRecord) {
    const { addedNodes, removedNodes, target, type } = originalRecord;
    const retargetedRecord = language_1.create(MutationRecord.prototype);
    language_1.defineProperties(retargetedRecord, {
        addedNodes: {
            get() {
                return addedNodes;
            },
            enumerable: true,
            configurable: true,
        },
        removedNodes: {
            get() {
                return removedNodes;
            },
            enumerable: true,
            configurable: true,
        },
        type: {
            get() {
                return type;
            },
            enumerable: true,
            configurable: true,
        },
        target: {
            get() {
                return target.shadowRoot;
            },
            enumerable: true,
            configurable: true,
        },
    });
    return retargetedRecord;
}
/**
 * Utility to identify if a target node is being observed by the given observer
 * Start at the current node, if the observer is registered to observe the current node, the mutation qualifies
 * @param {MutationObserver} observer
 * @param {Node} target
 */
function isQualifiedObserver(observer, target) {
    let parentNode = target;
    while (!language_1.isNull(parentNode)) {
        const parentNodeObservers = parentNode[observerLookupField];
        if (!language_1.isUndefined(parentNodeObservers) &&
            (parentNodeObservers[0] === observer || // perf optimization to check for the first item is a match
                language_1.ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {
            return true;
        }
        parentNode = parentNode.parentNode;
    }
    return false;
}
/**
 * This function provides a shadow dom compliant filtered view of mutation records for a given observer.
 *
 * The key logic here is to determine if a given observer has been registered to observe any nodes
 * between the target node of a mutation record to the target's root node.
 * This function also retargets records when mutations occur directly under the shadow root
 * @param {MutationRecords[]} mutations
 * @param {MutationObserver} observer
 */
function filterMutationRecords(mutations, observer) {
    return language_1.ArrayReduce.call(mutations, (filteredSet, record) => {
        const { target, addedNodes, removedNodes, type } = record;
        // If target is an lwc host,
        // Determine if the mutations affected the host or the shadowRoot
        // Mutations affecting host: changes to slot content
        // Mutations affecting shadowRoot: changes to template content
        if (type === 'childList' && !language_1.isUndefined(node_1.getNodeKey(target))) {
            // In case of added nodes, we can climb up the tree and determine eligibility
            if (addedNodes.length > 0) {
                // Optimization: Peek in and test one node to decide if the MutationRecord qualifies
                // The remaining nodes in this MutationRecord will have the same ownerKey
                const sampleNode = addedNodes[0];
                if (isQualifiedObserver(observer, sampleNode)) {
                    // If the target was being observed, then return record as-is
                    // this will be the case for slot content
                    if (target[observerLookupField] &&
                        (target[observerLookupField][0] === observer ||
                            language_1.ArrayIndexOf.call(target[observerLookupField], observer) !== -1)) {
                        language_1.ArrayPush.call(filteredSet, record);
                    }
                    else {
                        // else, must be observing the shadowRoot
                        language_1.ArrayPush.call(filteredSet, retargetMutationRecord(record));
                    }
                }
            }
            else {
                // In the case of removed nodes, climbing the tree is not an option as the nodes are disconnected
                // We can only check if either the host or shadow root was observed and qualify the record
                const shadowRoot = target.shadowRoot;
                const sampleNode = removedNodes[0];
                if (node_1.getNodeNearestOwnerKey(target) === node_1.getNodeNearestOwnerKey(sampleNode) && // trickery: sampleNode is slot content
                    isQualifiedObserver(observer, target) // use target as a close enough reference to climb up
                ) {
                    language_1.ArrayPush.call(filteredSet, record);
                }
                else if (shadowRoot &&
                    shadowRoot[observerLookupField] &&
                    (shadowRoot[observerLookupField][0] === observer ||
                        language_1.ArrayIndexOf.call(shadowRoot[observerLookupField], observer) !== -1)) {
                    language_1.ArrayPush.call(filteredSet, retargetMutationRecord(record));
                }
            }
        }
        else {
            // Mutation happened under a root node(shadow root or document) and the decision is straighforward
            // Ascend the tree starting from target and check if observer is qualified
            if (isQualifiedObserver(observer, target)) {
                language_1.ArrayPush.call(filteredSet, record);
            }
        }
        return filteredSet;
    }, []);
}
function getWrappedCallback(callback) {
    let wrappedCallback = callback[wrapperLookupField];
    if (language_1.isUndefined(wrappedCallback)) {
        wrappedCallback = callback[wrapperLookupField] = (mutations, observer) => {
            // Filter mutation records
            const filteredRecords = filterMutationRecords(mutations, observer);
            // If not records are eligible for the observer, do not invoke callback
            if (filteredRecords.length === 0) {
                return;
            }
            callback.call(observer, filteredRecords, observer);
        };
    }
    return wrappedCallback;
}
/**
 * Patched MutationObserver constructor.
 * 1. Wrap the callback to filter out MutationRecords based on dom ownership
 * 2. Add a property field to track all observed targets of the observer instance
 * @param {MutationCallback} callback
 */
function PatchedMutationObserver(callback) {
    const wrappedCallback = getWrappedCallback(callback);
    const observer = new OriginalMutationObserver(wrappedCallback);
    return observer;
}
function patchedDisconnect() {
    originalDisconnect.call(this);
    // Clear the node to observer reference which is a strong references
    const observedNodes = observerToNodesMap.get(this);
    if (!language_1.isUndefined(observedNodes)) {
        language_1.forEach.call(observedNodes, observedNode => {
            const observers = observedNode[observerLookupField];
            if (!language_1.isUndefined(observers)) {
                const index = language_1.ArrayIndexOf.call(observers, this);
                if (index !== -1) {
                    language_1.ArraySplice.call(observers, index, 1);
                }
            }
        });
        observedNodes.length = 0;
    }
}
/**
 * A single mutation observer can observe multiple nodes(target).
 * Maintain a list of all targets that the observer chooses to observe
 * @param {Node} target
 * @param {Object} options
 */
function patchedObserve(target, options) {
    // Maintain a list of all observers that want to observe a node
    if (language_1.isUndefined(target[observerLookupField])) {
        language_1.defineProperty(target, observerLookupField, { value: [] });
    }
    // Same observer trying to observe the same node
    if (language_1.ArrayIndexOf.call(target[observerLookupField], this) === -1) {
        language_1.ArrayPush.call(target[observerLookupField], this);
    } // else There is more bookkeeping to do here https://dom.spec.whatwg.org/#dom-mutationobserver-observe Step #7
    // If the target is a SyntheticShadowRoot, observe the host since the shadowRoot is an empty documentFragment
    if (target instanceof shadow_root_1.SyntheticShadowRoot) {
        target = target.host;
    }
    // maintain a list of all nodes observed by this observer
    if (observerToNodesMap.has(this)) {
        const observedNodes = observerToNodesMap.get(this);
        if (language_1.ArrayIndexOf.call(observedNodes, target) === -1) {
            language_1.ArrayPush.call(observedNodes, target);
        }
    }
    else {
        observerToNodesMap.set(this, [target]);
    }
    return originalObserve.call(this, target, options);
}
/**
 * Patch the takeRecords() api to filter MutationRecords based on the observed targets
 */
function patchedTakeRecords() {
    return filterMutationRecords(originalTakeRecords.call(this), this);
}
PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
PatchedMutationObserver.prototype.observe = patchedObserve;
PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
function apply() {
    language_1.defineProperty(window, 'MutationObserver', {
        value: PatchedMutationObserver,
        configurable: true,
        writable: true,
    });
}
exports.default = apply;
//# sourceMappingURL=polyfill.js.map