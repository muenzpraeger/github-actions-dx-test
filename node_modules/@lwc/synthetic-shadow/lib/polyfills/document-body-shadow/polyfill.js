"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const element_1 = require("../../env/element");
const language_1 = require("../../shared/language");
const node_collection_util_1 = require("../../shared/node-collection-util");
const node_1 = require("../../faux-shadow/node");
const static_node_list_1 = require("../../shared/static-node-list");
const static_html_collection_1 = require("../../shared/static-html-collection");
const utils_1 = require("../../shared/utils");
let skipGlobalPatching;
function isGlobalPatchingSkipped(node) {
    if (language_1.isUndefined(skipGlobalPatching)) {
        const ownerDocument = utils_1.getOwnerDocument(node);
        skipGlobalPatching =
            ownerDocument.body.getAttribute('data-global-patching-bypass') === 'temporary-bypass';
    }
    return language_1.isTrue(skipGlobalPatching);
}
function apply() {
    const HTMLBodyElementPrototype = HTMLBodyElement.prototype;
    // The following patched methods hide shadowed elements from global
    // traversing mechanisms. They are simplified for performance reasons to
    // filter by ownership and do not account for slotted elements. This
    // compromise is fine for our synthetic shadow dom because root elements
    // cannot have slotted elements.
    // Another compromise here is that all these traversing methods will return
    // static HTMLCollection or static NodeList. We decided that this compromise
    // is not a big problem considering the amount of code that is relying on
    // the liveliness of these results are rare.
    language_1.defineProperty(HTMLBodyElementPrototype, 'querySelector', {
        value() {
            const elements = element_1.querySelectorAll.apply(this, language_1.ArraySlice.call(arguments));
            const ownerKey = node_1.getNodeOwnerKey(this);
            // Return the first non shadow element
            const filtered = node_collection_util_1.collectionFind(elements, elm => node_1.getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped(elm));
            return !language_1.isUndefined(filtered) ? filtered : null;
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    language_1.defineProperty(HTMLBodyElementPrototype, 'querySelectorAll', {
        value() {
            const elements = element_1.querySelectorAll.apply(this, language_1.ArraySlice.call(arguments));
            const ownerKey = node_1.getNodeOwnerKey(this);
            const filtered = node_collection_util_1.collectionFilter(elements, elm => node_1.getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped(elm));
            return static_node_list_1.createStaticNodeList(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    language_1.defineProperty(HTMLBodyElementPrototype, 'getElementsByClassName', {
        value() {
            const elements = element_1.getElementsByClassName.apply(this, language_1.ArraySlice.call(arguments));
            const ownerKey = node_1.getNodeOwnerKey(this);
            const filtered = node_collection_util_1.collectionFilter(elements, elm => node_1.getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped(elm));
            return static_html_collection_1.createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    language_1.defineProperty(HTMLBodyElementPrototype, 'getElementsByTagName', {
        value() {
            const elements = element_1.getElementsByTagName.apply(this, language_1.ArraySlice.call(arguments));
            const ownerKey = node_1.getNodeOwnerKey(this);
            const filtered = node_collection_util_1.collectionFilter(elements, elm => node_1.getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped(elm));
            return static_html_collection_1.createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    language_1.defineProperty(HTMLBodyElementPrototype, 'getElementsByTagNameNS', {
        value() {
            const elements = element_1.getElementsByTagNameNS.apply(this, language_1.ArraySlice.call(arguments));
            const ownerKey = node_1.getNodeOwnerKey(this);
            const filtered = node_collection_util_1.collectionFilter(elements, elm => node_1.getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped(elm));
            return static_html_collection_1.createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
}
exports.default = apply;
//# sourceMappingURL=polyfill.js.map