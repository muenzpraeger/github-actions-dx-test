"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const language_1 = require("../../shared/language");
const node_1 = require("../../env/node");
const traverse_1 = require("../../faux-shadow/traverse");
const shadow_root_1 = require("../../faux-shadow/shadow-root");
const nativeGetRootNode = Node.prototype.getRootNode;
/**
 * Get the root by climbing up the dom tree, beyond the shadow root
 * If Node.prototype.getRootNode is supported, use it
 * else, assume we are working in non-native shadow mode and climb using parentNode
 */
const getDocumentOrRootNode = !language_1.isUndefined(nativeGetRootNode)
    ? nativeGetRootNode
    : function () {
        let node = this;
        let nodeParent;
        while (!language_1.isNull((nodeParent = node_1.parentNodeGetter.call(node)))) {
            node = nodeParent;
        }
        return node;
    };
/**
 * Get the shadow root
 * getNodeOwner() returns the host element that owns the given node
 * Note: getNodeOwner() returns null when running in native-shadow mode.
 *  Fallback to using the native getRootNode() to discover the root node.
 *  This is because, it is not possible to inspect the node and decide if it is part
 *  of a native shadow or the synthetic shadow.
 * @param {Node} node
 */
function getNearestRoot(node) {
    const ownerNode = traverse_1.getNodeOwner(node);
    if (language_1.isNull(ownerNode)) {
        // we hit a wall, either we are in native shadow mode or the node is not in lwc boundary.
        return getDocumentOrRootNode.call(node);
    }
    return shadow_root_1.getShadowRoot(ownerNode);
}
function patchedGetRootNode(options) {
    const composed = language_1.isUndefined(options) ? false : !!options.composed;
    return language_1.isTrue(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
}
function apply() {
    language_1.defineProperty(Node.prototype, 'getRootNode', {
        value: patchedGetRootNode,
        enumerable: true,
        configurable: true,
        writable: true,
    });
}
exports.default = apply;
//# sourceMappingURL=polyfill.js.map