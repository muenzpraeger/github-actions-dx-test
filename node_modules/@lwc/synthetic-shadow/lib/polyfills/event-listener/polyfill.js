"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const window_1 = require("../../env/window");
const element_1 = require("../../env/element");
const dom_1 = require("../../env/dom");
const events_1 = require("../../faux-shadow/events");
const node_1 = require("../../faux-shadow/node");
function doesEventNeedsPatch(e) {
    const originalTarget = dom_1.eventTargetGetter.call(e);
    return originalTarget instanceof Node && node_1.isNodeShadowed(originalTarget);
}
function getEventListenerWrapper(fnOrObj) {
    let wrapperFn = null;
    try {
        wrapperFn = fnOrObj.$$lwcEventWrapper$$;
        if (!wrapperFn) {
            const isHandlerFunction = typeof fnOrObj === 'function';
            wrapperFn = fnOrObj.$$lwcEventWrapper$$ = function (e) {
                // we don't want to patch every event, only when the original target is coming
                // from inside a synthetic shadow
                if (doesEventNeedsPatch(e)) {
                    events_1.patchEvent(e);
                }
                return isHandlerFunction
                    ? fnOrObj.call(this, e)
                    : fnOrObj.handleEvent && fnOrObj.handleEvent(e);
            };
        }
    }
    catch (e) {
        /** ignore */
    }
    return wrapperFn;
}
function windowAddEventListener(type, fnOrObj, optionsOrCapture) {
    const handlerType = typeof fnOrObj;
    // bail if `fnOrObj` is not a function, not an object
    if (handlerType !== 'function' && handlerType !== 'object') {
        return;
    }
    // bail if `fnOrObj` is an object without a `handleEvent` method
    if (handlerType === 'object' &&
        (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
        return;
    }
    const wrapperFn = getEventListenerWrapper(fnOrObj);
    window_1.windowAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
}
function windowRemoveEventListener(type, fnOrObj, optionsOrCapture) {
    const wrapperFn = getEventListenerWrapper(fnOrObj);
    window_1.windowRemoveEventListener.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);
}
function addEventListener(type, fnOrObj, optionsOrCapture) {
    const handlerType = typeof fnOrObj;
    // bail if `fnOrObj` is not a function, not an object
    if (handlerType !== 'function' && handlerType !== 'object') {
        return;
    }
    // bail if `fnOrObj` is an object without a `handleEvent` method
    if (handlerType === 'object' &&
        (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
        return;
    }
    const wrapperFn = getEventListenerWrapper(fnOrObj);
    element_1.addEventListener.call(this, type, wrapperFn, optionsOrCapture);
}
function removeEventListener(type, fnOrObj, optionsOrCapture) {
    const wrapperFn = getEventListenerWrapper(fnOrObj);
    element_1.removeEventListener.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);
}
// TODO: #1305 - these patches should be on EventTarget.prototype instead of win and node protos
function windowPatchListeners() {
    window.addEventListener = windowAddEventListener;
    window.removeEventListener = windowRemoveEventListener;
}
function nodePatchListeners() {
    Node.prototype.addEventListener = addEventListener;
    Node.prototype.removeEventListener = removeEventListener;
}
function apply() {
    windowPatchListeners();
    nodePatchListeners();
}
exports.default = apply;
//# sourceMappingURL=polyfill.js.map