"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const language_1 = require("../shared/language");
const node_1 = require("../env/node");
const traverse_1 = require("./traverse");
const text_content_1 = require("../3rdparty/polymer/text-content");
const shadow_root_1 = require("./shadow-root");
// DO NOT CHANGE this:
// these two values need to be in sync with engine
const OwnerKey = '$$OwnerKey$$';
const OwnKey = '$$OwnKey$$';
exports.hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
function getNodeOwnerKey(node) {
    return node[OwnerKey];
}
exports.getNodeOwnerKey = getNodeOwnerKey;
function setNodeOwnerKey(node, value) {
    if (process.env.NODE_ENV !== 'production') {
        // in dev-mode, we are more restrictive about what you can do with the owner key
        language_1.defineProperty(node, OwnerKey, {
            value,
            configurable: true,
        });
    }
    else {
        // in prod, for better perf, we just let it roll
        node[OwnerKey] = value;
    }
}
exports.setNodeOwnerKey = setNodeOwnerKey;
function setNodeKey(node, value) {
    if (process.env.NODE_ENV !== 'production') {
        // in dev-mode, we are more restrictive about what you can do with the own key
        language_1.defineProperty(node, OwnKey, {
            value,
        });
    }
    else {
        // in prod, for better perf, we just let it roll
        node[OwnKey] = value;
    }
}
exports.setNodeKey = setNodeKey;
function getNodeNearestOwnerKey(node) {
    let ownerNode = node;
    let ownerKey;
    // search for the first element with owner identity (just in case of manually inserted elements)
    while (!language_1.isNull(ownerNode)) {
        ownerKey = ownerNode[OwnerKey];
        if (!language_1.isUndefined(ownerKey)) {
            return ownerKey;
        }
        ownerNode = node_1.parentNodeGetter.call(ownerNode);
    }
}
exports.getNodeNearestOwnerKey = getNodeNearestOwnerKey;
function getNodeKey(node) {
    return node[OwnKey];
}
exports.getNodeKey = getNodeKey;
function isNodeShadowed(node) {
    return !language_1.isUndefined(getNodeNearestOwnerKey(node));
}
exports.isNodeShadowed = isNodeShadowed;
function getShadowParent(node, value) {
    const owner = traverse_1.getNodeOwner(node);
    if (value === owner) {
        // walking up via parent chain might end up in the shadow root element
        return shadow_root_1.getShadowRoot(owner);
    }
    else if (value instanceof Element) {
        if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
            // the element and its parent node belong to the same shadow root
            return value;
        }
        else if (!language_1.isNull(owner) && traverse_1.isSlotElement(value)) {
            // slotted elements must be top level childNodes of the slot element
            // where they slotted into, but its shadowed parent is always the
            // owner of the slot.
            const slotOwner = traverse_1.getNodeOwner(value);
            if (!language_1.isNull(slotOwner) && traverse_1.isNodeOwnedBy(owner, slotOwner)) {
                // it is a slotted element, and therefore its parent is always going to be the host of the slot
                return slotOwner;
            }
        }
    }
    return null;
}
function PatchedNode(node) {
    const Ctor = language_1.getPrototypeOf(node).constructor;
    class PatchedNodeClass {
        constructor() {
            // Patched classes are not supposed to be instantiated directly, ever!
            throw new TypeError('Illegal constructor');
        }
        hasChildNodes() {
            return exports.getInternalChildNodes(this).length > 0;
        }
        get firstChild() {
            const childNodes = exports.getInternalChildNodes(this);
            return childNodes[0] || null;
        }
        get lastChild() {
            const childNodes = exports.getInternalChildNodes(this);
            return childNodes[childNodes.length - 1] || null;
        }
        get textContent() {
            return text_content_1.getTextContent(this);
        }
        set textContent(value) {
            node_1.textContextSetter.call(this, value);
        }
        get childElementCount() {
            return this.children.length;
        }
        get firstElementChild() {
            return this.children[0] || null;
        }
        get lastElementChild() {
            const { children } = this;
            return children.item(children.length - 1) || null;
        }
        get assignedSlot() {
            const parentNode = node_1.parentNodeGetter.call(this);
            /**
             * if it doesn't have a parent node,
             * or the parent is not an slot element
             * or they both belong to the same template (default content)
             * we should assume that it is not slotted
             */
            if (language_1.isNull(parentNode) ||
                !traverse_1.isSlotElement(parentNode) ||
                getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
                return null;
            }
            return parentNode;
        }
        get parentNode() {
            const value = node_1.parentNodeGetter.call(this);
            if (language_1.isNull(value)) {
                return value;
            }
            return getShadowParent(this, value);
        }
        get parentElement() {
            const value = node_1.parentNodeGetter.call(this);
            if (language_1.isNull(value)) {
                return null;
            }
            const parentNode = getShadowParent(this, value);
            // it could be that the parentNode is the shadowRoot, in which case
            // we need to return null.
            return parentNode instanceof Element ? parentNode : null;
        }
        compareDocumentPosition(otherNode) {
            if (traverse_1.patchedGetRootNode.call(this) === otherNode) {
                // "this" is in a shadow tree where the shadow root is the "otherNode".
                return 10; // Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING
            }
            else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                // "this" and "otherNode" belongs to 2 different shadow tree.
                return 35; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node.DOCUMENT_POSITION_PRECEDING
            }
            // Since "this" and "otherNode" are part of the same shadow tree we can safely rely to the native
            // Node.compareDocumentPosition implementation.
            return node_1.compareDocumentPosition.call(this, otherNode);
        }
        contains(otherNode) {
            if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                // it is from another shadow
                return false;
            }
            return ((node_1.compareDocumentPosition.call(this, otherNode) & node_1.DOCUMENT_POSITION_CONTAINED_BY) !==
                0);
        }
        cloneNode(deep) {
            const clone = node_1.cloneNode.call(this, false);
            // Per spec, browsers only care about truthy values
            // Not strict true or false
            if (!deep) {
                return clone;
            }
            const childNodes = exports.getInternalChildNodes(this);
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                clone.appendChild(childNodes[i].cloneNode(true));
            }
            return clone;
        }
    }
    // prototype inheritance dance
    language_1.setPrototypeOf(PatchedNodeClass, Ctor);
    language_1.setPrototypeOf(PatchedNodeClass.prototype, Ctor.prototype);
    return PatchedNodeClass;
}
exports.PatchedNode = PatchedNode;
let internalChildNodeAccessorFlag = false;
/**
 * These 2 methods are providing a machinery to understand who is accessing the
 * .childNodes member property of a node. If it is used from inside the synthetic shadow
 * or from an external invoker. This helps to produce the right output in one very peculiar
 * case, the IE11 debugging comment for shadowRoot representation on the devtool.
 */
function isExternalChildNodeAccessorFlagOn() {
    return !internalChildNodeAccessorFlag;
}
exports.isExternalChildNodeAccessorFlagOn = isExternalChildNodeAccessorFlagOn;
exports.getInternalChildNodes = process.env.NODE_ENV !== 'production' && language_1.isFalse(exports.hasNativeSymbolsSupport)
    ? function (node) {
        internalChildNodeAccessorFlag = true;
        let childNodes;
        let error = null;
        try {
            childNodes = node.childNodes;
        }
        catch (e) {
            // childNodes accessor should never throw, but just in case!
            error = e;
        }
        finally {
            internalChildNodeAccessorFlag = false;
            if (!language_1.isNull(error)) {
                // re-throwing after restoring the state machinery for setInternalChildNodeAccessorFlag
                throw error; // eslint-disable-line no-unsafe-finally
            }
        }
        return childNodes;
    }
    : function (node) {
        return node.childNodes;
    };
//# sourceMappingURL=node.js.map