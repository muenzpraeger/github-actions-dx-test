"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const language_1 = require("../shared/language");
const events_1 = require("./events");
const traverse_1 = require("./traverse");
const fields_1 = require("../shared/fields");
const text_content_1 = require("../3rdparty/polymer/text-content");
const static_node_list_1 = require("../shared/static-node-list");
const document_1 = require("../env/document");
const node_1 = require("../env/node");
const dom_1 = require("../env/dom");
const static_html_collection_1 = require("../shared/static-html-collection");
const outer_html_1 = require("../3rdparty/polymer/outer-html");
const retarget_1 = require("../3rdparty/polymer/retarget");
const path_composer_1 = require("../3rdparty/polymer/path-composer");
const node_2 = require("./node");
const element_1 = require("../env/element");
const utils_1 = require("../shared/utils");
const ShadowRootResolverKey = '$shadowResolver$';
const InternalSlot = fields_1.createFieldName('shadowRecord');
const { createDocumentFragment } = document;
function getInternalSlot(root) {
    const record = fields_1.getInternalField(root, InternalSlot);
    if (language_1.isUndefined(record)) {
        throw new TypeError();
    }
    return record;
}
const ShadowResolverPrivateKey = '$$ShadowResolverKey$$';
language_1.defineProperty(Node.prototype, ShadowRootResolverKey, {
    set(fn) {
        this[ShadowResolverPrivateKey] = fn;
        // TODO: #1164 - temporary propagation of the key
        node_2.setNodeOwnerKey(this, fn.nodeKey);
    },
    get() {
        return this[ShadowResolverPrivateKey];
    },
    configurable: true,
    enumerable: true,
});
function getShadowRootResolver(node) {
    return node[ShadowRootResolverKey];
}
exports.getShadowRootResolver = getShadowRootResolver;
function setShadowRootResolver(node, fn) {
    node[ShadowRootResolverKey] = fn;
}
exports.setShadowRootResolver = setShadowRootResolver;
function isDelegatingFocus(host) {
    return getInternalSlot(host).delegatesFocus;
}
exports.isDelegatingFocus = isDelegatingFocus;
function getHost(root) {
    return getInternalSlot(root).host;
}
exports.getHost = getHost;
function getShadowRoot(elm) {
    return getInternalSlot(elm).shadowRoot;
}
exports.getShadowRoot = getShadowRoot;
function hasSyntheticShadow(elm) {
    return !language_1.isUndefined(fields_1.getInternalField(elm, InternalSlot));
}
exports.hasSyntheticShadow = hasSyntheticShadow;
let uid = 0;
function attachShadow(elm, options) {
    if (!language_1.isUndefined(fields_1.getInternalField(elm, InternalSlot))) {
        throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);
    }
    const { mode, delegatesFocus } = options;
    // creating a real fragment for shadowRoot instance
    const doc = utils_1.getOwnerDocument(elm);
    const sr = createDocumentFragment.call(doc);
    // creating shadow internal record
    const record = {
        mode,
        delegatesFocus: !!delegatesFocus,
        host: elm,
        shadowRoot: sr,
    };
    fields_1.setInternalField(sr, InternalSlot, record);
    fields_1.setInternalField(elm, InternalSlot, record);
    const shadowResolver = () => sr;
    const x = (shadowResolver.nodeKey = uid++);
    node_2.setNodeKey(elm, x);
    setShadowRootResolver(sr, shadowResolver);
    // correcting the proto chain
    language_1.setPrototypeOf(sr, SyntheticShadowRoot.prototype);
    return sr;
}
exports.attachShadow = attachShadow;
const SyntheticShadowRootDescriptors = {
    constructor: {
        writable: true,
        configurable: true,
        value: SyntheticShadowRoot,
    },
    toString: {
        writable: true,
        configurable: true,
        value() {
            return `[object ShadowRoot]`;
        },
    },
};
const ShadowRootDescriptors = {
    activeElement: {
        enumerable: true,
        configurable: true,
        get() {
            const host = getHost(this);
            const doc = utils_1.getOwnerDocument(host);
            const activeElement = document_1.DocumentPrototypeActiveElement.call(doc);
            if (language_1.isNull(activeElement)) {
                return activeElement;
            }
            if ((node_1.compareDocumentPosition.call(host, activeElement) &
                node_1.DOCUMENT_POSITION_CONTAINED_BY) ===
                0) {
                return null;
            }
            // activeElement must be child of the host and owned by it
            let node = activeElement;
            while (!traverse_1.isNodeOwnedBy(host, node)) {
                // parentElement is always an element because we are talking up the tree knowing
                // that it is a child of the host.
                node = node_1.parentElementGetter.call(node);
            }
            // If we have a slot element here that means that we were dealing
            // with an element that was passed to one of our slots. In this
            // case, activeElement returns null.
            if (traverse_1.isSlotElement(node)) {
                return null;
            }
            return node;
        },
    },
    delegatesFocus: {
        configurable: true,
        get() {
            return getInternalSlot(this).delegatesFocus;
        },
    },
    elementFromPoint: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(left, top) {
            const host = getHost(this);
            const doc = utils_1.getOwnerDocument(host);
            const element = document_1.elementFromPoint.call(doc, left, top);
            if (language_1.isNull(element)) {
                return element;
            }
            return retarget_1.retarget(this, path_composer_1.pathComposer(element, true));
        },
    },
    elementsFromPoint: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(_left, _top) {
            throw new Error();
        },
    },
    getSelection: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            throw new Error();
        },
    },
    host: {
        enumerable: true,
        configurable: true,
        get() {
            return getHost(this);
        },
    },
    mode: {
        configurable: true,
        get() {
            return getInternalSlot(this).mode;
        },
    },
    styleSheets: {
        enumerable: true,
        configurable: true,
        get() {
            throw new Error();
        },
    },
};
const NodePatchDescriptors = {
    insertBefore: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(newChild, refChild) {
            node_1.insertBefore.call(getHost(this), newChild, refChild);
            return newChild;
        },
    },
    removeChild: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(oldChild) {
            node_1.removeChild.call(getHost(this), oldChild);
            return oldChild;
        },
    },
    appendChild: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(newChild) {
            node_1.appendChild.call(getHost(this), newChild);
            return newChild;
        },
    },
    replaceChild: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(newChild, oldChild) {
            node_1.replaceChild.call(getHost(this), newChild, oldChild);
            return oldChild;
        },
    },
    addEventListener: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(type, listener, options) {
            events_1.addShadowRootEventListener(this, type, listener, options);
        },
    },
    removeEventListener: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(type, listener, options) {
            events_1.removeShadowRootEventListener(this, type, listener, options);
        },
    },
    baseURI: {
        enumerable: true,
        configurable: true,
        get() {
            return getHost(this).baseURI;
        },
    },
    childNodes: {
        enumerable: true,
        configurable: true,
        get() {
            return static_node_list_1.createStaticNodeList(traverse_1.shadowRootChildNodes(this));
        },
    },
    compareDocumentPosition: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(otherNode) {
            const host = getHost(this);
            if (this === otherNode) {
                // "this" and "otherNode" are the same shadow root.
                return 0;
            }
            else if (this.contains(otherNode)) {
                // "otherNode" belongs to the shadow tree where "this" is the shadow root.
                return 20; // Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING
            }
            else if (node_1.compareDocumentPosition.call(host, otherNode) & node_1.DOCUMENT_POSITION_CONTAINED_BY) {
                // "otherNode" is in a different shadow tree contained by the shadow tree where "this" is the shadow root.
                return 37; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
            }
            else {
                // "otherNode" is in a different shadow tree that is not contained by the shadow tree where "this" is the shadow root.
                return 35; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
            }
        },
    },
    contains: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(otherNode) {
            if (this === otherNode) {
                return true;
            }
            const host = getHost(this);
            // must be child of the host and owned by it.
            return ((node_1.compareDocumentPosition.call(host, otherNode) & node_1.DOCUMENT_POSITION_CONTAINED_BY) !==
                0 && traverse_1.isNodeOwnedBy(host, otherNode));
        },
    },
    firstChild: {
        enumerable: true,
        configurable: true,
        get() {
            const childNodes = node_2.getInternalChildNodes(this);
            return childNodes[0] || null;
        },
    },
    lastChild: {
        enumerable: true,
        configurable: true,
        get() {
            const childNodes = node_2.getInternalChildNodes(this);
            return childNodes[childNodes.length - 1] || null;
        },
    },
    hasChildNodes: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            const childNodes = node_2.getInternalChildNodes(this);
            return childNodes.length > 0;
        },
    },
    isConnected: {
        enumerable: true,
        configurable: true,
        get() {
            return node_1.isConnected.call(getHost(this));
        },
    },
    nextSibling: {
        enumerable: true,
        configurable: true,
        get() {
            return null;
        },
    },
    previousSibling: {
        enumerable: true,
        configurable: true,
        get() {
            return null;
        },
    },
    nodeName: {
        enumerable: true,
        configurable: true,
        get() {
            return '#document-fragment';
        },
    },
    nodeType: {
        enumerable: true,
        configurable: true,
        get() {
            return 11; // Node.DOCUMENT_FRAGMENT_NODE
        },
    },
    nodeValue: {
        enumerable: true,
        configurable: true,
        get() {
            return null;
        },
    },
    ownerDocument: {
        enumerable: true,
        configurable: true,
        get() {
            return getHost(this).ownerDocument;
        },
    },
    parentElement: {
        enumerable: true,
        configurable: true,
        get() {
            return null;
        },
    },
    parentNode: {
        enumerable: true,
        configurable: true,
        get() {
            return null;
        },
    },
    textContent: {
        enumerable: true,
        configurable: true,
        get() {
            const childNodes = node_2.getInternalChildNodes(this);
            let textContent = '';
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                textContent += text_content_1.getTextContent(childNodes[i]);
            }
            return textContent;
        },
        set(v) {
            const host = getHost(this);
            node_1.textContextSetter.call(host, v);
        },
    },
    // Since the synthetic shadow root is a detached DocumentFragment, short-circuit the getRootNode behavior
    getRootNode: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(options) {
            return !language_1.isUndefined(options) && language_1.isTrue(options.composed)
                ? getHost(this).getRootNode(options)
                : this;
        },
    },
};
const ElementPatchDescriptors = {
    innerHTML: {
        enumerable: true,
        configurable: true,
        get() {
            const childNodes = node_2.getInternalChildNodes(this);
            let innerHTML = '';
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                innerHTML += outer_html_1.getOuterHTML(childNodes[i]);
            }
            return innerHTML;
        },
        set(v) {
            const host = getHost(this);
            element_1.innerHTMLSetter.call(host, v);
        },
    },
};
const ParentNodePatchDescriptors = {
    childElementCount: {
        enumerable: true,
        configurable: true,
        get() {
            return this.children.length;
        },
    },
    children: {
        enumerable: true,
        configurable: true,
        get() {
            return static_html_collection_1.createStaticHTMLCollection(language_1.ArrayFilter.call(traverse_1.shadowRootChildNodes(this), (elm) => elm instanceof Element));
        },
    },
    firstElementChild: {
        enumerable: true,
        configurable: true,
        get() {
            return this.children[0] || null;
        },
    },
    lastElementChild: {
        enumerable: true,
        configurable: true,
        get() {
            const { children } = this;
            return children.item(children.length - 1) || null;
        },
    },
    querySelector: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(selectors) {
            return traverse_1.shadowRootQuerySelector(this, selectors);
        },
    },
    querySelectorAll: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(selectors) {
            return static_node_list_1.createStaticNodeList(traverse_1.shadowRootQuerySelectorAll(this, selectors));
        },
    },
};
language_1.assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);
function SyntheticShadowRoot() {
    throw new TypeError('Illegal constructor');
}
exports.SyntheticShadowRoot = SyntheticShadowRoot;
SyntheticShadowRoot.prototype = language_1.create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);
// Is native ShadowDom is available on window,
// we need to make sure that our synthetic shadow dom
// passed instanceof checks against window.ShadowDom
if (dom_1.isNativeShadowRootAvailable) {
    language_1.setPrototypeOf(SyntheticShadowRoot.prototype, window.ShadowRoot.prototype);
}
/**
 * This method is only intended to be used in non-production mode in IE11
 * and its role is to produce a 1-1 mapping between a shadowRoot instance
 * and a comment node that is intended to use to trick the IE11 DevTools
 * to show the content of the shadowRoot in the DOM Explorer.
 */
function getIE11FakeShadowRootPlaceholder(host) {
    const shadowRoot = getShadowRoot(host);
    // @ts-ignore this $$placeholder$$ is not a security issue because you must
    // have access to the shadowRoot in order to extract the fake node, which give
    // you access to the same childNodes of the shadowRoot, so, who cares.
    let c = shadowRoot.$$placeholder$$;
    if (!language_1.isUndefined(c)) {
        return c;
    }
    const doc = utils_1.getOwnerDocument(host);
    // @ts-ignore $$placeholder$$ is fine, read the node above.
    c = shadowRoot.$$placeholder$$ = document_1.createComment.call(doc, '');
    language_1.defineProperties(c, {
        childNodes: {
            get() {
                return shadowRoot.childNodes;
            },
            enumerable: true,
            configurable: true,
        },
        tagName: {
            get() {
                return `#shadow-root (${shadowRoot.mode})`;
            },
            enumerable: true,
            configurable: true,
        },
    });
    return c;
}
exports.getIE11FakeShadowRootPlaceholder = getIE11FakeShadowRootPlaceholder;
//# sourceMappingURL=shadow-root.js.map