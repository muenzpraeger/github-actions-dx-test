"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const node_1 = require("../env/node");
const language_1 = require("../shared/language");
const traverse_1 = require("./traverse");
const shadow_root_1 = require("./shadow-root");
const dom_1 = require("../env/dom");
const path_composer_1 = require("./../3rdparty/polymer/path-composer");
const retarget_1 = require("./../3rdparty/polymer/retarget");
require("../polyfills/event-listener/main");
const utils_1 = require("../shared/utils");
const node_2 = require("./node");
// intentionally extracting the patched addEventListener and removeEventListener from Node.prototype
// due to the issues with JSDOM patching hazard.
const { addEventListener, removeEventListener } = Node.prototype;
var EventListenerContext;
(function (EventListenerContext) {
    EventListenerContext[EventListenerContext["CUSTOM_ELEMENT_LISTENER"] = 1] = "CUSTOM_ELEMENT_LISTENER";
    EventListenerContext[EventListenerContext["SHADOW_ROOT_LISTENER"] = 2] = "SHADOW_ROOT_LISTENER";
})(EventListenerContext || (EventListenerContext = {}));
const eventToContextMap = new WeakMap();
function isChildNode(root, node) {
    return !!(node_1.compareDocumentPosition.call(root, node) & node_1.DOCUMENT_POSITION_CONTAINED_BY);
}
const GET_ROOT_NODE_CONFIG_FALSE = { composed: false };
function getRootNodeHost(node, options) {
    let rootNode = traverse_1.patchedGetRootNode.call(node, options);
    // is SyntheticShadowRootInterface
    if ('mode' in rootNode && 'delegatesFocus' in rootNode) {
        rootNode = shadow_root_1.getHost(rootNode);
    }
    return rootNode;
}
function targetGetter() {
    // currentTarget is always defined
    const originalCurrentTarget = dom_1.eventCurrentTargetGetter.call(this);
    const originalTarget = dom_1.eventTargetGetter.call(this);
    const composedPath = path_composer_1.pathComposer(originalTarget, this.composed);
    const doc = utils_1.getOwnerDocument(originalTarget);
    // Handle cases where the currentTarget is null (for async events),
    // and when an event has been added to Window
    if (!(originalCurrentTarget instanceof Node)) {
        // TODO: issue #1511 - Special escape hatch to support legacy behavior. Should be fixed.
        // If the event's target is being accessed async and originalTarget is not a keyed element, do not retarget
        if (language_1.isNull(originalCurrentTarget) && language_1.isUndefined(node_2.getNodeOwnerKey(originalTarget))) {
            return originalTarget;
        }
        return retarget_1.retarget(doc, composedPath);
    }
    else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
        // TODO: issue #1530 - If currentTarget is document or document.body (Third party libraries that have global event listeners)
        // and the originalTarget is not a keyed element, do not retarget
        if (language_1.isUndefined(node_2.getNodeOwnerKey(originalTarget))) {
            return originalTarget;
        }
        return retarget_1.retarget(doc, composedPath);
    }
    const eventContext = eventToContextMap.get(this);
    const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER
        ? shadow_root_1.getShadowRoot(originalCurrentTarget)
        : originalCurrentTarget;
    return retarget_1.retarget(currentTarget, composedPath);
}
function composedPathValue() {
    const originalTarget = dom_1.eventTargetGetter.call(this);
    return path_composer_1.pathComposer(originalTarget, this.composed);
}
function patchEvent(event) {
    if (eventToContextMap.has(event)) {
        return; // already patched
    }
    language_1.defineProperties(event, {
        target: {
            get: targetGetter,
            enumerable: true,
            configurable: true,
        },
        composedPath: {
            value: composedPathValue,
            writable: true,
            enumerable: true,
            configurable: true,
        },
        // non-standard but important accessor
        srcElement: {
            get: targetGetter,
            enumerable: true,
            configurable: true,
        },
        path: {
            get: composedPathValue,
            enumerable: true,
            configurable: true,
        },
    });
    // not all events implement the relatedTarget getter, that's why we need to extract it from the instance
    // Note: we can't really use the super here because of issues with the typescript transpilation for accessors
    const originalRelatedTargetDescriptor = language_1.getPropertyDescriptor(event, 'relatedTarget');
    if (!language_1.isUndefined(originalRelatedTargetDescriptor)) {
        const relatedTargetGetter = originalRelatedTargetDescriptor.get;
        language_1.defineProperty(event, 'relatedTarget', {
            get() {
                const eventContext = eventToContextMap.get(this);
                const originalCurrentTarget = dom_1.eventCurrentTargetGetter.call(this);
                const relatedTarget = relatedTargetGetter.call(this);
                if (language_1.isNull(relatedTarget)) {
                    return null;
                }
                const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER
                    ? shadow_root_1.getShadowRoot(originalCurrentTarget) /* because the context is a host */
                    : originalCurrentTarget;
                return retarget_1.retarget(currentTarget, path_composer_1.pathComposer(relatedTarget, true));
            },
            enumerable: true,
            configurable: true,
        });
    }
    eventToContextMap.set(event, 0);
}
exports.patchEvent = patchEvent;
const customElementToWrappedListeners = new WeakMap();
function getEventMap(elm) {
    let listenerInfo = customElementToWrappedListeners.get(elm);
    if (language_1.isUndefined(listenerInfo)) {
        listenerInfo = language_1.create(null);
        customElementToWrappedListeners.set(elm, listenerInfo);
    }
    return listenerInfo;
}
const shadowRootEventListenerMap = new WeakMap();
function getWrappedShadowRootListener(sr, listener) {
    if (!language_1.isFunction(listener)) {
        throw new TypeError(); // avoiding problems with non-valid listeners
    }
    let shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);
    if (language_1.isUndefined(shadowRootWrappedListener)) {
        shadowRootWrappedListener = function (event) {
            // * if the event is dispatched directly on the host, it is not observable from root
            // * if the event is dispatched in an element that does not belongs to the shadow and it is not composed,
            //   it is not observable from the root
            const { composed } = event;
            const target = dom_1.eventTargetGetter.call(event);
            const currentTarget = dom_1.eventCurrentTargetGetter.call(event);
            if (target !== currentTarget) {
                const rootNode = getRootNodeHost(target /* because wrapping on shadowRoot */, {
                    composed,
                });
                if (isChildNode(rootNode, currentTarget) ||
                    (composed === false && rootNode === currentTarget)) {
                    listener.call(sr, event);
                }
            }
        };
        shadowRootWrappedListener.placement = EventListenerContext.SHADOW_ROOT_LISTENER;
        if (process.env.NODE_ENV !== 'production') {
            shadowRootWrappedListener.original = listener; // for logging purposes
        }
        shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
    }
    return shadowRootWrappedListener;
}
const customElementEventListenerMap = new WeakMap();
function getWrappedCustomElementListener(elm, listener) {
    if (!language_1.isFunction(listener)) {
        throw new TypeError(); // avoiding problems with non-valid listeners
    }
    let customElementWrappedListener = customElementEventListenerMap.get(listener);
    if (language_1.isUndefined(customElementWrappedListener)) {
        customElementWrappedListener = function (event) {
            if (isValidEventForCustomElement(event)) {
                // all handlers on the custom element should be called with undefined 'this'
                listener.call(elm, event);
            }
        };
        customElementWrappedListener.placement = EventListenerContext.CUSTOM_ELEMENT_LISTENER;
        if (process.env.NODE_ENV !== 'production') {
            customElementWrappedListener.original = listener; // for logging purposes
        }
        customElementEventListenerMap.set(listener, customElementWrappedListener);
    }
    return customElementWrappedListener;
}
function domListener(evt) {
    let immediatePropagationStopped = false;
    let propagationStopped = false;
    const { type, stopImmediatePropagation, stopPropagation } = evt;
    // currentTarget is always defined
    const currentTarget = dom_1.eventCurrentTargetGetter.call(evt);
    const listenerMap = getEventMap(currentTarget);
    const listeners = listenerMap[type]; // it must have listeners at this point
    language_1.defineProperty(evt, 'stopImmediatePropagation', {
        value() {
            immediatePropagationStopped = true;
            stopImmediatePropagation.call(evt);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    language_1.defineProperty(evt, 'stopPropagation', {
        value() {
            propagationStopped = true;
            stopPropagation.call(evt);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    // in case a listener adds or removes other listeners during invocation
    const bookkeeping = language_1.ArraySlice.call(listeners);
    function invokeListenersByPlacement(placement) {
        language_1.forEach.call(bookkeeping, (listener) => {
            if (language_1.isFalse(immediatePropagationStopped) && listener.placement === placement) {
                // making sure that the listener was not removed from the original listener queue
                if (language_1.ArrayIndexOf.call(listeners, listener) !== -1) {
                    // all handlers on the custom element should be called with undefined 'this'
                    listener.call(undefined, evt);
                }
            }
        });
    }
    eventToContextMap.set(evt, EventListenerContext.SHADOW_ROOT_LISTENER);
    invokeListenersByPlacement(EventListenerContext.SHADOW_ROOT_LISTENER);
    if (language_1.isFalse(immediatePropagationStopped) && language_1.isFalse(propagationStopped)) {
        // doing the second iteration only if the first one didn't interrupt the event propagation
        eventToContextMap.set(evt, EventListenerContext.CUSTOM_ELEMENT_LISTENER);
        invokeListenersByPlacement(EventListenerContext.CUSTOM_ELEMENT_LISTENER);
    }
    eventToContextMap.set(evt, 0);
}
function attachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let cmpEventHandlers = listenerMap[type];
    if (language_1.isUndefined(cmpEventHandlers)) {
        cmpEventHandlers = listenerMap[type] = [];
    }
    // only add to DOM if there is no other listener on the same placement yet
    if (cmpEventHandlers.length === 0) {
        addEventListener.call(elm, type, domListener);
    }
    language_1.ArrayPush.call(cmpEventHandlers, wrappedListener);
}
function detachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let p;
    let listeners;
    if (!language_1.isUndefined((listeners = listenerMap[type])) &&
        (p = language_1.ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
        language_1.ArraySplice.call(listeners, p, 1);
        // only remove from DOM if there is no other listener on the same placement
        if (listeners.length === 0) {
            removeEventListener.call(elm, type, domListener);
        }
    }
}
function isValidEventForCustomElement(event) {
    const target = dom_1.eventTargetGetter.call(event);
    const currentTarget = dom_1.eventCurrentTargetGetter.call(event);
    const { composed } = event;
    return (
    // it is composed, and we should always get it, or
    composed === true ||
        // it is dispatched onto the custom element directly, or
        target === currentTarget ||
        // it is coming from a slotted element
        isChildNode(getRootNodeHost(target /* because wrap on shadowRoot */, GET_ROOT_NODE_CONFIG_FALSE), currentTarget));
}
function addCustomElementEventListener(elm, type, listener, options) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(language_1.isFunction(listener), `Invalid second argument for this.addEventListener() in ${language_1.toString(elm)} for event "${type}". Expected an EventListener but received ${listener}.`);
        // TODO: #420 - this is triggered when the component author attempts to add a listener
        // programmatically into a lighting element node
        if (!language_1.isUndefined(options)) {
            assert_1.default.logError('The `addEventListener` method in `LightningElement` does not support any options.', elm);
        }
    }
    const wrappedListener = getWrappedCustomElementListener(elm, listener);
    attachDOMListener(elm, type, wrappedListener);
}
exports.addCustomElementEventListener = addCustomElementEventListener;
function removeCustomElementEventListener(elm, type, listener, _options) {
    const wrappedListener = getWrappedCustomElementListener(elm, listener);
    detachDOMListener(elm, type, wrappedListener);
}
exports.removeCustomElementEventListener = removeCustomElementEventListener;
function addShadowRootEventListener(sr, type, listener, options) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(language_1.isFunction(listener), `Invalid second argument for this.template.addEventListener() in ${language_1.toString(sr)} for event "${type}". Expected an EventListener but received ${listener}.`);
        // TODO: #420 - this is triggered when the component author attempts to add a listener
        // programmatically into its Component's shadow root
        if (!language_1.isUndefined(options)) {
            assert_1.default.logError('The `addEventListener` method in `LightningElement` does not support any options.', shadow_root_1.getHost(sr));
        }
    }
    const elm = shadow_root_1.getHost(sr);
    const wrappedListener = getWrappedShadowRootListener(sr, listener);
    attachDOMListener(elm, type, wrappedListener);
}
exports.addShadowRootEventListener = addShadowRootEventListener;
function removeShadowRootEventListener(sr, type, listener, _options) {
    const elm = shadow_root_1.getHost(sr);
    const wrappedListener = getWrappedShadowRootListener(sr, listener);
    detachDOMListener(elm, type, wrappedListener);
}
exports.removeShadowRootEventListener = removeShadowRootEventListener;
//# sourceMappingURL=events.js.map