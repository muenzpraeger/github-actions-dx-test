"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const fields_1 = require("../shared/fields");
const window_1 = require("../env/window");
const element_1 = require("../env/element");
const node_1 = require("../env/node");
const language_1 = require("../shared/language");
const document_1 = require("../env/document");
const dom_1 = require("../env/dom");
const shadow_root_1 = require("./shadow-root");
const utils_1 = require("../shared/utils");
const traverse_1 = require("./traverse");
const node_collection_util_1 = require("../shared/node-collection-util");
const TabbableElementsQuery = `
    button:not([tabindex="-1"]):not([disabled]),
    [contenteditable]:not([tabindex="-1"]),
    video[controls]:not([tabindex="-1"]),
    audio[controls]:not([tabindex="-1"]),
    [href]:not([tabindex="-1"]),
    input:not([tabindex="-1"]):not([disabled]),
    select:not([tabindex="-1"]):not([disabled]),
    textarea:not([tabindex="-1"]):not([disabled]),
    [tabindex="0"]
`;
const DidAddMouseDownListener = fields_1.createFieldName('DidAddMouseDownListener');
function isVisible(element) {
    const { width, height } = element_1.getBoundingClientRect.call(element);
    const noZeroSize = width > 0 || height > 0;
    return noZeroSize && getComputedStyle(element).visibility !== 'hidden';
}
// This function based on https://allyjs.io/data-tables/focusable.html
// It won't catch everything, but should be good enough
// There are a lot of edge cases here that we can't realistically handle
// Determines if a particular element is tabbable, as opposed to simply focusable
// Exported for jest purposes
function isTabbable(element) {
    return element_1.matches.call(element, TabbableElementsQuery) && isVisible(element);
}
exports.isTabbable = isTabbable;
function getTabbableSegments(host) {
    const doc = utils_1.getOwnerDocument(host);
    const all = document_1.querySelectorAll.call(doc, TabbableElementsQuery);
    const inner = node_collection_util_1.collectionSlice(element_1.querySelectorAll.call(host, TabbableElementsQuery));
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(element_1.getAttribute.call(host, 'tabindex') === '-1' || shadow_root_1.isDelegatingFocus(host), `The focusin event is only relevant when the tabIndex property is -1 on the host.`);
    }
    const firstChild = inner[0];
    const lastChild = inner[inner.length - 1];
    const hostIndex = node_collection_util_1.collectionIndexOf(all, host);
    // Host element can show up in our "previous" section if its tabindex is 0
    // We want to filter that out here
    const firstChildIndex = hostIndex > -1 ? hostIndex : node_collection_util_1.collectionIndexOf(all, firstChild);
    // Account for an empty inner list
    const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : node_collection_util_1.collectionIndexOf(all, lastChild) + 1;
    const prev = node_collection_util_1.collectionSlice(all, 0, firstChildIndex);
    const next = node_collection_util_1.collectionSlice(all, lastChildIndex);
    return {
        prev,
        inner,
        next,
    };
}
function getActiveElement(host) {
    const doc = utils_1.getOwnerDocument(host);
    const activeElement = document_1.DocumentPrototypeActiveElement.call(doc);
    if (language_1.isNull(activeElement)) {
        return activeElement;
    }
    // activeElement must be child of the host and owned by it
    return (node_1.compareDocumentPosition.call(host, activeElement) & node_1.DOCUMENT_POSITION_CONTAINED_BY) !==
        0
        ? activeElement
        : null;
}
exports.getActiveElement = getActiveElement;
function relatedTargetPosition(host, relatedTarget) {
    // assert: target must be child of host
    const pos = node_1.compareDocumentPosition.call(host, relatedTarget);
    if (pos & node_1.DOCUMENT_POSITION_CONTAINED_BY) {
        // focus remains inside the host
        return 0;
    }
    else if (pos & node_1.DOCUMENT_POSITION_PRECEDING) {
        // focus is coming from above
        return 1;
    }
    else if (pos & node_1.DOCUMENT_POSITION_FOLLOWING) {
        // focus is coming from below
        return 2;
    }
    // we don't know what's going on.
    return -1;
}
function muteEvent(event) {
    event.preventDefault();
    event.stopPropagation();
}
function muteFocusEventsDuringExecution(win, func) {
    window_1.windowAddEventListener.call(win, 'focusin', muteEvent, true);
    window_1.windowAddEventListener.call(win, 'focusout', muteEvent, true);
    func();
    window_1.windowRemoveEventListener.call(win, 'focusin', muteEvent, true);
    window_1.windowRemoveEventListener.call(win, 'focusout', muteEvent, true);
}
function focusOnNextOrBlur(segment, target, relatedTarget) {
    const win = utils_1.getOwnerWindow(relatedTarget);
    const next = getNextTabbable(segment, relatedTarget);
    if (language_1.isNull(next)) {
        // nothing to focus on, blur to invalidate the operation
        muteFocusEventsDuringExecution(win, () => {
            target.blur();
        });
    }
    else {
        muteFocusEventsDuringExecution(win, () => {
            next.focus();
        });
    }
}
let letBrowserHandleFocus = false;
function disableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = true;
}
exports.disableKeyboardFocusNavigationRoutines = disableKeyboardFocusNavigationRoutines;
function enableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = false;
}
exports.enableKeyboardFocusNavigationRoutines = enableKeyboardFocusNavigationRoutines;
function skipHostHandler(event) {
    if (letBrowserHandleFocus) {
        enableKeyboardFocusNavigationRoutines();
        return;
    }
    const host = dom_1.eventCurrentTargetGetter.call(event);
    const target = dom_1.eventTargetGetter.call(event);
    // If the host delegating focus with tabindex=0 is not the target, we know
    // that the event was dispatched on a descendant node of the host. This
    // means the focus is coming from below and we don't need to do anything.
    if (host !== target) {
        // Focus is coming from above
        return;
    }
    const relatedTarget = dom_1.focusEventRelatedTargetGetter.call(event);
    if (language_1.isNull(relatedTarget)) {
        // If relatedTarget is null, the user is most likely tabbing into the document from the
        // browser chrome. We could probably deduce whether focus is coming in from the top or the
        // bottom by comparing the position of the target to all tabbable elements. This is an edge
        // case and only comes up if the custom element is the first or last tabbable element in the
        // document.
        return;
    }
    const segments = getTabbableSegments(host);
    const position = relatedTargetPosition(host, relatedTarget);
    if (position === 1) {
        // Focus is coming from above
        const findTabbableElms = isTabbableFrom.bind(null, traverse_1.patchedGetRootNode.call(host));
        const first = language_1.ArrayFind.call(segments.inner, findTabbableElms);
        if (!language_1.isUndefined(first)) {
            const win = utils_1.getOwnerWindow(first);
            muteFocusEventsDuringExecution(win, () => {
                first.focus();
            });
        }
        else {
            focusOnNextOrBlur(segments.next, target, relatedTarget);
        }
    }
    else if (host === target) {
        // Host is receiving focus from below, either from its shadow or from a sibling
        focusOnNextOrBlur(language_1.ArrayReverse.call(segments.prev), target, relatedTarget);
    }
}
function skipShadowHandler(event) {
    if (letBrowserHandleFocus) {
        enableKeyboardFocusNavigationRoutines();
        return;
    }
    const relatedTarget = dom_1.focusEventRelatedTargetGetter.call(event);
    if (language_1.isNull(relatedTarget)) {
        // If relatedTarget is null, the user is most likely tabbing into the document from the
        // browser chrome. We could probably deduce whether focus is coming in from the top or the
        // bottom by comparing the position of the target to all tabbable elements. This is an edge
        // case and only comes up if the custom element is the first or last tabbable element in the
        // document.
        return;
    }
    const host = dom_1.eventCurrentTargetGetter.call(event);
    const segments = getTabbableSegments(host);
    if (language_1.ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
        // If relatedTarget is contained by the host's subtree we can assume that the user is
        // tabbing between elements inside of the shadow. Do nothing.
        return;
    }
    const target = dom_1.eventTargetGetter.call(event);
    // Determine where the focus is coming from (Tab or Shift+Tab)
    const position = relatedTargetPosition(host, relatedTarget);
    if (position === 1) {
        // Focus is coming from above
        focusOnNextOrBlur(segments.next, target, relatedTarget);
    }
    if (position === 2) {
        // Focus is coming from below
        focusOnNextOrBlur(language_1.ArrayReverse.call(segments.prev), target, relatedTarget);
    }
}
// Use this function to determine whether you can start from one root and end up
// at another element via tabbing.
function isTabbableFrom(fromRoot, toElm) {
    if (!isTabbable(toElm)) {
        return false;
    }
    const ownerDocument = utils_1.getOwnerDocument(toElm);
    let root = traverse_1.patchedGetRootNode.call(toElm);
    while (root !== ownerDocument && root !== fromRoot) {
        const sr = root;
        const host = sr.host;
        if (element_1.getAttribute.call(host, 'tabindex') === '-1') {
            return false;
        }
        root = host && traverse_1.patchedGetRootNode.call(host);
    }
    return true;
}
function getNextTabbable(tabbables, relatedTarget) {
    const len = tabbables.length;
    if (len > 0) {
        for (let i = 0; i < len; i += 1) {
            const next = tabbables[i];
            if (isTabbableFrom(traverse_1.patchedGetRootNode.call(relatedTarget), next)) {
                return next;
            }
        }
    }
    return null;
}
// Skips the host element
function handleFocus(elm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(shadow_root_1.isDelegatingFocus(elm), `Invalid attempt to handle focus event for ${language_1.toString(elm)}. ${language_1.toString(elm)} should have delegates focus true, but is not delegating focus`);
    }
    bindDocumentMousedownMouseupHandlers(elm);
    // Unbind any focusin listeners we may have going on
    ignoreFocusIn(elm);
    element_1.addEventListener.call(elm, 'focusin', skipHostHandler, true);
}
exports.handleFocus = handleFocus;
function ignoreFocus(elm) {
    element_1.removeEventListener.call(elm, 'focusin', skipHostHandler, true);
}
exports.ignoreFocus = ignoreFocus;
function bindDocumentMousedownMouseupHandlers(elm) {
    const ownerDocument = utils_1.getOwnerDocument(elm);
    if (!fields_1.getInternalField(ownerDocument, DidAddMouseDownListener)) {
        fields_1.setInternalField(ownerDocument, DidAddMouseDownListener, true);
        element_1.addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);
        // Although our sequential focus navigation routines also unset this
        // flag, we need a backup plan in case they don't execute (e.g., the
        // click doesn't result in focus entering the shadow).
        element_1.addEventListener.call(ownerDocument, 'mouseup', () => {
            // We schedule this as an async task in the mouseup handler (as
            // opposed to the mousedown handler) because we want to guarantee
            // that it will never run before the focusin handler:
            //
            // Click form element   | Click form element label
            // ==================================================
            // mousedown            | mousedown
            // FOCUSIN              | mousedown-setTimeout
            // mousedown-setTimeout | mouseup
            // mouseup              | FOCUSIN
            // mouseup-setTimeout   | mouseup-setTimeout
            setTimeout(enableKeyboardFocusNavigationRoutines);
        }, true);
    }
}
// Skips the shadow tree
function handleFocusIn(elm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(element_1.tabIndexGetter.call(elm) === -1, `Invalid attempt to handle focus in  ${language_1.toString(elm)}. ${language_1.toString(elm)} should have tabIndex -1, but has tabIndex ${element_1.tabIndexGetter.call(elm)}`);
    }
    bindDocumentMousedownMouseupHandlers(elm);
    // Unbind any focus listeners we may have going on
    ignoreFocus(elm);
    // This focusin listener is to catch focusin events from keyboard interactions
    // A better solution would perhaps be to listen for keydown events, but
    // the keydown event happens on whatever element already has focus (or no element
    // at all in the case of the location bar. So, instead we have to assume that focusin
    // without a mousedown means keyboard navigation
    element_1.addEventListener.call(elm, 'focusin', skipShadowHandler, true);
}
exports.handleFocusIn = handleFocusIn;
function ignoreFocusIn(elm) {
    element_1.removeEventListener.call(elm, 'focusin', skipShadowHandler, true);
}
exports.ignoreFocusIn = ignoreFocusIn;
//# sourceMappingURL=focus.js.map