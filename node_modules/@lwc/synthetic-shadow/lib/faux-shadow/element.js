"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const shadow_root_1 = require("./shadow-root");
const events_1 = require("./events");
const traverse_1 = require("./traverse");
const element_1 = require("../env/element");
const language_1 = require("../shared/language");
const focus_1 = require("./focus");
const static_node_list_1 = require("../shared/static-node-list");
const static_html_collection_1 = require("../shared/static-html-collection");
const node_1 = require("./node");
const node_2 = require("./node");
const node_3 = require("../env/node");
const element_2 = require("../env/element");
const outer_html_1 = require("../3rdparty/polymer/outer-html");
require("../polyfills/node-get-root-node/main");
// when finding a slot in the DOM, we can fold it if it is contained
// inside another slot.
function foldSlotElement(slot) {
    let parent = node_3.parentElementGetter.call(slot);
    while (!language_1.isNull(parent) && traverse_1.isSlotElement(parent)) {
        slot = parent;
        parent = node_3.parentElementGetter.call(slot);
    }
    return slot;
}
function isNodeSlotted(host, node) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(host instanceof HTMLElement, `isNodeSlotted() should be called with a host as the first argument instead of ${host}`);
        assert_1.default.invariant(node instanceof Node, `isNodeSlotted() should be called with a node as the second argument instead of ${node}`);
        assert_1.default.isTrue(node_3.compareDocumentPosition.call(node, host) & node_3.DOCUMENT_POSITION_CONTAINS, `isNodeSlotted() should never be called with a node that is not a child node of ${host}`);
    }
    const hostKey = node_2.getNodeKey(host);
    // this routine assumes that the node is coming from a different shadow (it is not owned by the host)
    // just in case the provided node is not an element
    let currentElement = node instanceof Element ? node : node_3.parentElementGetter.call(node);
    while (!language_1.isNull(currentElement) && currentElement !== host) {
        const elmOwnerKey = node_2.getNodeNearestOwnerKey(currentElement);
        const parent = node_3.parentElementGetter.call(currentElement);
        if (elmOwnerKey === hostKey) {
            // we have reached an element inside the host's template, and only if
            // that element is an slot, then the node is considered slotted
            return traverse_1.isSlotElement(currentElement);
        }
        else if (parent === host) {
            return false;
        }
        else if (!language_1.isNull(parent) && node_2.getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
            // we are crossing a boundary of some sort since the elm and its parent
            // have different owner key. for slotted elements, this is possible
            // if the parent happens to be a slot.
            if (traverse_1.isSlotElement(parent)) {
                /**
                 * the slot parent might be allocated inside another slot, think of:
                 * <x-root> (<--- root element)
                 *    <x-parent> (<--- own by x-root)
                 *       <x-child> (<--- own by x-root)
                 *           <slot> (<--- own by x-child)
                 *               <slot> (<--- own by x-parent)
                 *                  <div> (<--- own by x-root)
                 *
                 * while checking if x-parent has the div slotted, we need to traverse
                 * up, but when finding the first slot, we skip that one in favor of the
                 * most outer slot parent before jumping into its corresponding host.
                 */
                currentElement = traverse_1.getNodeOwner(foldSlotElement(parent));
                if (!language_1.isNull(currentElement)) {
                    if (currentElement === host) {
                        // the slot element is a top level element inside the shadow
                        // of a host that was allocated into host in question
                        return true;
                    }
                    else if (node_2.getNodeNearestOwnerKey(currentElement) === hostKey) {
                        // the slot element is an element inside the shadow
                        // of a host that was allocated into host in question
                        return true;
                    }
                }
            }
            else {
                return false;
            }
        }
        else {
            currentElement = parent;
        }
    }
    return false;
}
function getAllSlottedMatches(host, nodeList) {
    const filteredAndPatched = [];
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
        const node = nodeList[i];
        if (!traverse_1.isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
            language_1.ArrayPush.call(filteredAndPatched, node);
        }
    }
    return filteredAndPatched;
}
function getFirstSlottedMatch(host, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
        const node = nodeList[i];
        if (!traverse_1.isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
            return node;
        }
    }
    return null;
}
function lightDomQuerySelectorAll(elm, selectors) {
    const owner = traverse_1.getNodeOwner(elm);
    if (language_1.isNull(owner)) {
        return [];
    }
    const nodeList = element_2.querySelectorAll.call(elm, selectors);
    if (node_2.getNodeKey(elm)) {
        // it is a custom element, and we should then filter by slotted elements
        return getAllSlottedMatches(elm, nodeList);
    }
    else {
        // regular element, we should then filter by ownership
        return traverse_1.getAllMatches(owner, nodeList);
    }
}
function lightDomQuerySelector(elm, selector) {
    const owner = traverse_1.getNodeOwner(elm);
    if (language_1.isNull(owner)) {
        // the it is a root, and those can't have a lightdom
        return null;
    }
    const nodeList = element_2.querySelectorAll.call(elm, selector);
    if (node_2.getNodeKey(elm)) {
        // it is a custom element, and we should then filter by slotted elements
        return getFirstSlottedMatch(elm, nodeList);
    }
    else {
        // regular element, we should then filter by ownership
        return traverse_1.getFirstMatch(owner, nodeList);
    }
}
function PatchedElement(elm) {
    const Ctor = node_2.PatchedNode(elm);
    const { addEventListener: superAddEventListener, removeEventListener: superRemoveEventListener, blur: superBlur, focus: superFocus, } = elm;
    // Note: Element.getElementsByTagName and Element.getElementsByClassName are purposefully
    // omitted from the list of patched methods. In order for the querySelector* APIs to run
    // properly in jsdom, we need to make sure those methods doesn't respect the shadow DOM
    // semantic.
    // https://github.com/salesforce/lwc/pull/1179#issuecomment-484041707
    return class PatchedHTMLElement extends Ctor {
        // Regular Elements
        querySelector(selector) {
            return lightDomQuerySelector(this, selector);
        }
        querySelectorAll(selectors) {
            return static_node_list_1.createStaticNodeList(lightDomQuerySelectorAll(this, selectors));
        }
        get innerHTML() {
            const childNodes = node_2.getInternalChildNodes(this);
            let innerHTML = '';
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                innerHTML += outer_html_1.getOuterHTML(childNodes[i]);
            }
            return innerHTML;
        }
        set innerHTML(value) {
            element_2.innerHTMLSetter.call(this, value);
        }
        get outerHTML() {
            return outer_html_1.getOuterHTML(this);
        }
        set outerHTML(value) {
            element_1.outerHTMLSetter.call(this, value);
        }
        // CE patches
        attachShadow(options) {
            return shadow_root_1.attachShadow(this, options);
        }
        addEventListener(type, listener, options) {
            if (shadow_root_1.hasSyntheticShadow(this)) {
                events_1.addCustomElementEventListener(this, type, listener, options);
            }
            else {
                superAddEventListener.call(this, type, listener, options);
            }
        }
        removeEventListener(type, listener, options) {
            if (shadow_root_1.hasSyntheticShadow(this)) {
                events_1.removeCustomElementEventListener(this, type, listener, options);
            }
            else {
                superRemoveEventListener.call(this, type, listener, options);
            }
        }
        get shadowRoot() {
            if (shadow_root_1.hasSyntheticShadow(this)) {
                const shadow = shadow_root_1.getShadowRoot(this);
                if (shadow.mode === 'open') {
                    return shadow;
                }
            }
            return null;
        }
        get tabIndex() {
            if (shadow_root_1.hasSyntheticShadow(this) &&
                shadow_root_1.isDelegatingFocus(this) &&
                language_1.isFalse(element_1.hasAttribute.call(this, 'tabindex'))) {
                // this cover the case where the default tabindex should be 0 because the
                // custom element is delegating its focus
                return 0;
            }
            // NOTE: Technically this should be `super.tabIndex` however Typescript
            // has a known bug while transpiling down to ES5
            // https://github.com/Microsoft/TypeScript/issues/338
            const descriptor = language_1.getPropertyDescriptor(Ctor.prototype, 'tabIndex');
            return descriptor.get.call(this);
        }
        set tabIndex(value) {
            if (shadow_root_1.hasSyntheticShadow(this)) {
                // This tabIndex setter might be confusing unless it is understood that HTML
                // elements have default tabIndex property values. Natively focusable elements have
                // a default tabIndex value of 0 and all other elements have a default tabIndex
                // value of -1. For example, the tabIndex property value is -1 for both <x-foo> and
                // <x-foo tabindex="-1">, but our delegatesFocus polyfill should only kick in for
                // the latter case when the value of the tabindex attribute is -1.
                const delegatesFocus = shadow_root_1.isDelegatingFocus(this);
                // Record the state of things before invoking component setter.
                const prevValue = element_1.tabIndexGetter.call(this);
                const prevHasAttr = element_1.hasAttribute.call(this, 'tabindex');
                // NOTE: Technically this should be `super.tabIndex` however Typescript
                // has a known bug while transpiling down to ES5
                // https://github.com/Microsoft/TypeScript/issues/338
                const descriptor = language_1.getPropertyDescriptor(Ctor.prototype, 'tabIndex');
                descriptor.set.call(this, value);
                // Record the state of things after invoking component setter.
                const currValue = element_1.tabIndexGetter.call(this);
                const currHasAttr = element_1.hasAttribute.call(this, 'tabindex');
                const didValueChange = prevValue !== currValue;
                // If the tabindex attribute is initially rendered, we can assume that this setter has
                // previously executed and a listener has been added. We must remove that listener if
                // the tabIndex property value has changed or if the component no longer renders a
                // tabindex attribute.
                if (prevHasAttr && (didValueChange || language_1.isFalse(currHasAttr))) {
                    if (prevValue === -1) {
                        focus_1.ignoreFocusIn(this);
                    }
                    if (prevValue === 0 && delegatesFocus) {
                        focus_1.ignoreFocus(this);
                    }
                }
                // If a tabindex attribute was not rendered after invoking its setter, it means the
                // component is taking control. Do nothing.
                if (language_1.isFalse(currHasAttr)) {
                    return;
                }
                // If the tabindex attribute is initially rendered, we can assume that this setter has
                // previously executed and a listener has been added. If the tabindex attribute is still
                // rendered after invoking the setter AND the tabIndex property value has not changed,
                // we don't need to do any work.
                if (prevHasAttr && currHasAttr && language_1.isFalse(didValueChange)) {
                    return;
                }
                // At this point we know that a tabindex attribute was rendered after invoking the
                // setter and that either:
                // 1) This is the first time this setter is being invoked.
                // 2) This is not the first time this setter is being invoked and the value is changing.
                // We need to add the appropriate listeners in either case.
                if (currValue === -1) {
                    // Add the magic to skip the shadow tree
                    focus_1.handleFocusIn(this);
                }
                if (currValue === 0 && delegatesFocus) {
                    // Add the magic to skip the host element
                    focus_1.handleFocus(this);
                }
                return;
            }
            // NOTE: Technically this should be `super.tabIndex` however Typescript
            // has a known bug while transpiling down to ES5
            // https://github.com/Microsoft/TypeScript/issues/338
            const descriptor = language_1.getPropertyDescriptor(Ctor.prototype, 'tabIndex');
            descriptor.set.call(this, value);
        }
        blur() {
            if (shadow_root_1.hasSyntheticShadow(this) && shadow_root_1.isDelegatingFocus(this)) {
                const currentActiveElement = focus_1.getActiveElement(this);
                if (!language_1.isNull(currentActiveElement)) {
                    // if there is an active element, blur it
                    currentActiveElement.blur();
                    return;
                }
            }
            // NOTE: Technically this should be `super.blur` however Typescript
            // has a known bug while transpiling down to ES5
            // https://github.com/Microsoft/TypeScript/issues/338
            return superBlur.call(this);
        }
        focus() {
            focus_1.disableKeyboardFocusNavigationRoutines();
            // TODO: #1327 - Shadow DOM semantics for focus method
            superFocus.call(this);
            focus_1.enableKeyboardFocusNavigationRoutines();
        }
        get childNodes() {
            if (shadow_root_1.hasSyntheticShadow(this)) {
                const owner = traverse_1.getNodeOwner(this);
                const childNodes = language_1.isNull(owner)
                    ? []
                    : traverse_1.getAllMatches(owner, traverse_1.getFilteredChildNodes(this));
                if (process.env.NODE_ENV !== 'production' &&
                    language_1.isFalse(node_1.hasNativeSymbolsSupport) &&
                    node_1.isExternalChildNodeAccessorFlagOn()) {
                    // inserting a comment node as the first childNode to trick the IE11
                    // DevTool to show the content of the shadowRoot, this should only happen
                    // in dev-mode and in IE11 (which we detect by looking at the symbol).
                    // Plus it should only be in place if we know it is an external invoker.
                    language_1.ArrayUnshift.call(childNodes, shadow_root_1.getIE11FakeShadowRootPlaceholder(this));
                }
                return static_node_list_1.createStaticNodeList(childNodes);
            }
            // nothing to do here since this does not have a synthetic shadow attached to it
            return node_3.childNodesGetter.call(this);
        }
        get children() {
            if (shadow_root_1.hasSyntheticShadow(this)) {
                // We cannot patch `children` in test mode
                // because JSDOM uses children for its "native"
                // querySelector implementation. If we patch this,
                // HTMLElement.prototype.querySelector.call(element) will not
                // return any elements from shadow, which is not what we want
                if (process.env.NODE_ENV === 'test') {
                    return element_1.childrenGetter.call(this);
                }
                const owner = traverse_1.getNodeOwner(this);
                const childNodes = language_1.isNull(owner)
                    ? []
                    : traverse_1.getAllMatches(owner, traverse_1.getFilteredChildNodes(this));
                return static_html_collection_1.createStaticHTMLCollection(language_1.ArrayFilter.call(childNodes, (node) => node instanceof Element));
            }
            // nothing to do here since this does not have a synthetic shadow attached to it
            return element_1.childrenGetter.call(this);
        }
    };
}
exports.PatchedElement = PatchedElement;
//# sourceMappingURL=element.js.map