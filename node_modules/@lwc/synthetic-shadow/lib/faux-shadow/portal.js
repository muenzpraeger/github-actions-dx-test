"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const language_1 = require("../shared/language");
const node_1 = require("./node");
require("../polyfills/mutation-observer/main");
const shadow_root_1 = require("./shadow-root");
const shadow_token_1 = require("./shadow-token");
const MutationObserver = window.MutationObserver;
const MutationObserverObserve = MutationObserver.prototype.observe;
const DomManualPrivateKey = '$$DomManualKey$$';
// We can use a single observer without having to worry about leaking because
// "Registered observers in a nodeâ€™s registered observer list have a weak
// reference to the node."
// https://dom.spec.whatwg.org/#garbage-collection
let portalObserver;
const portalObserverConfig = {
    childList: true,
    subtree: true,
};
function adoptChildNode(node, fn, shadowToken) {
    if (shadow_root_1.getShadowRootResolver(node) === fn) {
        return; // nothing to do here, it is already correctly patched
    }
    shadow_root_1.setShadowRootResolver(node, fn);
    if (node instanceof Element) {
        shadow_token_1.setShadowToken(node, shadowToken);
        // recursively patching all children as well
        const childNodes = node_1.getInternalChildNodes(node);
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
            const child = childNodes[i];
            adoptChildNode(child, fn, shadowToken);
        }
    }
}
function initPortalObserver() {
    return new MutationObserver(mutations => {
        language_1.forEach.call(mutations, mutation => {
            const { target: elm, addedNodes } = mutation;
            // the target of the mutation should always have a ShadowRootResolver attached to it
            const fn = shadow_root_1.getShadowRootResolver(elm);
            const shadowToken = shadow_token_1.getShadowToken(elm);
            for (let i = 0, len = addedNodes.length; i < len; i += 1) {
                const node = addedNodes[i];
                adoptChildNode(node, fn, shadowToken);
            }
        });
    });
}
function markElementAsPortal(elm) {
    if (language_1.isUndefined(portalObserver)) {
        portalObserver = initPortalObserver();
    }
    if (language_1.isUndefined(shadow_root_1.getShadowRootResolver(elm))) {
        // only an element from a within a shadowRoot should be used here
        throw new Error(`Invalid Element`);
    }
    // install mutation observer for portals
    MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);
    // TODO: #1253 - optimization to synchronously adopt new child nodes added
    // to this elm, we can do that by patching the most common operations
    // on the node itself
}
/**
 * Patching Element.prototype.$domManual$ to mark elements as portal:
 *
 *  - we use a property to allow engines to signal that a particular element in
 *    a shadow supports manual insertion of child nodes.
 *
 *  - this signal comes as a boolean value, and we use it to install the MO instance
 *    onto the element, to propagate the $ownerKey$ and $shadowToken$ to all new
 *    child nodes.
 *
 *  - at the moment, there is no way to undo this operation, once the element is
 *    marked as $domManual$, setting it to false does nothing.
 *
 **/
// TODO: #1306 - rename this to $observerConnection$
language_1.defineProperty(Element.prototype, '$domManual$', {
    set(v) {
        this[DomManualPrivateKey] = v;
        if (language_1.isTrue(v)) {
            markElementAsPortal(this);
        }
    },
    get() {
        return this[DomManualPrivateKey];
    },
    configurable: true,
});
//# sourceMappingURL=portal.js.map