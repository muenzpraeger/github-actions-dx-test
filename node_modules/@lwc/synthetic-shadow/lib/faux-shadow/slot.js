"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const element_1 = require("../env/element");
const fields_1 = require("../shared/fields");
const dom_1 = require("../env/dom");
const language_1 = require("../shared/language");
const mutation_observer_1 = require("../env/mutation-observer");
const traverse_1 = require("./traverse");
const node_1 = require("../env/node");
const static_node_list_1 = require("../shared/static-node-list");
const static_html_collection_1 = require("../shared/static-html-collection");
const element_2 = require("./element");
const node_collection_util_1 = require("../shared/node-collection-util");
// We can use a single observer without having to worry about leaking because
// "Registered observers in a nodeâ€™s registered observer list have a weak
// reference to the node."
// https://dom.spec.whatwg.org/#garbage-collection
let observer;
const observerConfig = { childList: true };
const SlotChangeKey = fields_1.createFieldName('slotchange');
function initSlotObserver() {
    return new mutation_observer_1.MutationObserver(mutations => {
        const slots = [];
        language_1.forEach.call(mutations, mutation => {
            if (process.env.NODE_ENV !== 'production') {
                assert_1.default.isTrue(mutation.type === 'childList', `Invalid mutation type: ${mutation.type}. This mutation handler for slots should only handle "childList" mutations.`);
            }
            const { target: slot } = mutation;
            if (language_1.ArrayIndexOf.call(slots, slot) === -1) {
                language_1.ArrayPush.call(slots, slot);
                dom_1.dispatchEvent.call(slot, new CustomEvent('slotchange'));
            }
        });
    });
}
function getFilteredSlotAssignedNodes(slot) {
    const owner = traverse_1.getNodeOwner(slot);
    if (language_1.isNull(owner)) {
        return [];
    }
    const childNodes = node_collection_util_1.collectionSlice(node_1.childNodesGetter.call(slot));
    // Typescript is inferring the wrong function type for this particular
    // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
    // @ts-ignore type-mismatch
    return language_1.ArrayReduce.call(childNodes, (seed, child) => {
        if (!traverse_1.isNodeOwnedBy(owner, child)) {
            language_1.ArrayPush.call(seed, child);
        }
        return seed;
    }, []);
}
exports.getFilteredSlotAssignedNodes = getFilteredSlotAssignedNodes;
function getFilteredSlotFlattenNodes(slot) {
    const childNodes = node_collection_util_1.collectionSlice(node_1.childNodesGetter.call(slot));
    // Typescript is inferring the wrong function type for this particular
    // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
    // @ts-ignore type-mismatch
    return language_1.ArrayReduce.call(childNodes, (seed, child) => {
        if (child instanceof Element && traverse_1.isSlotElement(child)) {
            language_1.ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
        }
        else {
            language_1.ArrayPush.call(seed, child);
        }
        return seed;
    }, []);
}
function PatchedSlotElement(elm) {
    const Ctor = element_2.PatchedElement(elm);
    const { addEventListener: superAddEventListener } = elm;
    return class PatchedHTMLSlotElement extends Ctor {
        addEventListener(type, listener, options) {
            if (type === 'slotchange' && !fields_1.getInternalField(this, SlotChangeKey)) {
                if (process.env.NODE_ENV === 'test') {
                    /* eslint-disable-next-line no-console */
                    console.warn('The "slotchange" event is not supported in our jest test environment.');
                }
                fields_1.setInternalField(this, SlotChangeKey, true);
                if (!observer) {
                    observer = initSlotObserver();
                }
                mutation_observer_1.MutationObserverObserve.call(observer, this, observerConfig);
            }
            superAddEventListener.call(this, type, listener, options);
        }
        assignedElements(options) {
            const flatten = !language_1.isUndefined(options) && language_1.isTrue(options.flatten);
            const nodes = flatten
                ? getFilteredSlotFlattenNodes(this)
                : getFilteredSlotAssignedNodes(this);
            return language_1.ArrayFilter.call(nodes, node => node instanceof Element);
        }
        assignedNodes(options) {
            const flatten = !language_1.isUndefined(options) && language_1.isTrue(options.flatten);
            return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
        }
        get name() {
            // in browsers that do not support shadow dom, slot's name attribute is not reflective
            const name = element_1.getAttribute.call(this, 'name');
            return language_1.isNull(name) ? '' : name;
        }
        get childNodes() {
            const owner = traverse_1.getNodeOwner(this);
            const childNodes = language_1.isNull(owner)
                ? []
                : traverse_1.getAllMatches(owner, traverse_1.getFilteredChildNodes(this));
            return static_node_list_1.createStaticNodeList(childNodes);
        }
        get children() {
            // We cannot patch `children` in test mode
            // because JSDOM uses children for its "native"
            // querySelector implementation. If we patch this,
            // HTMLElement.prototype.querySelector.call(element) will not
            // return any elements from shadow, which is not what we want
            if (process.env.NODE_ENV === 'test') {
                return element_1.childrenGetter.call(this);
            }
            const owner = traverse_1.getNodeOwner(this);
            const childNodes = language_1.isNull(owner)
                ? []
                : traverse_1.getAllMatches(owner, traverse_1.getFilteredChildNodes(this));
            return static_html_collection_1.createStaticHTMLCollection(language_1.ArrayFilter.call(childNodes, (node) => node instanceof Element));
        }
    };
}
exports.PatchedSlotElement = PatchedSlotElement;
//# sourceMappingURL=slot.js.map