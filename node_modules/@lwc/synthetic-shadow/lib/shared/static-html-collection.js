"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const language_1 = require("./language");
const fields_1 = require("./fields");
const Items = fields_1.createFieldName('items');
function isValidHTMLCollectionName(name) {
    return name !== 'length' && isNaN(name);
}
function getNodeHTMLCollectionName(node) {
    return node.getAttribute('id') || node.getAttribute('name');
}
function StaticHTMLCollection() {
    throw new TypeError('Illegal constructor');
}
StaticHTMLCollection.prototype = language_1.create(HTMLCollection.prototype, {
    constructor: {
        writable: true,
        configurable: true,
        value: StaticHTMLCollection,
    },
    item: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(index) {
            return this[index];
        },
    },
    length: {
        enumerable: true,
        configurable: true,
        get() {
            return fields_1.getInternalField(this, Items).length;
        },
    },
    // https://dom.spec.whatwg.org/#dom-htmlcollection-nameditem-key
    namedItem: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(name) {
            if (isValidHTMLCollectionName(name) && this[name]) {
                return this[name];
            }
            const items = fields_1.getInternalField(this, Items);
            // Note: loop in reverse so that the first named item matches the named property
            for (let len = items.length - 1; len >= 0; len -= 1) {
                const item = items[len];
                const nodeName = getNodeHTMLCollectionName(item);
                if (nodeName === name) {
                    return item;
                }
            }
            return null;
        },
    },
    // Iterator protocol
    forEach: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(cb, thisArg) {
            language_1.forEach.call(fields_1.getInternalField(this, Items), cb, thisArg);
        },
    },
    entries: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            return language_1.ArrayMap.call(fields_1.getInternalField(this, Items), (v, i) => [i, v]);
        },
    },
    keys: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            return language_1.ArrayMap.call(fields_1.getInternalField(this, Items), (v, i) => i);
        },
    },
    values: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            return fields_1.getInternalField(this, Items);
        },
    },
    [Symbol.iterator]: {
        writable: true,
        configurable: true,
        value() {
            let nextIndex = 0;
            return {
                next: () => {
                    const items = fields_1.getInternalField(this, Items);
                    return nextIndex < items.length
                        ? {
                            value: items[nextIndex++],
                            done: false,
                        }
                        : {
                            done: true,
                        };
                },
            };
        },
    },
    [Symbol.toStringTag]: {
        configurable: true,
        get() {
            return 'HTMLCollection';
        },
    },
    // IE11 doesn't support Symbol.toStringTag, in which case we
    // provide the regular toString method.
    toString: {
        writable: true,
        configurable: true,
        value() {
            return '[object HTMLCollection]';
        },
    },
});
// prototype inheritance dance
language_1.setPrototypeOf(StaticHTMLCollection, HTMLCollection);
function createStaticHTMLCollection(items) {
    const collection = language_1.create(StaticHTMLCollection.prototype);
    fields_1.setInternalField(collection, Items, items);
    // setting static indexes
    language_1.forEach.call(items, (item, index) => {
        language_1.defineProperty(collection, index, {
            value: item,
            enumerable: true,
            configurable: true,
        });
    });
    return collection;
}
exports.createStaticHTMLCollection = createStaticHTMLCollection;
//# sourceMappingURL=static-html-collection.js.map