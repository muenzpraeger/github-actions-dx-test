/* proxy-compat-disable */
'use strict';

const { freeze, seal, keys, create, assign, defineProperty, getPrototypeOf, setPrototypeOf, getOwnPropertyDescriptor, getOwnPropertyNames, defineProperties, getOwnPropertySymbols, hasOwnProperty, preventExtensions, isExtensible, } = Object;
const { concat: ArrayConcat, filter: ArrayFilter, find: ArrayFind, slice: ArraySlice, splice: ArraySplice, unshift: ArrayUnshift, indexOf: ArrayIndexOf, push: ArrayPush, map: ArrayMap, join: ArrayJoin, forEach, reduce: ArrayReduce, reverse: ArrayReverse, } = Array.prototype;
const { replace: StringReplace, toLowerCase: StringToLowerCase, indexOf: StringIndexOf, charCodeAt: StringCharCodeAt, slice: StringSlice, split: StringSplit, } = String.prototype;
function isUndefined(obj) {
    return obj === undefined;
}
function isNull(obj) {
    return obj === null;
}
function isTrue(obj) {
    return obj === true;
}
function isFalse(obj) {
    return obj === false;
}
function isFunction(obj) {
    return typeof obj === 'function';
}
const OtS = {}.toString;
function toString(obj) {
    if (obj && obj.toString) {
        return obj.toString();
    }
    else if (typeof obj === 'object') {
        return OtS.call(obj);
    }
    else {
        return obj + '';
    }
}
function getPropertyDescriptor(o, p) {
    do {
        const d = getOwnPropertyDescriptor(o, p);
        if (!isUndefined(d)) {
            return d;
        }
        o = getPrototypeOf(o);
    } while (o !== null);
}

const DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;
const elementFromPoint = hasOwnProperty.call(Document.prototype, 'elementFromPoint')
    ? Document.prototype.elementFromPoint
    : Document.prototype.msElementFromPoint;
const defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, 'defaultView').get;
const { createComment, querySelectorAll, getElementById, getElementsByClassName, getElementsByTagName, getElementsByTagNameNS, } = Document.prototype;
const { getElementsByName } = HTMLDocument.prototype;

const { DOCUMENT_POSITION_CONTAINED_BY, DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_PRECEDING, DOCUMENT_POSITION_FOLLOWING, DOCUMENT_FRAGMENT_NODE, } = Node;
const { appendChild, cloneNode, compareDocumentPosition, insertBefore, removeChild, replaceChild, } = Node.prototype;
const parentNodeGetter = getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;
const ownerDocumentGetter = getOwnPropertyDescriptor(Node.prototype, 'ownerDocument').get;
const parentElementGetter = hasOwnProperty.call(Node.prototype, 'parentElement')
    ? getOwnPropertyDescriptor(Node.prototype, 'parentElement').get
    : getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get;
const textContextSetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').set;
const childNodesGetter = hasOwnProperty.call(Node.prototype, 'childNodes')
    ? getOwnPropertyDescriptor(Node.prototype, 'childNodes').get
    : getOwnPropertyDescriptor(HTMLElement.prototype, 'childNodes').get;
const isConnected = hasOwnProperty.call(Node.prototype, 'isConnected')
    ? getOwnPropertyDescriptor(Node.prototype, 'isConnected').get
    : function () {
        const doc = ownerDocumentGetter.call(this);
        return (
        doc === null ||
            (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0);
    };

const { hasAttribute, getAttribute, setAttribute, removeAttribute, querySelectorAll: querySelectorAll$1, getBoundingClientRect, getElementsByTagName: getElementsByTagName$1, getElementsByTagNameNS: getElementsByTagNameNS$1, } = Element.prototype;
const { addEventListener, removeEventListener } = Element.prototype;
const innerHTMLSetter = hasOwnProperty.call(Element.prototype, 'innerHTML')
    ? getOwnPropertyDescriptor(Element.prototype, 'innerHTML').set
    : getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML').set;
const outerHTMLSetter = hasOwnProperty.call(Element.prototype, 'outerHTML')
    ? getOwnPropertyDescriptor(Element.prototype, 'outerHTML').set
    : getOwnPropertyDescriptor(HTMLElement.prototype, 'outerHTML').set;
const tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;
const tabIndexGetter = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex').get;
const matches = hasOwnProperty.call(Element.prototype, 'matches')
    ? Element.prototype.matches
    : Element.prototype.msMatchesSelector;
const childrenGetter = hasOwnProperty.call(Element.prototype, 'children')
    ? getOwnPropertyDescriptor(Element.prototype, 'children').get
    : getOwnPropertyDescriptor(HTMLElement.prototype, 'children').get;
const { getElementsByClassName: getElementsByClassName$1 } = HTMLElement.prototype;

const ShadowRootHostGetter = typeof window.ShadowRoot !== 'undefined'
    ? getOwnPropertyDescriptor(window.ShadowRoot.prototype, 'host').get
    : () => {
        throw new Error('Internal Error: Missing ShadowRoot');
    };
const dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent;
const isNativeShadowRootAvailable = typeof window.ShadowRoot !== 'undefined';
const eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;
const eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;
const focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;

function isLWC(element) {
    return element instanceof Element && tagNameGetter.call(element).indexOf('-') !== -1;
}
function isShadowRoot(elmOrShadow) {
    return !(elmOrShadow instanceof Element) && 'host' in elmOrShadow;
}
function getFormattedComponentStack(elm) {
    const componentStack = [];
    const indentationChar = '\t';
    let indentation = '';
    let currentElement = elm;
    do {
        if (isLWC(currentElement)) {
            ArrayPush.call(componentStack, `${indentation}<${StringToLowerCase.call(tagNameGetter.call(currentElement))}>`);
            indentation = indentation + indentationChar;
        }
        if (isShadowRoot(currentElement)) {
            currentElement = ShadowRootHostGetter.call(currentElement);
        }
        else {
            currentElement = parentNodeGetter.call(currentElement);
        }
    } while (!isNull(currentElement));
    return ArrayJoin.call(componentStack, '\n');
}
const assert = {
    invariant(value, msg) {
        if (!value) {
            throw new Error(`Invariant Violation: ${msg}`);
        }
    },
    isTrue(value, msg) {
        if (!value) {
            throw new Error(`Assert Violation: ${msg}`);
        }
    },
    isFalse(value, msg) {
        if (value) {
            throw new Error(`Assert Violation: ${msg}`);
        }
    },
    fail(msg) {
        throw new Error(msg);
    },
    logError(message, elm) {
        let msg = `[LWC error]: ${message}`;
        if (elm) {
            msg = `${msg}\n${getFormattedComponentStack(elm)}`;
        }
        if (process.env.NODE_ENV === 'test') {
            console.error(msg);
            return;
        }
        try {
            throw new Error(msg);
        }
        catch (e) {
            console.error(e);
        }
    },
};

function getOwnerDocument(node) {
    const doc = ownerDocumentGetter.call(node);
    return doc === null ? node : doc;
}
function getOwnerWindow(node) {
    const doc = getOwnerDocument(node);
    const win = defaultViewGetter.call(doc);
    if (win === null) {
        throw new TypeError();
    }
    return win;
}

function pathComposer(startNode, composed) {
    const composedPath = [];
    let current = startNode;
    const startRoot = startNode instanceof Window ? startNode : patchedGetRootNode$1.call(startNode);
    while (current) {
        composedPath.push(current);
        if (current.assignedSlot) {
            current = current.assignedSlot;
        }
        else if (current.nodeType === DOCUMENT_FRAGMENT_NODE &&
            current.host &&
            (composed || current !== startRoot)) {
            current = current.host;
        }
        else {
            current = current.parentNode;
        }
    }
    let doc;
    if (startNode instanceof Window) {
        doc = startNode.document;
    }
    else {
        doc = getOwnerDocument(startNode);
    }
    if (composedPath[composedPath.length - 1] === doc) {
        composedPath.push(window);
    }
    return composedPath;
}

function retarget(refNode, path) {
    if (isNull(refNode)) {
        return null;
    }
    const refNodePath = pathComposer(refNode, true);
    const p$ = path;
    for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
        ancestor = p$[i];
        root = ancestor instanceof Window ? ancestor : patchedGetRootNode$1.call(ancestor);
        if (root !== lastRoot) {
            rootIdx = refNodePath.indexOf(root);
            lastRoot = root;
        }
        if (!(root instanceof SyntheticShadowRoot) || rootIdx > -1) {
            return ancestor;
        }
    }
    return null;
}

const { addEventListener: windowAddEventListener, removeEventListener: windowRemoveEventListener, } = window;

function doesEventNeedsPatch(e) {
    const originalTarget = eventTargetGetter.call(e);
    return originalTarget instanceof Node && isNodeShadowed(originalTarget);
}
function getEventListenerWrapper(fnOrObj) {
    let wrapperFn = null;
    try {
        wrapperFn = fnOrObj.$$lwcEventWrapper$$;
        if (!wrapperFn) {
            const isHandlerFunction = typeof fnOrObj === 'function';
            wrapperFn = fnOrObj.$$lwcEventWrapper$$ = function (e) {
                if (doesEventNeedsPatch(e)) {
                    patchEvent(e);
                }
                return isHandlerFunction
                    ? fnOrObj.call(this, e)
                    : fnOrObj.handleEvent && fnOrObj.handleEvent(e);
            };
        }
    }
    catch (e) {
    }
    return wrapperFn;
}
function windowAddEventListener$1(type, fnOrObj, optionsOrCapture) {
    const handlerType = typeof fnOrObj;
    if (handlerType !== 'function' && handlerType !== 'object') {
        return;
    }
    if (handlerType === 'object' &&
        (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
        return;
    }
    const wrapperFn = getEventListenerWrapper(fnOrObj);
    windowAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
}
function windowRemoveEventListener$1(type, fnOrObj, optionsOrCapture) {
    const wrapperFn = getEventListenerWrapper(fnOrObj);
    windowRemoveEventListener.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);
}
function addEventListener$1(type, fnOrObj, optionsOrCapture) {
    const handlerType = typeof fnOrObj;
    if (handlerType !== 'function' && handlerType !== 'object') {
        return;
    }
    if (handlerType === 'object' &&
        (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
        return;
    }
    const wrapperFn = getEventListenerWrapper(fnOrObj);
    addEventListener.call(this, type, wrapperFn, optionsOrCapture);
}
function removeEventListener$1(type, fnOrObj, optionsOrCapture) {
    const wrapperFn = getEventListenerWrapper(fnOrObj);
    removeEventListener.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);
}
function windowPatchListeners() {
    window.addEventListener = windowAddEventListener$1;
    window.removeEventListener = windowRemoveEventListener$1;
}
function nodePatchListeners() {
    Node.prototype.addEventListener = addEventListener$1;
    Node.prototype.removeEventListener = removeEventListener$1;
}
function apply() {
    windowPatchListeners();
    nodePatchListeners();
}

{
    apply();
}

const { addEventListener: addEventListener$2, removeEventListener: removeEventListener$2 } = Node.prototype;
var EventListenerContext;
(function (EventListenerContext) {
    EventListenerContext[EventListenerContext["CUSTOM_ELEMENT_LISTENER"] = 1] = "CUSTOM_ELEMENT_LISTENER";
    EventListenerContext[EventListenerContext["SHADOW_ROOT_LISTENER"] = 2] = "SHADOW_ROOT_LISTENER";
})(EventListenerContext || (EventListenerContext = {}));
const eventToContextMap = new WeakMap();
function isChildNode(root, node) {
    return !!(compareDocumentPosition.call(root, node) & DOCUMENT_POSITION_CONTAINED_BY);
}
const GET_ROOT_NODE_CONFIG_FALSE = { composed: false };
function getRootNodeHost(node, options) {
    let rootNode = patchedGetRootNode$1.call(node, options);
    if ('mode' in rootNode && 'delegatesFocus' in rootNode) {
        rootNode = getHost(rootNode);
    }
    return rootNode;
}
function targetGetter() {
    const originalCurrentTarget = eventCurrentTargetGetter.call(this);
    const originalTarget = eventTargetGetter.call(this);
    const composedPath = pathComposer(originalTarget, this.composed);
    const doc = getOwnerDocument(originalTarget);
    if (!(originalCurrentTarget instanceof Node)) {
        if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
            return originalTarget;
        }
        return retarget(doc, composedPath);
    }
    else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
        if (isUndefined(getNodeOwnerKey(originalTarget))) {
            return originalTarget;
        }
        return retarget(doc, composedPath);
    }
    const eventContext = eventToContextMap.get(this);
    const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER
        ? getShadowRoot(originalCurrentTarget)
        : originalCurrentTarget;
    return retarget(currentTarget, composedPath);
}
function composedPathValue() {
    const originalTarget = eventTargetGetter.call(this);
    return pathComposer(originalTarget, this.composed);
}
function patchEvent(event) {
    if (eventToContextMap.has(event)) {
        return;
    }
    defineProperties(event, {
        target: {
            get: targetGetter,
            enumerable: true,
            configurable: true,
        },
        composedPath: {
            value: composedPathValue,
            writable: true,
            enumerable: true,
            configurable: true,
        },
        srcElement: {
            get: targetGetter,
            enumerable: true,
            configurable: true,
        },
        path: {
            get: composedPathValue,
            enumerable: true,
            configurable: true,
        },
    });
    const originalRelatedTargetDescriptor = getPropertyDescriptor(event, 'relatedTarget');
    if (!isUndefined(originalRelatedTargetDescriptor)) {
        const relatedTargetGetter = originalRelatedTargetDescriptor.get;
        defineProperty(event, 'relatedTarget', {
            get() {
                const eventContext = eventToContextMap.get(this);
                const originalCurrentTarget = eventCurrentTargetGetter.call(this);
                const relatedTarget = relatedTargetGetter.call(this);
                if (isNull(relatedTarget)) {
                    return null;
                }
                const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER
                    ? getShadowRoot(originalCurrentTarget)
                    : originalCurrentTarget;
                return retarget(currentTarget, pathComposer(relatedTarget, true));
            },
            enumerable: true,
            configurable: true,
        });
    }
    eventToContextMap.set(event, 0);
}
const customElementToWrappedListeners = new WeakMap();
function getEventMap(elm) {
    let listenerInfo = customElementToWrappedListeners.get(elm);
    if (isUndefined(listenerInfo)) {
        listenerInfo = create(null);
        customElementToWrappedListeners.set(elm, listenerInfo);
    }
    return listenerInfo;
}
const shadowRootEventListenerMap = new WeakMap();
function getWrappedShadowRootListener(sr, listener) {
    if (!isFunction(listener)) {
        throw new TypeError();
    }
    let shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);
    if (isUndefined(shadowRootWrappedListener)) {
        shadowRootWrappedListener = function (event) {
            const { composed } = event;
            const target = eventTargetGetter.call(event);
            const currentTarget = eventCurrentTargetGetter.call(event);
            if (target !== currentTarget) {
                const rootNode = getRootNodeHost(target , {
                    composed,
                });
                if (isChildNode(rootNode, currentTarget) ||
                    (composed === false && rootNode === currentTarget)) {
                    listener.call(sr, event);
                }
            }
        };
        shadowRootWrappedListener.placement = EventListenerContext.SHADOW_ROOT_LISTENER;
        if (process.env.NODE_ENV !== 'production') {
            shadowRootWrappedListener.original = listener;
        }
        shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
    }
    return shadowRootWrappedListener;
}
const customElementEventListenerMap = new WeakMap();
function getWrappedCustomElementListener(elm, listener) {
    if (!isFunction(listener)) {
        throw new TypeError();
    }
    let customElementWrappedListener = customElementEventListenerMap.get(listener);
    if (isUndefined(customElementWrappedListener)) {
        customElementWrappedListener = function (event) {
            if (isValidEventForCustomElement(event)) {
                listener.call(elm, event);
            }
        };
        customElementWrappedListener.placement = EventListenerContext.CUSTOM_ELEMENT_LISTENER;
        if (process.env.NODE_ENV !== 'production') {
            customElementWrappedListener.original = listener;
        }
        customElementEventListenerMap.set(listener, customElementWrappedListener);
    }
    return customElementWrappedListener;
}
function domListener(evt) {
    let immediatePropagationStopped = false;
    let propagationStopped = false;
    const { type, stopImmediatePropagation, stopPropagation } = evt;
    const currentTarget = eventCurrentTargetGetter.call(evt);
    const listenerMap = getEventMap(currentTarget);
    const listeners = listenerMap[type];
    defineProperty(evt, 'stopImmediatePropagation', {
        value() {
            immediatePropagationStopped = true;
            stopImmediatePropagation.call(evt);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(evt, 'stopPropagation', {
        value() {
            propagationStopped = true;
            stopPropagation.call(evt);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    const bookkeeping = ArraySlice.call(listeners);
    function invokeListenersByPlacement(placement) {
        forEach.call(bookkeeping, (listener) => {
            if (isFalse(immediatePropagationStopped) && listener.placement === placement) {
                if (ArrayIndexOf.call(listeners, listener) !== -1) {
                    listener.call(undefined, evt);
                }
            }
        });
    }
    eventToContextMap.set(evt, EventListenerContext.SHADOW_ROOT_LISTENER);
    invokeListenersByPlacement(EventListenerContext.SHADOW_ROOT_LISTENER);
    if (isFalse(immediatePropagationStopped) && isFalse(propagationStopped)) {
        eventToContextMap.set(evt, EventListenerContext.CUSTOM_ELEMENT_LISTENER);
        invokeListenersByPlacement(EventListenerContext.CUSTOM_ELEMENT_LISTENER);
    }
    eventToContextMap.set(evt, 0);
}
function attachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let cmpEventHandlers = listenerMap[type];
    if (isUndefined(cmpEventHandlers)) {
        cmpEventHandlers = listenerMap[type] = [];
    }
    if (cmpEventHandlers.length === 0) {
        addEventListener$2.call(elm, type, domListener);
    }
    ArrayPush.call(cmpEventHandlers, wrappedListener);
}
function detachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let p;
    let listeners;
    if (!isUndefined((listeners = listenerMap[type])) &&
        (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
        ArraySplice.call(listeners, p, 1);
        if (listeners.length === 0) {
            removeEventListener$2.call(elm, type, domListener);
        }
    }
}
function isValidEventForCustomElement(event) {
    const target = eventTargetGetter.call(event);
    const currentTarget = eventCurrentTargetGetter.call(event);
    const { composed } = event;
    return (
    composed === true ||
        target === currentTarget ||
        isChildNode(getRootNodeHost(target , GET_ROOT_NODE_CONFIG_FALSE), currentTarget));
}
function addCustomElementEventListener(elm, type, listener, options) {
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(isFunction(listener), `Invalid second argument for this.addEventListener() in ${toString(elm)} for event "${type}". Expected an EventListener but received ${listener}.`);
        if (!isUndefined(options)) {
            assert.logError('The `addEventListener` method in `LightningElement` does not support any options.', elm);
        }
    }
    const wrappedListener = getWrappedCustomElementListener(elm, listener);
    attachDOMListener(elm, type, wrappedListener);
}
function removeCustomElementEventListener(elm, type, listener, _options) {
    const wrappedListener = getWrappedCustomElementListener(elm, listener);
    detachDOMListener(elm, type, wrappedListener);
}
function addShadowRootEventListener(sr, type, listener, options) {
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(isFunction(listener), `Invalid second argument for this.template.addEventListener() in ${toString(sr)} for event "${type}". Expected an EventListener but received ${listener}.`);
        if (!isUndefined(options)) {
            assert.logError('The `addEventListener` method in `LightningElement` does not support any options.', getHost(sr));
        }
    }
    const elm = getHost(sr);
    const wrappedListener = getWrappedShadowRootListener(sr, listener);
    attachDOMListener(elm, type, wrappedListener);
}
function removeShadowRootEventListener(sr, type, listener, _options) {
    const elm = getHost(sr);
    const wrappedListener = getWrappedShadowRootListener(sr, listener);
    detachDOMListener(elm, type, wrappedListener);
}

const hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
function createFieldName(key) {
    return hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${key}$$`;
}
function setInternalField(o, fieldName, value) {
    defineProperty(o, fieldName, {
        value,
    });
}
function getInternalField(o, fieldName) {
    return o[fieldName];
}

function getTextContent(node) {
    switch (node.nodeType) {
        case Node.ELEMENT_NODE: {
            const childNodes = getFilteredChildNodes(node);
            let content = '';
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                content += getTextContent(childNodes[i]);
            }
            return content;
        }
        default:
            return node.nodeValue;
    }
}

const Items = createFieldName('items');
function StaticNodeList() {
    throw new TypeError('Illegal constructor');
}
StaticNodeList.prototype = create(NodeList.prototype, {
    constructor: {
        writable: true,
        configurable: true,
        value: StaticNodeList,
    },
    item: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(index) {
            return this[index];
        },
    },
    length: {
        enumerable: true,
        configurable: true,
        get() {
            return getInternalField(this, Items).length;
        },
    },
    forEach: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(cb, thisArg) {
            forEach.call(getInternalField(this, Items), cb, thisArg);
        },
    },
    entries: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            return ArrayMap.call(getInternalField(this, Items), (v, i) => [i, v]);
        },
    },
    keys: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            return ArrayMap.call(getInternalField(this, Items), (v, i) => i);
        },
    },
    values: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            return getInternalField(this, Items);
        },
    },
    [Symbol.iterator]: {
        writable: true,
        configurable: true,
        value() {
            let nextIndex = 0;
            return {
                next: () => {
                    const items = getInternalField(this, Items);
                    return nextIndex < items.length
                        ? {
                            value: items[nextIndex++],
                            done: false,
                        }
                        : {
                            done: true,
                        };
                },
            };
        },
    },
    [Symbol.toStringTag]: {
        configurable: true,
        get() {
            return 'NodeList';
        },
    },
    toString: {
        writable: true,
        configurable: true,
        value() {
            return '[object NodeList]';
        },
    },
});
setPrototypeOf(StaticNodeList, NodeList);
function createStaticNodeList(items) {
    const nodeList = create(StaticNodeList.prototype);
    setInternalField(nodeList, Items, items);
    forEach.call(items, (item, index) => {
        defineProperty(nodeList, index, {
            value: item,
            enumerable: true,
            configurable: true,
        });
    });
    return nodeList;
}

const Items$1 = createFieldName('items');
function isValidHTMLCollectionName(name) {
    return name !== 'length' && isNaN(name);
}
function getNodeHTMLCollectionName(node) {
    return node.getAttribute('id') || node.getAttribute('name');
}
function StaticHTMLCollection() {
    throw new TypeError('Illegal constructor');
}
StaticHTMLCollection.prototype = create(HTMLCollection.prototype, {
    constructor: {
        writable: true,
        configurable: true,
        value: StaticHTMLCollection,
    },
    item: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(index) {
            return this[index];
        },
    },
    length: {
        enumerable: true,
        configurable: true,
        get() {
            return getInternalField(this, Items$1).length;
        },
    },
    namedItem: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(name) {
            if (isValidHTMLCollectionName(name) && this[name]) {
                return this[name];
            }
            const items = getInternalField(this, Items$1);
            for (let len = items.length - 1; len >= 0; len -= 1) {
                const item = items[len];
                const nodeName = getNodeHTMLCollectionName(item);
                if (nodeName === name) {
                    return item;
                }
            }
            return null;
        },
    },
    forEach: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(cb, thisArg) {
            forEach.call(getInternalField(this, Items$1), cb, thisArg);
        },
    },
    entries: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            return ArrayMap.call(getInternalField(this, Items$1), (v, i) => [i, v]);
        },
    },
    keys: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            return ArrayMap.call(getInternalField(this, Items$1), (v, i) => i);
        },
    },
    values: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            return getInternalField(this, Items$1);
        },
    },
    [Symbol.iterator]: {
        writable: true,
        configurable: true,
        value() {
            let nextIndex = 0;
            return {
                next: () => {
                    const items = getInternalField(this, Items$1);
                    return nextIndex < items.length
                        ? {
                            value: items[nextIndex++],
                            done: false,
                        }
                        : {
                            done: true,
                        };
                },
            };
        },
    },
    [Symbol.toStringTag]: {
        configurable: true,
        get() {
            return 'HTMLCollection';
        },
    },
    toString: {
        writable: true,
        configurable: true,
        value() {
            return '[object HTMLCollection]';
        },
    },
});
setPrototypeOf(StaticHTMLCollection, HTMLCollection);
function createStaticHTMLCollection(items) {
    const collection = create(StaticHTMLCollection.prototype);
    setInternalField(collection, Items$1, items);
    forEach.call(items, (item, index) => {
        defineProperty(collection, index, {
            value: item,
            enumerable: true,
            configurable: true,
        });
    });
    return collection;
}

function getInnerHTML(node) {
    let s = '';
    const childNodes = getFilteredChildNodes(node);
    for (let i = 0, len = childNodes.length; i < len; i += 1) {
        s += getOuterHTML(childNodes[i]);
    }
    return s;
}

const escapeAttrRegExp = /[&\u00A0"]/g;
const escapeDataRegExp = /[&\u00A0<>]/g;
const { replace, toLowerCase } = String.prototype;
function escapeReplace(c) {
    switch (c) {
        case '&':
            return '&amp;';
        case '<':
            return '&lt;';
        case '>':
            return '&gt;';
        case '"':
            return '&quot;';
        case '\u00A0':
            return '&nbsp;';
        default:
            return '';
    }
}
function escapeAttr(s) {
    return replace.call(s, escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
    return replace.call(s, escapeDataRegExp, escapeReplace);
}
const voidElements = new Set([
    'AREA',
    'BASE',
    'BR',
    'COL',
    'COMMAND',
    'EMBED',
    'HR',
    'IMG',
    'INPUT',
    'KEYGEN',
    'LINK',
    'META',
    'PARAM',
    'SOURCE',
    'TRACK',
    'WBR',
]);
const plaintextParents = new Set([
    'STYLE',
    'SCRIPT',
    'XMP',
    'IFRAME',
    'NOEMBED',
    'NOFRAMES',
    'PLAINTEXT',
    'NOSCRIPT',
]);
function getOuterHTML(node) {
    switch (node.nodeType) {
        case Node.ELEMENT_NODE: {
            const { attributes: attrs } = node;
            const tagName = tagNameGetter.call(node);
            let s = '<' + toLowerCase.call(tagName);
            for (let i = 0, attr; (attr = attrs[i]); i++) {
                s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
            }
            s += '>';
            if (voidElements.has(tagName)) {
                return s;
            }
            return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';
        }
        case Node.TEXT_NODE: {
            const { data, parentNode } = node;
            if (parentNode instanceof Element &&
                plaintextParents.has(tagNameGetter.call(parentNode))) {
                return data;
            }
            return escapeData(data);
        }
        case Node.COMMENT_NODE: {
            return '<!--' + node.data + '-->';
        }
        default: {
            throw new Error();
        }
    }
}

const ShadowRootResolverKey = '$shadowResolver$';
const InternalSlot = createFieldName('shadowRecord');
const { createDocumentFragment } = document;
function getInternalSlot(root) {
    const record = getInternalField(root, InternalSlot);
    if (isUndefined(record)) {
        throw new TypeError();
    }
    return record;
}
const ShadowResolverPrivateKey = '$$ShadowResolverKey$$';
defineProperty(Node.prototype, ShadowRootResolverKey, {
    set(fn) {
        this[ShadowResolverPrivateKey] = fn;
        setNodeOwnerKey(this, fn.nodeKey);
    },
    get() {
        return this[ShadowResolverPrivateKey];
    },
    configurable: true,
    enumerable: true,
});
function getShadowRootResolver(node) {
    return node[ShadowRootResolverKey];
}
function setShadowRootResolver(node, fn) {
    node[ShadowRootResolverKey] = fn;
}
function isDelegatingFocus(host) {
    return getInternalSlot(host).delegatesFocus;
}
function getHost(root) {
    return getInternalSlot(root).host;
}
function getShadowRoot(elm) {
    return getInternalSlot(elm).shadowRoot;
}
function hasSyntheticShadow(elm) {
    return !isUndefined(getInternalField(elm, InternalSlot));
}
let uid = 0;
function attachShadow(elm, options) {
    if (!isUndefined(getInternalField(elm, InternalSlot))) {
        throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);
    }
    const { mode, delegatesFocus } = options;
    const doc = getOwnerDocument(elm);
    const sr = createDocumentFragment.call(doc);
    const record = {
        mode,
        delegatesFocus: !!delegatesFocus,
        host: elm,
        shadowRoot: sr,
    };
    setInternalField(sr, InternalSlot, record);
    setInternalField(elm, InternalSlot, record);
    const shadowResolver = () => sr;
    const x = (shadowResolver.nodeKey = uid++);
    setNodeKey(elm, x);
    setShadowRootResolver(sr, shadowResolver);
    setPrototypeOf(sr, SyntheticShadowRoot.prototype);
    return sr;
}
const SyntheticShadowRootDescriptors = {
    constructor: {
        writable: true,
        configurable: true,
        value: SyntheticShadowRoot,
    },
    toString: {
        writable: true,
        configurable: true,
        value() {
            return `[object ShadowRoot]`;
        },
    },
};
const ShadowRootDescriptors = {
    activeElement: {
        enumerable: true,
        configurable: true,
        get() {
            const host = getHost(this);
            const doc = getOwnerDocument(host);
            const activeElement = DocumentPrototypeActiveElement.call(doc);
            if (isNull(activeElement)) {
                return activeElement;
            }
            if ((compareDocumentPosition.call(host, activeElement) &
                DOCUMENT_POSITION_CONTAINED_BY) ===
                0) {
                return null;
            }
            let node = activeElement;
            while (!isNodeOwnedBy(host, node)) {
                node = parentElementGetter.call(node);
            }
            if (isSlotElement(node)) {
                return null;
            }
            return node;
        },
    },
    delegatesFocus: {
        configurable: true,
        get() {
            return getInternalSlot(this).delegatesFocus;
        },
    },
    elementFromPoint: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(left, top) {
            const host = getHost(this);
            const doc = getOwnerDocument(host);
            const element = elementFromPoint.call(doc, left, top);
            if (isNull(element)) {
                return element;
            }
            return retarget(this, pathComposer(element, true));
        },
    },
    elementsFromPoint: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(_left, _top) {
            throw new Error();
        },
    },
    getSelection: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            throw new Error();
        },
    },
    host: {
        enumerable: true,
        configurable: true,
        get() {
            return getHost(this);
        },
    },
    mode: {
        configurable: true,
        get() {
            return getInternalSlot(this).mode;
        },
    },
    styleSheets: {
        enumerable: true,
        configurable: true,
        get() {
            throw new Error();
        },
    },
};
const NodePatchDescriptors = {
    insertBefore: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(newChild, refChild) {
            insertBefore.call(getHost(this), newChild, refChild);
            return newChild;
        },
    },
    removeChild: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(oldChild) {
            removeChild.call(getHost(this), oldChild);
            return oldChild;
        },
    },
    appendChild: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(newChild) {
            appendChild.call(getHost(this), newChild);
            return newChild;
        },
    },
    replaceChild: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(newChild, oldChild) {
            replaceChild.call(getHost(this), newChild, oldChild);
            return oldChild;
        },
    },
    addEventListener: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(type, listener, options) {
            addShadowRootEventListener(this, type, listener, options);
        },
    },
    removeEventListener: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(type, listener, options) {
            removeShadowRootEventListener(this, type, listener, options);
        },
    },
    baseURI: {
        enumerable: true,
        configurable: true,
        get() {
            return getHost(this).baseURI;
        },
    },
    childNodes: {
        enumerable: true,
        configurable: true,
        get() {
            return createStaticNodeList(shadowRootChildNodes(this));
        },
    },
    compareDocumentPosition: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(otherNode) {
            const host = getHost(this);
            if (this === otherNode) {
                return 0;
            }
            else if (this.contains(otherNode)) {
                return 20;
            }
            else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
                return 37;
            }
            else {
                return 35;
            }
        },
    },
    contains: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(otherNode) {
            if (this === otherNode) {
                return true;
            }
            const host = getHost(this);
            return ((compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !==
                0 && isNodeOwnedBy(host, otherNode));
        },
    },
    firstChild: {
        enumerable: true,
        configurable: true,
        get() {
            const childNodes = getInternalChildNodes(this);
            return childNodes[0] || null;
        },
    },
    lastChild: {
        enumerable: true,
        configurable: true,
        get() {
            const childNodes = getInternalChildNodes(this);
            return childNodes[childNodes.length - 1] || null;
        },
    },
    hasChildNodes: {
        writable: true,
        enumerable: true,
        configurable: true,
        value() {
            const childNodes = getInternalChildNodes(this);
            return childNodes.length > 0;
        },
    },
    isConnected: {
        enumerable: true,
        configurable: true,
        get() {
            return isConnected.call(getHost(this));
        },
    },
    nextSibling: {
        enumerable: true,
        configurable: true,
        get() {
            return null;
        },
    },
    previousSibling: {
        enumerable: true,
        configurable: true,
        get() {
            return null;
        },
    },
    nodeName: {
        enumerable: true,
        configurable: true,
        get() {
            return '#document-fragment';
        },
    },
    nodeType: {
        enumerable: true,
        configurable: true,
        get() {
            return 11;
        },
    },
    nodeValue: {
        enumerable: true,
        configurable: true,
        get() {
            return null;
        },
    },
    ownerDocument: {
        enumerable: true,
        configurable: true,
        get() {
            return getHost(this).ownerDocument;
        },
    },
    parentElement: {
        enumerable: true,
        configurable: true,
        get() {
            return null;
        },
    },
    parentNode: {
        enumerable: true,
        configurable: true,
        get() {
            return null;
        },
    },
    textContent: {
        enumerable: true,
        configurable: true,
        get() {
            const childNodes = getInternalChildNodes(this);
            let textContent = '';
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                textContent += getTextContent(childNodes[i]);
            }
            return textContent;
        },
        set(v) {
            const host = getHost(this);
            textContextSetter.call(host, v);
        },
    },
    getRootNode: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(options) {
            return !isUndefined(options) && isTrue(options.composed)
                ? getHost(this).getRootNode(options)
                : this;
        },
    },
};
const ElementPatchDescriptors = {
    innerHTML: {
        enumerable: true,
        configurable: true,
        get() {
            const childNodes = getInternalChildNodes(this);
            let innerHTML = '';
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                innerHTML += getOuterHTML(childNodes[i]);
            }
            return innerHTML;
        },
        set(v) {
            const host = getHost(this);
            innerHTMLSetter.call(host, v);
        },
    },
};
const ParentNodePatchDescriptors = {
    childElementCount: {
        enumerable: true,
        configurable: true,
        get() {
            return this.children.length;
        },
    },
    children: {
        enumerable: true,
        configurable: true,
        get() {
            return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), (elm) => elm instanceof Element));
        },
    },
    firstElementChild: {
        enumerable: true,
        configurable: true,
        get() {
            return this.children[0] || null;
        },
    },
    lastElementChild: {
        enumerable: true,
        configurable: true,
        get() {
            const { children } = this;
            return children.item(children.length - 1) || null;
        },
    },
    querySelector: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(selectors) {
            return shadowRootQuerySelector(this, selectors);
        },
    },
    querySelectorAll: {
        writable: true,
        enumerable: true,
        configurable: true,
        value(selectors) {
            return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
        },
    },
};
assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);
function SyntheticShadowRoot() {
    throw new TypeError('Illegal constructor');
}
SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);
if (isNativeShadowRootAvailable) {
    setPrototypeOf(SyntheticShadowRoot.prototype, window.ShadowRoot.prototype);
}
function getIE11FakeShadowRootPlaceholder(host) {
    const shadowRoot = getShadowRoot(host);
    let c = shadowRoot.$$placeholder$$;
    if (!isUndefined(c)) {
        return c;
    }
    const doc = getOwnerDocument(host);
    c = shadowRoot.$$placeholder$$ = createComment.call(doc, '');
    defineProperties(c, {
        childNodes: {
            get() {
                return shadowRoot.childNodes;
            },
            enumerable: true,
            configurable: true,
        },
        tagName: {
            get() {
                return `#shadow-root (${shadowRoot.mode})`;
            },
            enumerable: true,
            configurable: true,
        },
    });
    return c;
}

let MO = window.MutationObserver;
if (typeof MO === 'undefined') {
    function MutationObserverMock() { }
    MutationObserverMock.prototype = {
        observe() {
            if (process.env.NODE_ENV !== 'production') {
                if (process.env.NODE_ENV !== 'test') {
                    throw new Error(`MutationObserver should not be mocked outside of the jest test environment`);
                }
            }
        },
    };
    MO = window.MutationObserver = MutationObserverMock;
}
const MutationObserver = MO;
const MutationObserverObserve = MutationObserver.prototype.observe;

function collectionFilter(collection, fn) {
    const res = [];
    const length = collection.length;
    for (let i = 0; i < length; i++) {
        const curr = collection[i];
        if (isTrue(fn(curr, i, collection))) {
            ArrayPush.call(res, curr);
        }
    }
    return res;
}
function collectionFind(collection, fn) {
    const length = collection.length;
    for (let i = 0; i < length; i++) {
        const curr = collection[i];
        if (isTrue(fn(curr, i, collection))) {
            return curr;
        }
    }
    return undefined;
}
function collectionSlice(collection, begin, end) {
    end = !isUndefined(end) ? end : collection.length;
    const cloned = [];
    const len = collection.length;
    let start = !isUndefined(begin) ? begin : 0;
    start = start >= 0 ? start : Math.max(0, len + start);
    let upTo = !isUndefined(end) ? Math.min(end, len) : len;
    if (end < 0) {
        upTo = len + end;
    }
    const size = upTo - start;
    if (size > 0) {
        for (let i = 0; i < size; i++) {
            ArrayPush.call(cloned, collection[start + i]);
        }
    }
    return cloned;
}
function collectionIndexOf(collection, searchItem, fromIndex = 0) {
    const len = collection.length;
    let i = Math.min(fromIndex, len);
    if (i < 0) {
        i = Math.max(0, len + i);
    }
    else if (i >= len) {
        return -1;
    }
    for (; i !== len; ++i) {
        if (collection[i] === searchItem) {
            return i;
        }
    }
    return -1;
}

const TabbableElementsQuery = `
    button:not([tabindex="-1"]):not([disabled]),
    [contenteditable]:not([tabindex="-1"]),
    video[controls]:not([tabindex="-1"]),
    audio[controls]:not([tabindex="-1"]),
    [href]:not([tabindex="-1"]),
    input:not([tabindex="-1"]):not([disabled]),
    select:not([tabindex="-1"]):not([disabled]),
    textarea:not([tabindex="-1"]):not([disabled]),
    [tabindex="0"]
`;
const DidAddMouseDownListener = createFieldName('DidAddMouseDownListener');
function isVisible(element) {
    const { width, height } = getBoundingClientRect.call(element);
    const noZeroSize = width > 0 || height > 0;
    return noZeroSize && getComputedStyle(element).visibility !== 'hidden';
}
function isTabbable(element) {
    return matches.call(element, TabbableElementsQuery) && isVisible(element);
}
function getTabbableSegments(host) {
    const doc = getOwnerDocument(host);
    const all = querySelectorAll.call(doc, TabbableElementsQuery);
    const inner = collectionSlice(querySelectorAll$1.call(host, TabbableElementsQuery));
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(getAttribute.call(host, 'tabindex') === '-1' || isDelegatingFocus(host), `The focusin event is only relevant when the tabIndex property is -1 on the host.`);
    }
    const firstChild = inner[0];
    const lastChild = inner[inner.length - 1];
    const hostIndex = collectionIndexOf(all, host);
    const firstChildIndex = hostIndex > -1 ? hostIndex : collectionIndexOf(all, firstChild);
    const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : collectionIndexOf(all, lastChild) + 1;
    const prev = collectionSlice(all, 0, firstChildIndex);
    const next = collectionSlice(all, lastChildIndex);
    return {
        prev,
        inner,
        next,
    };
}
function getActiveElement(host) {
    const doc = getOwnerDocument(host);
    const activeElement = DocumentPrototypeActiveElement.call(doc);
    if (isNull(activeElement)) {
        return activeElement;
    }
    return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !==
        0
        ? activeElement
        : null;
}
function relatedTargetPosition(host, relatedTarget) {
    const pos = compareDocumentPosition.call(host, relatedTarget);
    if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
        return 0;
    }
    else if (pos & DOCUMENT_POSITION_PRECEDING) {
        return 1;
    }
    else if (pos & DOCUMENT_POSITION_FOLLOWING) {
        return 2;
    }
    return -1;
}
function muteEvent(event) {
    event.preventDefault();
    event.stopPropagation();
}
function muteFocusEventsDuringExecution(win, func) {
    windowAddEventListener.call(win, 'focusin', muteEvent, true);
    windowAddEventListener.call(win, 'focusout', muteEvent, true);
    func();
    windowRemoveEventListener.call(win, 'focusin', muteEvent, true);
    windowRemoveEventListener.call(win, 'focusout', muteEvent, true);
}
function focusOnNextOrBlur(segment, target, relatedTarget) {
    const win = getOwnerWindow(relatedTarget);
    const next = getNextTabbable(segment, relatedTarget);
    if (isNull(next)) {
        muteFocusEventsDuringExecution(win, () => {
            target.blur();
        });
    }
    else {
        muteFocusEventsDuringExecution(win, () => {
            next.focus();
        });
    }
}
let letBrowserHandleFocus = false;
function disableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = true;
}
function enableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = false;
}
function skipHostHandler(event) {
    if (letBrowserHandleFocus) {
        enableKeyboardFocusNavigationRoutines();
        return;
    }
    const host = eventCurrentTargetGetter.call(event);
    const target = eventTargetGetter.call(event);
    if (host !== target) {
        return;
    }
    const relatedTarget = focusEventRelatedTargetGetter.call(event);
    if (isNull(relatedTarget)) {
        return;
    }
    const segments = getTabbableSegments(host);
    const position = relatedTargetPosition(host, relatedTarget);
    if (position === 1) {
        const findTabbableElms = isTabbableFrom.bind(null, patchedGetRootNode$1.call(host));
        const first = ArrayFind.call(segments.inner, findTabbableElms);
        if (!isUndefined(first)) {
            const win = getOwnerWindow(first);
            muteFocusEventsDuringExecution(win, () => {
                first.focus();
            });
        }
        else {
            focusOnNextOrBlur(segments.next, target, relatedTarget);
        }
    }
    else if (host === target) {
        focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
}
function skipShadowHandler(event) {
    if (letBrowserHandleFocus) {
        enableKeyboardFocusNavigationRoutines();
        return;
    }
    const relatedTarget = focusEventRelatedTargetGetter.call(event);
    if (isNull(relatedTarget)) {
        return;
    }
    const host = eventCurrentTargetGetter.call(event);
    const segments = getTabbableSegments(host);
    if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
        return;
    }
    const target = eventTargetGetter.call(event);
    const position = relatedTargetPosition(host, relatedTarget);
    if (position === 1) {
        focusOnNextOrBlur(segments.next, target, relatedTarget);
    }
    if (position === 2) {
        focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
}
function isTabbableFrom(fromRoot, toElm) {
    if (!isTabbable(toElm)) {
        return false;
    }
    const ownerDocument = getOwnerDocument(toElm);
    let root = patchedGetRootNode$1.call(toElm);
    while (root !== ownerDocument && root !== fromRoot) {
        const sr = root;
        const host = sr.host;
        if (getAttribute.call(host, 'tabindex') === '-1') {
            return false;
        }
        root = host && patchedGetRootNode$1.call(host);
    }
    return true;
}
function getNextTabbable(tabbables, relatedTarget) {
    const len = tabbables.length;
    if (len > 0) {
        for (let i = 0; i < len; i += 1) {
            const next = tabbables[i];
            if (isTabbableFrom(patchedGetRootNode$1.call(relatedTarget), next)) {
                return next;
            }
        }
    }
    return null;
}
function handleFocus(elm) {
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(isDelegatingFocus(elm), `Invalid attempt to handle focus event for ${toString(elm)}. ${toString(elm)} should have delegates focus true, but is not delegating focus`);
    }
    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocusIn(elm);
    addEventListener.call(elm, 'focusin', skipHostHandler, true);
}
function ignoreFocus(elm) {
    removeEventListener.call(elm, 'focusin', skipHostHandler, true);
}
function bindDocumentMousedownMouseupHandlers(elm) {
    const ownerDocument = getOwnerDocument(elm);
    if (!getInternalField(ownerDocument, DidAddMouseDownListener)) {
        setInternalField(ownerDocument, DidAddMouseDownListener, true);
        addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);
        addEventListener.call(ownerDocument, 'mouseup', () => {
            setTimeout(enableKeyboardFocusNavigationRoutines);
        }, true);
    }
}
function handleFocusIn(elm) {
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(tabIndexGetter.call(elm) === -1, `Invalid attempt to handle focus in  ${toString(elm)}. ${toString(elm)} should have tabIndex -1, but has tabIndex ${tabIndexGetter.call(elm)}`);
    }
    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocus(elm);
    addEventListener.call(elm, 'focusin', skipShadowHandler, true);
}
function ignoreFocusIn(elm) {
    removeEventListener.call(elm, 'focusin', skipShadowHandler, true);
}

const nativeGetRootNode = Node.prototype.getRootNode;
const getDocumentOrRootNode = !isUndefined(nativeGetRootNode)
    ? nativeGetRootNode
    : function () {
        let node = this;
        let nodeParent;
        while (!isNull((nodeParent = parentNodeGetter.call(node)))) {
            node = nodeParent;
        }
        return node;
    };
function getNearestRoot(node) {
    const ownerNode = getNodeOwner(node);
    if (isNull(ownerNode)) {
        return getDocumentOrRootNode.call(node);
    }
    return getShadowRoot(ownerNode);
}
function patchedGetRootNode(options) {
    const composed = isUndefined(options) ? false : !!options.composed;
    return isTrue(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
}
function apply$1() {
    defineProperty(Node.prototype, 'getRootNode', {
        value: patchedGetRootNode,
        enumerable: true,
        configurable: true,
        writable: true,
    });
}

{
    apply$1();
}

function foldSlotElement(slot) {
    let parent = parentElementGetter.call(slot);
    while (!isNull(parent) && isSlotElement(parent)) {
        slot = parent;
        parent = parentElementGetter.call(slot);
    }
    return slot;
}
function isNodeSlotted(host, node) {
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(host instanceof HTMLElement, `isNodeSlotted() should be called with a host as the first argument instead of ${host}`);
        assert.invariant(node instanceof Node, `isNodeSlotted() should be called with a node as the second argument instead of ${node}`);
        assert.isTrue(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS, `isNodeSlotted() should never be called with a node that is not a child node of ${host}`);
    }
    const hostKey = getNodeKey(host);
    let currentElement = node instanceof Element ? node : parentElementGetter.call(node);
    while (!isNull(currentElement) && currentElement !== host) {
        const elmOwnerKey = getNodeNearestOwnerKey(currentElement);
        const parent = parentElementGetter.call(currentElement);
        if (elmOwnerKey === hostKey) {
            return isSlotElement(currentElement);
        }
        else if (parent === host) {
            return false;
        }
        else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
            if (isSlotElement(parent)) {
                currentElement = getNodeOwner(foldSlotElement(parent));
                if (!isNull(currentElement)) {
                    if (currentElement === host) {
                        return true;
                    }
                    else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
                        return true;
                    }
                }
            }
            else {
                return false;
            }
        }
        else {
            currentElement = parent;
        }
    }
    return false;
}
function getAllSlottedMatches(host, nodeList) {
    const filteredAndPatched = [];
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
        const node = nodeList[i];
        if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
            ArrayPush.call(filteredAndPatched, node);
        }
    }
    return filteredAndPatched;
}
function getFirstSlottedMatch(host, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
        const node = nodeList[i];
        if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
            return node;
        }
    }
    return null;
}
function lightDomQuerySelectorAll(elm, selectors) {
    const owner = getNodeOwner(elm);
    if (isNull(owner)) {
        return [];
    }
    const nodeList = querySelectorAll$1.call(elm, selectors);
    if (getNodeKey(elm)) {
        return getAllSlottedMatches(elm, nodeList);
    }
    else {
        return getAllMatches(owner, nodeList);
    }
}
function lightDomQuerySelector(elm, selector) {
    const owner = getNodeOwner(elm);
    if (isNull(owner)) {
        return null;
    }
    const nodeList = querySelectorAll$1.call(elm, selector);
    if (getNodeKey(elm)) {
        return getFirstSlottedMatch(elm, nodeList);
    }
    else {
        return getFirstMatch(owner, nodeList);
    }
}
function PatchedElement(elm) {
    const Ctor = PatchedNode(elm);
    const { addEventListener: superAddEventListener, removeEventListener: superRemoveEventListener, blur: superBlur, focus: superFocus, } = elm;
    return class PatchedHTMLElement extends Ctor {
        querySelector(selector) {
            return lightDomQuerySelector(this, selector);
        }
        querySelectorAll(selectors) {
            return createStaticNodeList(lightDomQuerySelectorAll(this, selectors));
        }
        get innerHTML() {
            const childNodes = getInternalChildNodes(this);
            let innerHTML = '';
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                innerHTML += getOuterHTML(childNodes[i]);
            }
            return innerHTML;
        }
        set innerHTML(value) {
            innerHTMLSetter.call(this, value);
        }
        get outerHTML() {
            return getOuterHTML(this);
        }
        set outerHTML(value) {
            outerHTMLSetter.call(this, value);
        }
        attachShadow(options) {
            return attachShadow(this, options);
        }
        addEventListener(type, listener, options) {
            if (hasSyntheticShadow(this)) {
                addCustomElementEventListener(this, type, listener, options);
            }
            else {
                superAddEventListener.call(this, type, listener, options);
            }
        }
        removeEventListener(type, listener, options) {
            if (hasSyntheticShadow(this)) {
                removeCustomElementEventListener(this, type, listener, options);
            }
            else {
                superRemoveEventListener.call(this, type, listener, options);
            }
        }
        get shadowRoot() {
            if (hasSyntheticShadow(this)) {
                const shadow = getShadowRoot(this);
                if (shadow.mode === 'open') {
                    return shadow;
                }
            }
            return null;
        }
        get tabIndex() {
            if (hasSyntheticShadow(this) &&
                isDelegatingFocus(this) &&
                isFalse(hasAttribute.call(this, 'tabindex'))) {
                return 0;
            }
            const descriptor = getPropertyDescriptor(Ctor.prototype, 'tabIndex');
            return descriptor.get.call(this);
        }
        set tabIndex(value) {
            if (hasSyntheticShadow(this)) {
                const delegatesFocus = isDelegatingFocus(this);
                const prevValue = tabIndexGetter.call(this);
                const prevHasAttr = hasAttribute.call(this, 'tabindex');
                const descriptor = getPropertyDescriptor(Ctor.prototype, 'tabIndex');
                descriptor.set.call(this, value);
                const currValue = tabIndexGetter.call(this);
                const currHasAttr = hasAttribute.call(this, 'tabindex');
                const didValueChange = prevValue !== currValue;
                if (prevHasAttr && (didValueChange || isFalse(currHasAttr))) {
                    if (prevValue === -1) {
                        ignoreFocusIn(this);
                    }
                    if (prevValue === 0 && delegatesFocus) {
                        ignoreFocus(this);
                    }
                }
                if (isFalse(currHasAttr)) {
                    return;
                }
                if (prevHasAttr && currHasAttr && isFalse(didValueChange)) {
                    return;
                }
                if (currValue === -1) {
                    handleFocusIn(this);
                }
                if (currValue === 0 && delegatesFocus) {
                    handleFocus(this);
                }
                return;
            }
            const descriptor = getPropertyDescriptor(Ctor.prototype, 'tabIndex');
            descriptor.set.call(this, value);
        }
        blur() {
            if (hasSyntheticShadow(this) && isDelegatingFocus(this)) {
                const currentActiveElement = getActiveElement(this);
                if (!isNull(currentActiveElement)) {
                    currentActiveElement.blur();
                    return;
                }
            }
            return superBlur.call(this);
        }
        focus() {
            disableKeyboardFocusNavigationRoutines();
            superFocus.call(this);
            enableKeyboardFocusNavigationRoutines();
        }
        get childNodes() {
            if (hasSyntheticShadow(this)) {
                const owner = getNodeOwner(this);
                const childNodes = isNull(owner)
                    ? []
                    : getAllMatches(owner, getFilteredChildNodes(this));
                if (process.env.NODE_ENV !== 'production' &&
                    isFalse(hasNativeSymbolsSupport$1) &&
                    isExternalChildNodeAccessorFlagOn()) {
                    ArrayUnshift.call(childNodes, getIE11FakeShadowRootPlaceholder(this));
                }
                return createStaticNodeList(childNodes);
            }
            return childNodesGetter.call(this);
        }
        get children() {
            if (hasSyntheticShadow(this)) {
                if (process.env.NODE_ENV === 'test') {
                    return childrenGetter.call(this);
                }
                const owner = getNodeOwner(this);
                const childNodes = isNull(owner)
                    ? []
                    : getAllMatches(owner, getFilteredChildNodes(this));
                return createStaticHTMLCollection(ArrayFilter.call(childNodes, (node) => node instanceof Element));
            }
            return childrenGetter.call(this);
        }
    };
}

let observer;
const observerConfig = { childList: true };
const SlotChangeKey = createFieldName('slotchange');
function initSlotObserver() {
    return new MutationObserver(mutations => {
        const slots = [];
        forEach.call(mutations, mutation => {
            if (process.env.NODE_ENV !== 'production') {
                assert.isTrue(mutation.type === 'childList', `Invalid mutation type: ${mutation.type}. This mutation handler for slots should only handle "childList" mutations.`);
            }
            const { target: slot } = mutation;
            if (ArrayIndexOf.call(slots, slot) === -1) {
                ArrayPush.call(slots, slot);
                dispatchEvent.call(slot, new CustomEvent('slotchange'));
            }
        });
    });
}
function getFilteredSlotAssignedNodes(slot) {
    const owner = getNodeOwner(slot);
    if (isNull(owner)) {
        return [];
    }
    const childNodes = collectionSlice(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, (seed, child) => {
        if (!isNodeOwnedBy(owner, child)) {
            ArrayPush.call(seed, child);
        }
        return seed;
    }, []);
}
function getFilteredSlotFlattenNodes(slot) {
    const childNodes = collectionSlice(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, (seed, child) => {
        if (child instanceof Element && isSlotElement(child)) {
            ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
        }
        else {
            ArrayPush.call(seed, child);
        }
        return seed;
    }, []);
}
function PatchedSlotElement(elm) {
    const Ctor = PatchedElement(elm);
    const { addEventListener: superAddEventListener } = elm;
    return class PatchedHTMLSlotElement extends Ctor {
        addEventListener(type, listener, options) {
            if (type === 'slotchange' && !getInternalField(this, SlotChangeKey)) {
                if (process.env.NODE_ENV === 'test') {
                    console.warn('The "slotchange" event is not supported in our jest test environment.');
                }
                setInternalField(this, SlotChangeKey, true);
                if (!observer) {
                    observer = initSlotObserver();
                }
                MutationObserverObserve.call(observer, this, observerConfig);
            }
            superAddEventListener.call(this, type, listener, options);
        }
        assignedElements(options) {
            const flatten = !isUndefined(options) && isTrue(options.flatten);
            const nodes = flatten
                ? getFilteredSlotFlattenNodes(this)
                : getFilteredSlotAssignedNodes(this);
            return ArrayFilter.call(nodes, node => node instanceof Element);
        }
        assignedNodes(options) {
            const flatten = !isUndefined(options) && isTrue(options.flatten);
            return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
        }
        get name() {
            const name = getAttribute.call(this, 'name');
            return isNull(name) ? '' : name;
        }
        get childNodes() {
            const owner = getNodeOwner(this);
            const childNodes = isNull(owner)
                ? []
                : getAllMatches(owner, getFilteredChildNodes(this));
            return createStaticNodeList(childNodes);
        }
        get children() {
            if (process.env.NODE_ENV === 'test') {
                return childrenGetter.call(this);
            }
            const owner = getNodeOwner(this);
            const childNodes = isNull(owner)
                ? []
                : getAllMatches(owner, getFilteredChildNodes(this));
            return createStaticHTMLCollection(ArrayFilter.call(childNodes, (node) => node instanceof Element));
        }
    };
}

const { getRootNode: patchedGetRootNode$1 } = Node.prototype;
function getNodeOwner(node) {
    if (!(node instanceof Node)) {
        return null;
    }
    const ownerKey = getNodeNearestOwnerKey(node);
    if (isUndefined(ownerKey)) {
        return null;
    }
    let nodeOwner = node;
    while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
        nodeOwner = parentNodeGetter.call(nodeOwner);
    }
    if (isNull(nodeOwner)) {
        return null;
    }
    return nodeOwner;
}
function isSlotElement(elm) {
    return tagNameGetter.call(elm) === 'SLOT';
}
function isNodeOwnedBy(owner, node) {
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(owner instanceof HTMLElement, `isNodeOwnedBy() should be called with an element as the first argument instead of ${owner}`);
        assert.invariant(node instanceof Node, `isNodeOwnedBy() should be called with a node as the second argument instead of ${node}`);
        assert.isTrue(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS, `isNodeOwnedBy() should never be called with a node that is not a child node of ${owner}`);
    }
    const ownerKey = getNodeNearestOwnerKey(node);
    return isUndefined(ownerKey) || getNodeKey(owner) === ownerKey;
}
function shadowRootChildNodes(root) {
    const elm = getHost(root);
    return getAllMatches(elm, childNodesGetter.call(elm));
}
function getAllMatches(owner, nodeList) {
    const filteredAndPatched = [];
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
        const node = nodeList[i];
        const isOwned = isNodeOwnedBy(owner, node);
        if (isOwned) {
            ArrayPush.call(filteredAndPatched, node);
        }
    }
    return filteredAndPatched;
}
function getFirstMatch(owner, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
        if (isNodeOwnedBy(owner, nodeList[i])) {
            return nodeList[i];
        }
    }
    return null;
}
function shadowRootQuerySelector(root, selector) {
    const elm = getHost(root);
    const nodeList = querySelectorAll$1.call(elm, selector);
    return getFirstMatch(elm, nodeList);
}
function shadowRootQuerySelectorAll(root, selector) {
    const elm = getHost(root);
    const nodeList = querySelectorAll$1.call(elm, selector);
    return getAllMatches(elm, nodeList);
}
function getFilteredChildNodes(node) {
    let children;
    if (!isUndefined(getNodeKey(node))) {
        const slots = querySelectorAll$1.call(node, 'slot');
        children = ArrayReduce.call(slots, (seed, slot) => {
            if (isNodeOwnedBy(node, slot)) {
                ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
            }
            return seed;
        }, []);
    }
    else {
        children = childNodesGetter.call(node);
    }
    const owner = getNodeOwner(node);
    if (isNull(owner)) {
        return [];
    }
    return ArrayReduce.call(children, (seed, child) => {
        if (isNodeOwnedBy(owner, child)) {
            ArrayPush.call(seed, child);
        }
        return seed;
    }, []);
}

const OwnerKey = '$$OwnerKey$$';
const OwnKey = '$$OwnKey$$';
const hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';
function getNodeOwnerKey(node) {
    return node[OwnerKey];
}
function setNodeOwnerKey(node, value) {
    if (process.env.NODE_ENV !== 'production') {
        defineProperty(node, OwnerKey, {
            value,
            configurable: true,
        });
    }
    else {
        node[OwnerKey] = value;
    }
}
function setNodeKey(node, value) {
    if (process.env.NODE_ENV !== 'production') {
        defineProperty(node, OwnKey, {
            value,
        });
    }
    else {
        node[OwnKey] = value;
    }
}
function getNodeNearestOwnerKey(node) {
    let ownerNode = node;
    let ownerKey;
    while (!isNull(ownerNode)) {
        ownerKey = ownerNode[OwnerKey];
        if (!isUndefined(ownerKey)) {
            return ownerKey;
        }
        ownerNode = parentNodeGetter.call(ownerNode);
    }
}
function getNodeKey(node) {
    return node[OwnKey];
}
function isNodeShadowed(node) {
    return !isUndefined(getNodeNearestOwnerKey(node));
}
function getShadowParent(node, value) {
    const owner = getNodeOwner(node);
    if (value === owner) {
        return getShadowRoot(owner);
    }
    else if (value instanceof Element) {
        if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
            return value;
        }
        else if (!isNull(owner) && isSlotElement(value)) {
            const slotOwner = getNodeOwner(value);
            if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
                return slotOwner;
            }
        }
    }
    return null;
}
function PatchedNode(node) {
    const Ctor = getPrototypeOf(node).constructor;
    class PatchedNodeClass {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        hasChildNodes() {
            return getInternalChildNodes(this).length > 0;
        }
        get firstChild() {
            const childNodes = getInternalChildNodes(this);
            return childNodes[0] || null;
        }
        get lastChild() {
            const childNodes = getInternalChildNodes(this);
            return childNodes[childNodes.length - 1] || null;
        }
        get textContent() {
            return getTextContent(this);
        }
        set textContent(value) {
            textContextSetter.call(this, value);
        }
        get childElementCount() {
            return this.children.length;
        }
        get firstElementChild() {
            return this.children[0] || null;
        }
        get lastElementChild() {
            const { children } = this;
            return children.item(children.length - 1) || null;
        }
        get assignedSlot() {
            const parentNode = parentNodeGetter.call(this);
            if (isNull(parentNode) ||
                !isSlotElement(parentNode) ||
                getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
                return null;
            }
            return parentNode;
        }
        get parentNode() {
            const value = parentNodeGetter.call(this);
            if (isNull(value)) {
                return value;
            }
            return getShadowParent(this, value);
        }
        get parentElement() {
            const value = parentNodeGetter.call(this);
            if (isNull(value)) {
                return null;
            }
            const parentNode = getShadowParent(this, value);
            return parentNode instanceof Element ? parentNode : null;
        }
        compareDocumentPosition(otherNode) {
            if (patchedGetRootNode$1.call(this) === otherNode) {
                return 10;
            }
            else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                return 35;
            }
            return compareDocumentPosition.call(this, otherNode);
        }
        contains(otherNode) {
            if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                return false;
            }
            return ((compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !==
                0);
        }
        cloneNode(deep) {
            const clone = cloneNode.call(this, false);
            if (!deep) {
                return clone;
            }
            const childNodes = getInternalChildNodes(this);
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                clone.appendChild(childNodes[i].cloneNode(true));
            }
            return clone;
        }
    }
    setPrototypeOf(PatchedNodeClass, Ctor);
    setPrototypeOf(PatchedNodeClass.prototype, Ctor.prototype);
    return PatchedNodeClass;
}
let internalChildNodeAccessorFlag = false;
function isExternalChildNodeAccessorFlagOn() {
    return !internalChildNodeAccessorFlag;
}
const getInternalChildNodes = process.env.NODE_ENV !== 'production' && isFalse(hasNativeSymbolsSupport$1)
    ? function (node) {
        internalChildNodeAccessorFlag = true;
        let childNodes;
        let error = null;
        try {
            childNodes = node.childNodes;
        }
        catch (e) {
            error = e;
        }
        finally {
            internalChildNodeAccessorFlag = false;
            if (!isNull(error)) {
                throw error;
            }
        }
        return childNodes;
    }
    : function (node) {
        return node.childNodes;
    };

let skipGlobalPatching;
function isGlobalPatchingSkipped(node) {
    if (isUndefined(skipGlobalPatching)) {
        const ownerDocument = getOwnerDocument(node);
        skipGlobalPatching =
            ownerDocument.body.getAttribute('data-global-patching-bypass') === 'temporary-bypass';
    }
    return isTrue(skipGlobalPatching);
}
function apply$2() {
    function elemFromPoint(left, top) {
        const element = elementFromPoint.call(this, left, top);
        if (isNull(element)) {
            return element;
        }
        return retarget(this, pathComposer(element, true));
    }
    Document.prototype.elementFromPoint = elemFromPoint;
    defineProperty(Document.prototype, 'activeElement', {
        get() {
            let node = DocumentPrototypeActiveElement.call(this);
            if (isNull(node)) {
                return node;
            }
            while (!isUndefined(getNodeOwnerKey(node))) {
                node = parentElementGetter.call(node);
                if (isNull(node)) {
                    return null;
                }
            }
            if (node.tagName === 'HTML') {
                node = this.body;
            }
            return node;
        },
        enumerable: true,
        configurable: true,
    });
    defineProperty(Document.prototype, 'getElementById', {
        value() {
            const elm = getElementById.apply(this, ArraySlice.call(arguments));
            if (isNull(elm)) {
                return null;
            }
            return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(Document.prototype, 'querySelector', {
        value() {
            const elements = querySelectorAll.apply(this, ArraySlice.call(arguments));
            const filtered = collectionFind(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
            return !isUndefined(filtered) ? filtered : null;
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(Document.prototype, 'querySelectorAll', {
        value() {
            const elements = querySelectorAll.apply(this, ArraySlice.call(arguments));
            const filtered = collectionFilter(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
            return createStaticNodeList(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(Document.prototype, 'getElementsByClassName', {
        value() {
            const elements = getElementsByClassName.apply(this, ArraySlice.call(arguments));
            const filtered = collectionFilter(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
            return createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(Document.prototype, 'getElementsByTagName', {
        value() {
            const elements = getElementsByTagName.apply(this, ArraySlice.call(arguments));
            const filtered = collectionFilter(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
            return createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(Document.prototype, 'getElementsByTagNameNS', {
        value() {
            const elements = getElementsByTagNameNS.apply(this, ArraySlice.call(arguments));
            const filtered = collectionFilter(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
            return createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(
    getOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName')
        ? HTMLDocument.prototype
        : Document.prototype, 'getElementsByName', {
        value() {
            const elements = getElementsByName.apply(this, ArraySlice.call(arguments));
            const filtered = collectionFilter(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
            return createStaticNodeList(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
}

{
    apply$2();
}

let skipGlobalPatching$1;
function isGlobalPatchingSkipped$1(node) {
    if (isUndefined(skipGlobalPatching$1)) {
        const ownerDocument = getOwnerDocument(node);
        skipGlobalPatching$1 =
            ownerDocument.body.getAttribute('data-global-patching-bypass') === 'temporary-bypass';
    }
    return isTrue(skipGlobalPatching$1);
}
function apply$3() {
    const HTMLBodyElementPrototype = HTMLBodyElement.prototype;
    defineProperty(HTMLBodyElementPrototype, 'querySelector', {
        value() {
            const elements = querySelectorAll$1.apply(this, ArraySlice.call(arguments));
            const ownerKey = getNodeOwnerKey(this);
            const filtered = collectionFind(elements, elm => getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm));
            return !isUndefined(filtered) ? filtered : null;
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(HTMLBodyElementPrototype, 'querySelectorAll', {
        value() {
            const elements = querySelectorAll$1.apply(this, ArraySlice.call(arguments));
            const ownerKey = getNodeOwnerKey(this);
            const filtered = collectionFilter(elements, elm => getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm));
            return createStaticNodeList(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(HTMLBodyElementPrototype, 'getElementsByClassName', {
        value() {
            const elements = getElementsByClassName$1.apply(this, ArraySlice.call(arguments));
            const ownerKey = getNodeOwnerKey(this);
            const filtered = collectionFilter(elements, elm => getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm));
            return createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(HTMLBodyElementPrototype, 'getElementsByTagName', {
        value() {
            const elements = getElementsByTagName$1.apply(this, ArraySlice.call(arguments));
            const ownerKey = getNodeOwnerKey(this);
            const filtered = collectionFilter(elements, elm => getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm));
            return createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(HTMLBodyElementPrototype, 'getElementsByTagNameNS', {
        value() {
            const elements = getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments));
            const ownerKey = getNodeOwnerKey(this);
            const filtered = collectionFilter(elements, elm => getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm));
            return createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
}

{
    apply$3();
}

function apply$4() {
    Object.defineProperty(window, 'ShadowRoot', {
        value: SyntheticShadowRoot,
        configurable: true,
        writable: true,
    });
}

{
    apply$4();
}

const composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');
function detect() {
    if (!composedDescriptor) {
        return false;
    }
    let clickEvent = new Event('click');
    const button = document.createElement('button');
    button.addEventListener('click', event => (clickEvent = event));
    button.click();
    return !composedDescriptor.get.call(clickEvent);
}

const originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'click');
function handleClick(event) {
    Object.defineProperty(event, 'composed', {
        configurable: true,
        enumerable: true,
        get() {
            return true;
        },
    });
}
function apply$5() {
    HTMLElement.prototype.click = function () {
        addEventListener.call(this, 'click', handleClick);
        try {
            originalClickDescriptor.value.call(this);
        }
        finally {
            removeEventListener.call(this, 'click', handleClick);
        }
    };
}

if (detect()) {
    apply$5();
}

function detect$1() {
    return Object.getOwnPropertyDescriptor(Event.prototype, 'composed') === undefined;
}

function apply$6() {
    const composedEvents = assign(create(null), {
        blur: 1,
        focus: 1,
        focusin: 1,
        focusout: 1,
        click: 1,
        dblclick: 1,
        mousedown: 1,
        mouseenter: 1,
        mouseleave: 1,
        mousemove: 1,
        mouseout: 1,
        mouseover: 1,
        mouseup: 1,
        wheel: 1,
        beforeinput: 1,
        input: 1,
        keydown: 1,
        keyup: 1,
        compositionstart: 1,
        compositionupdate: 1,
        compositionend: 1,
        touchstart: 1,
        touchend: 1,
        touchmove: 1,
        touchcancel: 1,
        pointerover: 1,
        pointerenter: 1,
        pointerdown: 1,
        pointermove: 1,
        pointerup: 1,
        pointercancel: 1,
        pointerout: 1,
        pointerleave: 1,
        gotpointercapture: 1,
        lostpointercapture: 1,
        dragstart: 1,
        drag: 1,
        dragenter: 1,
        dragleave: 1,
        dragover: 1,
        drop: 1,
        dragend: 1,
        DOMActivate: 1,
        DOMFocusIn: 1,
        DOMFocusOut: 1,
        keypress: 1,
    });
    Object.defineProperties(Event.prototype, {
        composed: {
            get() {
                const { type } = this;
                return composedEvents[type] === 1;
            },
            configurable: true,
            enumerable: true,
        },
    });
}

if (detect$1()) {
    apply$6();
}

const { CustomEvent: OriginalCustomEvent } = window;
function PatchedCustomEvent(type, eventInitDict) {
    const event = new OriginalCustomEvent(type, eventInitDict);
    Object.defineProperties(event, {
        composed: {
            get() {
                return !!(eventInitDict && eventInitDict.composed);
            },
            configurable: true,
            enumerable: true,
        },
    });
    return event;
}
function apply$7() {
    window.CustomEvent = PatchedCustomEvent;
    window.CustomEvent.prototype = OriginalCustomEvent.prototype;
}

{
    apply$7();
}

function apply$8 () {
    const originalComposedGetter = Object.getOwnPropertyDescriptor(Event.prototype, 'composed')
        .get;
    Object.defineProperties(FocusEvent.prototype, {
        composed: {
            get() {
                const { isTrusted } = this;
                const composed = originalComposedGetter.call(this);
                if (isTrusted && composed === false) {
                    return true;
                }
                return composed;
            },
            enumerable: true,
            configurable: true,
        },
    });
}

{
    apply$8();
}

function detect$2() {
    return typeof HTMLIFrameElement !== 'undefined';
}

function apply$9() {
    const desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');
    const { get: originalGetter } = desc;
    desc.get = function () {
        const original = originalGetter.call(this);
        if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {
            return original;
        }
        return wrapIframeWindow(original);
    };
    defineProperty(HTMLIFrameElement.prototype, 'contentWindow', desc);
}
function wrapIframeWindow(win) {
    return {
        addEventListener() {
            return win.addEventListener.apply(win, arguments);
        },
        blur() {
            return win.blur.apply(win, arguments);
        },
        close() {
            return win.close.apply(win, arguments);
        },
        focus() {
            return win.focus.apply(win, arguments);
        },
        postMessage() {
            return win.postMessage.apply(win, arguments);
        },
        removeEventListener() {
            return win.removeEventListener.apply(win, arguments);
        },
        get closed() {
            return win.closed;
        },
        get frames() {
            return win.frames;
        },
        get length() {
            return win.length;
        },
        get location() {
            return win.location;
        },
        set location(value) {
            win.location = value;
        },
        get opener() {
            return win.opener;
        },
        get parent() {
            return win.parent;
        },
        get self() {
            return win.self;
        },
        get top() {
            return win.top;
        },
        get window() {
            return win.window;
        },
    };
}

if (detect$2()) {
    apply$9();
}

const OriginalMutationObserver = window.MutationObserver;
const { disconnect: originalDisconnect, observe: originalObserve, takeRecords: originalTakeRecords, } = OriginalMutationObserver.prototype;
const wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
const observerLookupField = '$$lwcNodeObservers$$';
const observerToNodesMap = new WeakMap();
function retargetMutationRecord(originalRecord) {
    const { addedNodes, removedNodes, target, type } = originalRecord;
    const retargetedRecord = create(MutationRecord.prototype);
    defineProperties(retargetedRecord, {
        addedNodes: {
            get() {
                return addedNodes;
            },
            enumerable: true,
            configurable: true,
        },
        removedNodes: {
            get() {
                return removedNodes;
            },
            enumerable: true,
            configurable: true,
        },
        type: {
            get() {
                return type;
            },
            enumerable: true,
            configurable: true,
        },
        target: {
            get() {
                return target.shadowRoot;
            },
            enumerable: true,
            configurable: true,
        },
    });
    return retargetedRecord;
}
function isQualifiedObserver(observer, target) {
    let parentNode = target;
    while (!isNull(parentNode)) {
        const parentNodeObservers = parentNode[observerLookupField];
        if (!isUndefined(parentNodeObservers) &&
            (parentNodeObservers[0] === observer ||
                ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {
            return true;
        }
        parentNode = parentNode.parentNode;
    }
    return false;
}
function filterMutationRecords(mutations, observer) {
    return ArrayReduce.call(mutations, (filteredSet, record) => {
        const { target, addedNodes, removedNodes, type } = record;
        if (type === 'childList' && !isUndefined(getNodeKey(target))) {
            if (addedNodes.length > 0) {
                const sampleNode = addedNodes[0];
                if (isQualifiedObserver(observer, sampleNode)) {
                    if (target[observerLookupField] &&
                        (target[observerLookupField][0] === observer ||
                            ArrayIndexOf.call(target[observerLookupField], observer) !== -1)) {
                        ArrayPush.call(filteredSet, record);
                    }
                    else {
                        ArrayPush.call(filteredSet, retargetMutationRecord(record));
                    }
                }
            }
            else {
                const shadowRoot = target.shadowRoot;
                const sampleNode = removedNodes[0];
                if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) &&
                    isQualifiedObserver(observer, target)
                ) {
                    ArrayPush.call(filteredSet, record);
                }
                else if (shadowRoot &&
                    shadowRoot[observerLookupField] &&
                    (shadowRoot[observerLookupField][0] === observer ||
                        ArrayIndexOf.call(shadowRoot[observerLookupField], observer) !== -1)) {
                    ArrayPush.call(filteredSet, retargetMutationRecord(record));
                }
            }
        }
        else {
            if (isQualifiedObserver(observer, target)) {
                ArrayPush.call(filteredSet, record);
            }
        }
        return filteredSet;
    }, []);
}
function getWrappedCallback(callback) {
    let wrappedCallback = callback[wrapperLookupField];
    if (isUndefined(wrappedCallback)) {
        wrappedCallback = callback[wrapperLookupField] = (mutations, observer) => {
            const filteredRecords = filterMutationRecords(mutations, observer);
            if (filteredRecords.length === 0) {
                return;
            }
            callback.call(observer, filteredRecords, observer);
        };
    }
    return wrappedCallback;
}
function PatchedMutationObserver(callback) {
    const wrappedCallback = getWrappedCallback(callback);
    const observer = new OriginalMutationObserver(wrappedCallback);
    return observer;
}
function patchedDisconnect() {
    originalDisconnect.call(this);
    const observedNodes = observerToNodesMap.get(this);
    if (!isUndefined(observedNodes)) {
        forEach.call(observedNodes, observedNode => {
            const observers = observedNode[observerLookupField];
            if (!isUndefined(observers)) {
                const index = ArrayIndexOf.call(observers, this);
                if (index !== -1) {
                    ArraySplice.call(observers, index, 1);
                }
            }
        });
        observedNodes.length = 0;
    }
}
function patchedObserve(target, options) {
    if (isUndefined(target[observerLookupField])) {
        defineProperty(target, observerLookupField, { value: [] });
    }
    if (ArrayIndexOf.call(target[observerLookupField], this) === -1) {
        ArrayPush.call(target[observerLookupField], this);
    }
    if (target instanceof SyntheticShadowRoot) {
        target = target.host;
    }
    if (observerToNodesMap.has(this)) {
        const observedNodes = observerToNodesMap.get(this);
        if (ArrayIndexOf.call(observedNodes, target) === -1) {
            ArrayPush.call(observedNodes, target);
        }
    }
    else {
        observerToNodesMap.set(this, [target]);
    }
    return originalObserve.call(this, target, options);
}
function patchedTakeRecords() {
    return filterMutationRecords(originalTakeRecords.call(this), this);
}
PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
PatchedMutationObserver.prototype.observe = patchedObserve;
PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
function apply$a() {
    defineProperty(window, 'MutationObserver', {
        value: PatchedMutationObserver,
        configurable: true,
        writable: true,
    });
}

{
    apply$a();
}

const ShadowTokenPrivateKey = '$$ShadowTokenKey$$';
function getShadowToken(node) {
    return node.$shadowToken$;
}
function setShadowToken(node, shadowToken) {
    node.$shadowToken$ = shadowToken;
}
defineProperty(Element.prototype, '$shadowToken$', {
    set(shadowToken) {
        const oldShadowToken = this[ShadowTokenPrivateKey];
        if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
            removeAttribute.call(this, oldShadowToken);
        }
        if (!isUndefined(shadowToken)) {
            setAttribute.call(this, shadowToken, '');
        }
        this[ShadowTokenPrivateKey] = shadowToken;
    },
    get() {
        return this[ShadowTokenPrivateKey];
    },
    configurable: true,
});

const MutationObserver$1 = window.MutationObserver;
const MutationObserverObserve$1 = MutationObserver$1.prototype.observe;
const DomManualPrivateKey = '$$DomManualKey$$';
let portalObserver;
const portalObserverConfig = {
    childList: true,
    subtree: true,
};
function adoptChildNode(node, fn, shadowToken) {
    if (getShadowRootResolver(node) === fn) {
        return;
    }
    setShadowRootResolver(node, fn);
    if (node instanceof Element) {
        setShadowToken(node, shadowToken);
        const childNodes = getInternalChildNodes(node);
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
            const child = childNodes[i];
            adoptChildNode(child, fn, shadowToken);
        }
    }
}
function initPortalObserver() {
    return new MutationObserver$1(mutations => {
        forEach.call(mutations, mutation => {
            const { target: elm, addedNodes } = mutation;
            const fn = getShadowRootResolver(elm);
            const shadowToken = getShadowToken(elm);
            for (let i = 0, len = addedNodes.length; i < len; i += 1) {
                const node = addedNodes[i];
                adoptChildNode(node, fn, shadowToken);
            }
        });
    });
}
function markElementAsPortal(elm) {
    if (isUndefined(portalObserver)) {
        portalObserver = initPortalObserver();
    }
    if (isUndefined(getShadowRootResolver(elm))) {
        throw new Error(`Invalid Element`);
    }
    MutationObserverObserve$1.call(portalObserver, elm, portalObserverConfig);
}
defineProperty(Element.prototype, '$domManual$', {
    set(v) {
        this[DomManualPrivateKey] = v;
        if (isTrue(v)) {
            markElementAsPortal(this);
        }
    },
    get() {
        return this[DomManualPrivateKey];
    },
    configurable: true,
});

Element.prototype.$lwcPolyfill$ = {
    PatchedNode,
    PatchedElement,
    PatchedSlotElement,
};
/** version: 1.0.2-222.23 */
