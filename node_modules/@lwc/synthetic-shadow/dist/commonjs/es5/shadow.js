/* proxy-compat-disable */
'use strict';

var create = Object.create, assign = Object.assign, defineProperty = Object.defineProperty, getPrototypeOf = Object.getPrototypeOf, setPrototypeOf = Object.setPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, defineProperties = Object.defineProperties, hasOwnProperty = Object.hasOwnProperty;
var _a = Array.prototype, ArrayFilter = _a.filter, ArrayFind = _a.find, ArraySlice = _a.slice, ArraySplice = _a.splice, ArrayUnshift = _a.unshift, ArrayIndexOf = _a.indexOf, ArrayPush = _a.push, ArrayMap = _a.map, ArrayJoin = _a.join, forEach = _a.forEach, ArrayReduce = _a.reduce, ArrayReverse = _a.reverse;
var _b = String.prototype, StringToLowerCase = _b.toLowerCase;
function isUndefined(obj) {
    return obj === undefined;
}
function isNull(obj) {
    return obj === null;
}
function isTrue(obj) {
    return obj === true;
}
function isFalse(obj) {
    return obj === false;
}
function isFunction(obj) {
    return typeof obj === 'function';
}
var OtS = {}.toString;
function toString(obj) {
    if (obj && obj.toString) {
        return obj.toString();
    }
    else if (typeof obj === 'object') {
        return OtS.call(obj);
    }
    else {
        return obj + '';
    }
}
function getPropertyDescriptor(o, p) {
    do {
        var d = getOwnPropertyDescriptor(o, p);
        if (!isUndefined(d)) {
            return d;
        }
        o = getPrototypeOf(o);
    } while (o !== null);
}

var DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;
var elementFromPoint = hasOwnProperty.call(Document.prototype, 'elementFromPoint')
    ? Document.prototype.elementFromPoint
    : Document.prototype.msElementFromPoint;
var defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, 'defaultView').get;
var _a$1 = Document.prototype, createComment = _a$1.createComment, querySelectorAll = _a$1.querySelectorAll, getElementById = _a$1.getElementById, getElementsByClassName = _a$1.getElementsByClassName, getElementsByTagName = _a$1.getElementsByTagName, getElementsByTagNameNS = _a$1.getElementsByTagNameNS;
var getElementsByName = HTMLDocument.prototype.getElementsByName;

var DOCUMENT_POSITION_CONTAINED_BY = Node.DOCUMENT_POSITION_CONTAINED_BY, DOCUMENT_POSITION_CONTAINS = Node.DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_PRECEDING = Node.DOCUMENT_POSITION_PRECEDING, DOCUMENT_POSITION_FOLLOWING = Node.DOCUMENT_POSITION_FOLLOWING, DOCUMENT_FRAGMENT_NODE = Node.DOCUMENT_FRAGMENT_NODE;
var _a$2 = Node.prototype, appendChild = _a$2.appendChild, cloneNode = _a$2.cloneNode, compareDocumentPosition = _a$2.compareDocumentPosition, insertBefore = _a$2.insertBefore, removeChild = _a$2.removeChild, replaceChild = _a$2.replaceChild;
var parentNodeGetter = getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;
var ownerDocumentGetter = getOwnPropertyDescriptor(Node.prototype, 'ownerDocument').get;
var parentElementGetter = hasOwnProperty.call(Node.prototype, 'parentElement')
    ? getOwnPropertyDescriptor(Node.prototype, 'parentElement').get
    : getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get;
var textContextSetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').set;
var childNodesGetter = hasOwnProperty.call(Node.prototype, 'childNodes')
    ? getOwnPropertyDescriptor(Node.prototype, 'childNodes').get
    : getOwnPropertyDescriptor(HTMLElement.prototype, 'childNodes').get;
var isConnected = hasOwnProperty.call(Node.prototype, 'isConnected')
    ? getOwnPropertyDescriptor(Node.prototype, 'isConnected').get
    : function () {
        var doc = ownerDocumentGetter.call(this);
        return (
        doc === null ||
            (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0);
    };

var _a$3 = Element.prototype, hasAttribute = _a$3.hasAttribute, getAttribute = _a$3.getAttribute, setAttribute = _a$3.setAttribute, removeAttribute = _a$3.removeAttribute, querySelectorAll$1 = _a$3.querySelectorAll, getBoundingClientRect = _a$3.getBoundingClientRect, getElementsByTagName$1 = _a$3.getElementsByTagName, getElementsByTagNameNS$1 = _a$3.getElementsByTagNameNS;
var _b$1 = Element.prototype, addEventListener = _b$1.addEventListener, removeEventListener = _b$1.removeEventListener;
var innerHTMLSetter = hasOwnProperty.call(Element.prototype, 'innerHTML')
    ? getOwnPropertyDescriptor(Element.prototype, 'innerHTML').set
    : getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML').set;
var outerHTMLSetter = hasOwnProperty.call(Element.prototype, 'outerHTML')
    ? getOwnPropertyDescriptor(Element.prototype, 'outerHTML').set
    : getOwnPropertyDescriptor(HTMLElement.prototype, 'outerHTML').set;
var tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;
var tabIndexGetter = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex').get;
var matches = hasOwnProperty.call(Element.prototype, 'matches')
    ? Element.prototype.matches
    : Element.prototype.msMatchesSelector;
var childrenGetter = hasOwnProperty.call(Element.prototype, 'children')
    ? getOwnPropertyDescriptor(Element.prototype, 'children').get
    : getOwnPropertyDescriptor(HTMLElement.prototype, 'children').get;
var getElementsByClassName$1 = HTMLElement.prototype.getElementsByClassName;

var ShadowRootHostGetter = typeof window.ShadowRoot !== 'undefined'
    ? getOwnPropertyDescriptor(window.ShadowRoot.prototype, 'host').get
    : function () {
        throw new Error('Internal Error: Missing ShadowRoot');
    };
var dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent;
var isNativeShadowRootAvailable = typeof window.ShadowRoot !== 'undefined';
var eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;
var eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;
var focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;

function isLWC(element) {
    return element instanceof Element && tagNameGetter.call(element).indexOf('-') !== -1;
}
function isShadowRoot(elmOrShadow) {
    return !(elmOrShadow instanceof Element) && 'host' in elmOrShadow;
}
function getFormattedComponentStack(elm) {
    var componentStack = [];
    var indentationChar = '\t';
    var indentation = '';
    var currentElement = elm;
    do {
        if (isLWC(currentElement)) {
            ArrayPush.call(componentStack, indentation + "<" + StringToLowerCase.call(tagNameGetter.call(currentElement)) + ">");
            indentation = indentation + indentationChar;
        }
        if (isShadowRoot(currentElement)) {
            currentElement = ShadowRootHostGetter.call(currentElement);
        }
        else {
            currentElement = parentNodeGetter.call(currentElement);
        }
    } while (!isNull(currentElement));
    return ArrayJoin.call(componentStack, '\n');
}
var assert = {
    invariant: function (value, msg) {
        if (!value) {
            throw new Error("Invariant Violation: " + msg);
        }
    },
    isTrue: function (value, msg) {
        if (!value) {
            throw new Error("Assert Violation: " + msg);
        }
    },
    isFalse: function (value, msg) {
        if (value) {
            throw new Error("Assert Violation: " + msg);
        }
    },
    fail: function (msg) {
        throw new Error(msg);
    },
    logError: function (message, elm) {
        var msg = "[LWC error]: " + message;
        if (elm) {
            msg = msg + "\n" + getFormattedComponentStack(elm);
        }
        if (process.env.NODE_ENV === 'test') {
            console.error(msg);
            return;
        }
        try {
            throw new Error(msg);
        }
        catch (e) {
            console.error(e);
        }
    },
};

function getOwnerDocument(node) {
    var doc = ownerDocumentGetter.call(node);
    return doc === null ? node : doc;
}
function getOwnerWindow(node) {
    var doc = getOwnerDocument(node);
    var win = defaultViewGetter.call(doc);
    if (win === null) {
        throw new TypeError();
    }
    return win;
}

function pathComposer(startNode, composed) {
    var composedPath = [];
    var current = startNode;
    var startRoot = startNode instanceof Window ? startNode : patchedGetRootNode$1.call(startNode);
    while (current) {
        composedPath.push(current);
        if (current.assignedSlot) {
            current = current.assignedSlot;
        }
        else if (current.nodeType === DOCUMENT_FRAGMENT_NODE &&
            current.host &&
            (composed || current !== startRoot)) {
            current = current.host;
        }
        else {
            current = current.parentNode;
        }
    }
    var doc;
    if (startNode instanceof Window) {
        doc = startNode.document;
    }
    else {
        doc = getOwnerDocument(startNode);
    }
    if (composedPath[composedPath.length - 1] === doc) {
        composedPath.push(window);
    }
    return composedPath;
}

function retarget(refNode, path) {
    if (isNull(refNode)) {
        return null;
    }
    var refNodePath = pathComposer(refNode, true);
    var p$ = path;
    for (var i = 0, ancestor = void 0, lastRoot = void 0, root = void 0, rootIdx = void 0; i < p$.length; i++) {
        ancestor = p$[i];
        root = ancestor instanceof Window ? ancestor : patchedGetRootNode$1.call(ancestor);
        if (root !== lastRoot) {
            rootIdx = refNodePath.indexOf(root);
            lastRoot = root;
        }
        if (!(root instanceof SyntheticShadowRoot) || rootIdx > -1) {
            return ancestor;
        }
    }
    return null;
}

var windowAddEventListener = window.addEventListener, windowRemoveEventListener = window.removeEventListener;

function doesEventNeedsPatch(e) {
    var originalTarget = eventTargetGetter.call(e);
    return originalTarget instanceof Node && isNodeShadowed(originalTarget);
}
function getEventListenerWrapper(fnOrObj) {
    var wrapperFn = null;
    try {
        wrapperFn = fnOrObj.$$lwcEventWrapper$$;
        if (!wrapperFn) {
            var isHandlerFunction_1 = typeof fnOrObj === 'function';
            wrapperFn = fnOrObj.$$lwcEventWrapper$$ = function (e) {
                if (doesEventNeedsPatch(e)) {
                    patchEvent(e);
                }
                return isHandlerFunction_1
                    ? fnOrObj.call(this, e)
                    : fnOrObj.handleEvent && fnOrObj.handleEvent(e);
            };
        }
    }
    catch (e) {
    }
    return wrapperFn;
}
function windowAddEventListener$1(type, fnOrObj, optionsOrCapture) {
    var handlerType = typeof fnOrObj;
    if (handlerType !== 'function' && handlerType !== 'object') {
        return;
    }
    if (handlerType === 'object' &&
        (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
        return;
    }
    var wrapperFn = getEventListenerWrapper(fnOrObj);
    windowAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
}
function windowRemoveEventListener$1(type, fnOrObj, optionsOrCapture) {
    var wrapperFn = getEventListenerWrapper(fnOrObj);
    windowRemoveEventListener.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);
}
function addEventListener$1(type, fnOrObj, optionsOrCapture) {
    var handlerType = typeof fnOrObj;
    if (handlerType !== 'function' && handlerType !== 'object') {
        return;
    }
    if (handlerType === 'object' &&
        (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
        return;
    }
    var wrapperFn = getEventListenerWrapper(fnOrObj);
    addEventListener.call(this, type, wrapperFn, optionsOrCapture);
}
function removeEventListener$1(type, fnOrObj, optionsOrCapture) {
    var wrapperFn = getEventListenerWrapper(fnOrObj);
    removeEventListener.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);
}
function windowPatchListeners() {
    window.addEventListener = windowAddEventListener$1;
    window.removeEventListener = windowRemoveEventListener$1;
}
function nodePatchListeners() {
    Node.prototype.addEventListener = addEventListener$1;
    Node.prototype.removeEventListener = removeEventListener$1;
}
function apply() {
    windowPatchListeners();
    nodePatchListeners();
}

{
    apply();
}

var _a$4 = Node.prototype, addEventListener$2 = _a$4.addEventListener, removeEventListener$2 = _a$4.removeEventListener;
var EventListenerContext;
(function (EventListenerContext) {
    EventListenerContext[EventListenerContext["CUSTOM_ELEMENT_LISTENER"] = 1] = "CUSTOM_ELEMENT_LISTENER";
    EventListenerContext[EventListenerContext["SHADOW_ROOT_LISTENER"] = 2] = "SHADOW_ROOT_LISTENER";
})(EventListenerContext || (EventListenerContext = {}));
var eventToContextMap = new WeakMap();
function isChildNode(root, node) {
    return !!(compareDocumentPosition.call(root, node) & DOCUMENT_POSITION_CONTAINED_BY);
}
var GET_ROOT_NODE_CONFIG_FALSE = { composed: false };
function getRootNodeHost(node, options) {
    var rootNode = patchedGetRootNode$1.call(node, options);
    if ('mode' in rootNode && 'delegatesFocus' in rootNode) {
        rootNode = getHost(rootNode);
    }
    return rootNode;
}
function targetGetter() {
    var originalCurrentTarget = eventCurrentTargetGetter.call(this);
    var originalTarget = eventTargetGetter.call(this);
    var composedPath = pathComposer(originalTarget, this.composed);
    var doc = getOwnerDocument(originalTarget);
    if (!(originalCurrentTarget instanceof Node)) {
        if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
            return originalTarget;
        }
        return retarget(doc, composedPath);
    }
    else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
        if (isUndefined(getNodeOwnerKey(originalTarget))) {
            return originalTarget;
        }
        return retarget(doc, composedPath);
    }
    var eventContext = eventToContextMap.get(this);
    var currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER
        ? getShadowRoot(originalCurrentTarget)
        : originalCurrentTarget;
    return retarget(currentTarget, composedPath);
}
function composedPathValue() {
    var originalTarget = eventTargetGetter.call(this);
    return pathComposer(originalTarget, this.composed);
}
function patchEvent(event) {
    if (eventToContextMap.has(event)) {
        return;
    }
    defineProperties(event, {
        target: {
            get: targetGetter,
            enumerable: true,
            configurable: true,
        },
        composedPath: {
            value: composedPathValue,
            writable: true,
            enumerable: true,
            configurable: true,
        },
        srcElement: {
            get: targetGetter,
            enumerable: true,
            configurable: true,
        },
        path: {
            get: composedPathValue,
            enumerable: true,
            configurable: true,
        },
    });
    var originalRelatedTargetDescriptor = getPropertyDescriptor(event, 'relatedTarget');
    if (!isUndefined(originalRelatedTargetDescriptor)) {
        var relatedTargetGetter_1 = originalRelatedTargetDescriptor.get;
        defineProperty(event, 'relatedTarget', {
            get: function () {
                var eventContext = eventToContextMap.get(this);
                var originalCurrentTarget = eventCurrentTargetGetter.call(this);
                var relatedTarget = relatedTargetGetter_1.call(this);
                if (isNull(relatedTarget)) {
                    return null;
                }
                var currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER
                    ? getShadowRoot(originalCurrentTarget)
                    : originalCurrentTarget;
                return retarget(currentTarget, pathComposer(relatedTarget, true));
            },
            enumerable: true,
            configurable: true,
        });
    }
    eventToContextMap.set(event, 0);
}
var customElementToWrappedListeners = new WeakMap();
function getEventMap(elm) {
    var listenerInfo = customElementToWrappedListeners.get(elm);
    if (isUndefined(listenerInfo)) {
        listenerInfo = create(null);
        customElementToWrappedListeners.set(elm, listenerInfo);
    }
    return listenerInfo;
}
var shadowRootEventListenerMap = new WeakMap();
function getWrappedShadowRootListener(sr, listener) {
    if (!isFunction(listener)) {
        throw new TypeError();
    }
    var shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);
    if (isUndefined(shadowRootWrappedListener)) {
        shadowRootWrappedListener = function (event) {
            var composed = event.composed;
            var target = eventTargetGetter.call(event);
            var currentTarget = eventCurrentTargetGetter.call(event);
            if (target !== currentTarget) {
                var rootNode = getRootNodeHost(target , {
                    composed: composed,
                });
                if (isChildNode(rootNode, currentTarget) ||
                    (composed === false && rootNode === currentTarget)) {
                    listener.call(sr, event);
                }
            }
        };
        shadowRootWrappedListener.placement = EventListenerContext.SHADOW_ROOT_LISTENER;
        if (process.env.NODE_ENV !== 'production') {
            shadowRootWrappedListener.original = listener;
        }
        shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
    }
    return shadowRootWrappedListener;
}
var customElementEventListenerMap = new WeakMap();
function getWrappedCustomElementListener(elm, listener) {
    if (!isFunction(listener)) {
        throw new TypeError();
    }
    var customElementWrappedListener = customElementEventListenerMap.get(listener);
    if (isUndefined(customElementWrappedListener)) {
        customElementWrappedListener = function (event) {
            if (isValidEventForCustomElement(event)) {
                listener.call(elm, event);
            }
        };
        customElementWrappedListener.placement = EventListenerContext.CUSTOM_ELEMENT_LISTENER;
        if (process.env.NODE_ENV !== 'production') {
            customElementWrappedListener.original = listener;
        }
        customElementEventListenerMap.set(listener, customElementWrappedListener);
    }
    return customElementWrappedListener;
}
function domListener(evt) {
    var immediatePropagationStopped = false;
    var propagationStopped = false;
    var type = evt.type, stopImmediatePropagation = evt.stopImmediatePropagation, stopPropagation = evt.stopPropagation;
    var currentTarget = eventCurrentTargetGetter.call(evt);
    var listenerMap = getEventMap(currentTarget);
    var listeners = listenerMap[type];
    defineProperty(evt, 'stopImmediatePropagation', {
        value: function () {
            immediatePropagationStopped = true;
            stopImmediatePropagation.call(evt);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(evt, 'stopPropagation', {
        value: function () {
            propagationStopped = true;
            stopPropagation.call(evt);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    var bookkeeping = ArraySlice.call(listeners);
    function invokeListenersByPlacement(placement) {
        forEach.call(bookkeeping, function (listener) {
            if (isFalse(immediatePropagationStopped) && listener.placement === placement) {
                if (ArrayIndexOf.call(listeners, listener) !== -1) {
                    listener.call(undefined, evt);
                }
            }
        });
    }
    eventToContextMap.set(evt, EventListenerContext.SHADOW_ROOT_LISTENER);
    invokeListenersByPlacement(EventListenerContext.SHADOW_ROOT_LISTENER);
    if (isFalse(immediatePropagationStopped) && isFalse(propagationStopped)) {
        eventToContextMap.set(evt, EventListenerContext.CUSTOM_ELEMENT_LISTENER);
        invokeListenersByPlacement(EventListenerContext.CUSTOM_ELEMENT_LISTENER);
    }
    eventToContextMap.set(evt, 0);
}
function attachDOMListener(elm, type, wrappedListener) {
    var listenerMap = getEventMap(elm);
    var cmpEventHandlers = listenerMap[type];
    if (isUndefined(cmpEventHandlers)) {
        cmpEventHandlers = listenerMap[type] = [];
    }
    if (cmpEventHandlers.length === 0) {
        addEventListener$2.call(elm, type, domListener);
    }
    ArrayPush.call(cmpEventHandlers, wrappedListener);
}
function detachDOMListener(elm, type, wrappedListener) {
    var listenerMap = getEventMap(elm);
    var p;
    var listeners;
    if (!isUndefined((listeners = listenerMap[type])) &&
        (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
        ArraySplice.call(listeners, p, 1);
        if (listeners.length === 0) {
            removeEventListener$2.call(elm, type, domListener);
        }
    }
}
function isValidEventForCustomElement(event) {
    var target = eventTargetGetter.call(event);
    var currentTarget = eventCurrentTargetGetter.call(event);
    var composed = event.composed;
    return (
    composed === true ||
        target === currentTarget ||
        isChildNode(getRootNodeHost(target , GET_ROOT_NODE_CONFIG_FALSE), currentTarget));
}
function addCustomElementEventListener(elm, type, listener, options) {
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(isFunction(listener), "Invalid second argument for this.addEventListener() in " + toString(elm) + " for event \"" + type + "\". Expected an EventListener but received " + listener + ".");
        if (!isUndefined(options)) {
            assert.logError('The `addEventListener` method in `LightningElement` does not support any options.', elm);
        }
    }
    var wrappedListener = getWrappedCustomElementListener(elm, listener);
    attachDOMListener(elm, type, wrappedListener);
}
function removeCustomElementEventListener(elm, type, listener, _options) {
    var wrappedListener = getWrappedCustomElementListener(elm, listener);
    detachDOMListener(elm, type, wrappedListener);
}
function addShadowRootEventListener(sr, type, listener, options) {
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(isFunction(listener), "Invalid second argument for this.template.addEventListener() in " + toString(sr) + " for event \"" + type + "\". Expected an EventListener but received " + listener + ".");
        if (!isUndefined(options)) {
            assert.logError('The `addEventListener` method in `LightningElement` does not support any options.', getHost(sr));
        }
    }
    var elm = getHost(sr);
    var wrappedListener = getWrappedShadowRootListener(sr, listener);
    attachDOMListener(elm, type, wrappedListener);
}
function removeShadowRootEventListener(sr, type, listener, _options) {
    var elm = getHost(sr);
    var wrappedListener = getWrappedShadowRootListener(sr, listener);
    detachDOMListener(elm, type, wrappedListener);
}

var hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
function createFieldName(key) {
    return hasNativeSymbolsSupport ? Symbol(key) : "$$lwc-" + key + "$$";
}
function setInternalField(o, fieldName, value) {
    defineProperty(o, fieldName, {
        value: value,
    });
}
function getInternalField(o, fieldName) {
    return o[fieldName];
}

function getTextContent(node) {
    switch (node.nodeType) {
        case Node.ELEMENT_NODE: {
            var childNodes = getFilteredChildNodes(node);
            var content = '';
            for (var i = 0, len = childNodes.length; i < len; i += 1) {
                content += getTextContent(childNodes[i]);
            }
            return content;
        }
        default:
            return node.nodeValue;
    }
}

var _a$5;
var Items = createFieldName('items');
function StaticNodeList() {
    throw new TypeError('Illegal constructor');
}
StaticNodeList.prototype = create(NodeList.prototype, (_a$5 = {
        constructor: {
            writable: true,
            configurable: true,
            value: StaticNodeList,
        },
        item: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (index) {
                return this[index];
            },
        },
        length: {
            enumerable: true,
            configurable: true,
            get: function () {
                return getInternalField(this, Items).length;
            },
        },
        forEach: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (cb, thisArg) {
                forEach.call(getInternalField(this, Items), cb, thisArg);
            },
        },
        entries: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function () {
                return ArrayMap.call(getInternalField(this, Items), function (v, i) { return [i, v]; });
            },
        },
        keys: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function () {
                return ArrayMap.call(getInternalField(this, Items), function (v, i) { return i; });
            },
        },
        values: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function () {
                return getInternalField(this, Items);
            },
        }
    },
    _a$5[Symbol.iterator] = {
        writable: true,
        configurable: true,
        value: function () {
            var _this = this;
            var nextIndex = 0;
            return {
                next: function () {
                    var items = getInternalField(_this, Items);
                    return nextIndex < items.length
                        ? {
                            value: items[nextIndex++],
                            done: false,
                        }
                        : {
                            done: true,
                        };
                },
            };
        },
    },
    _a$5[Symbol.toStringTag] = {
        configurable: true,
        get: function () {
            return 'NodeList';
        },
    },
    _a$5.toString = {
        writable: true,
        configurable: true,
        value: function () {
            return '[object NodeList]';
        },
    },
    _a$5));
setPrototypeOf(StaticNodeList, NodeList);
function createStaticNodeList(items) {
    var nodeList = create(StaticNodeList.prototype);
    setInternalField(nodeList, Items, items);
    forEach.call(items, function (item, index) {
        defineProperty(nodeList, index, {
            value: item,
            enumerable: true,
            configurable: true,
        });
    });
    return nodeList;
}

var _a$6;
var Items$1 = createFieldName('items');
function isValidHTMLCollectionName(name) {
    return name !== 'length' && isNaN(name);
}
function getNodeHTMLCollectionName(node) {
    return node.getAttribute('id') || node.getAttribute('name');
}
function StaticHTMLCollection() {
    throw new TypeError('Illegal constructor');
}
StaticHTMLCollection.prototype = create(HTMLCollection.prototype, (_a$6 = {
        constructor: {
            writable: true,
            configurable: true,
            value: StaticHTMLCollection,
        },
        item: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (index) {
                return this[index];
            },
        },
        length: {
            enumerable: true,
            configurable: true,
            get: function () {
                return getInternalField(this, Items$1).length;
            },
        },
        namedItem: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (name) {
                if (isValidHTMLCollectionName(name) && this[name]) {
                    return this[name];
                }
                var items = getInternalField(this, Items$1);
                for (var len = items.length - 1; len >= 0; len -= 1) {
                    var item = items[len];
                    var nodeName = getNodeHTMLCollectionName(item);
                    if (nodeName === name) {
                        return item;
                    }
                }
                return null;
            },
        },
        forEach: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function (cb, thisArg) {
                forEach.call(getInternalField(this, Items$1), cb, thisArg);
            },
        },
        entries: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function () {
                return ArrayMap.call(getInternalField(this, Items$1), function (v, i) { return [i, v]; });
            },
        },
        keys: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function () {
                return ArrayMap.call(getInternalField(this, Items$1), function (v, i) { return i; });
            },
        },
        values: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: function () {
                return getInternalField(this, Items$1);
            },
        }
    },
    _a$6[Symbol.iterator] = {
        writable: true,
        configurable: true,
        value: function () {
            var _this = this;
            var nextIndex = 0;
            return {
                next: function () {
                    var items = getInternalField(_this, Items$1);
                    return nextIndex < items.length
                        ? {
                            value: items[nextIndex++],
                            done: false,
                        }
                        : {
                            done: true,
                        };
                },
            };
        },
    },
    _a$6[Symbol.toStringTag] = {
        configurable: true,
        get: function () {
            return 'HTMLCollection';
        },
    },
    _a$6.toString = {
        writable: true,
        configurable: true,
        value: function () {
            return '[object HTMLCollection]';
        },
    },
    _a$6));
setPrototypeOf(StaticHTMLCollection, HTMLCollection);
function createStaticHTMLCollection(items) {
    var collection = create(StaticHTMLCollection.prototype);
    setInternalField(collection, Items$1, items);
    forEach.call(items, function (item, index) {
        defineProperty(collection, index, {
            value: item,
            enumerable: true,
            configurable: true,
        });
    });
    return collection;
}

function getInnerHTML(node) {
    var s = '';
    var childNodes = getFilteredChildNodes(node);
    for (var i = 0, len = childNodes.length; i < len; i += 1) {
        s += getOuterHTML(childNodes[i]);
    }
    return s;
}

var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
var _a$7 = String.prototype, replace = _a$7.replace, toLowerCase = _a$7.toLowerCase;
function escapeReplace(c) {
    switch (c) {
        case '&':
            return '&amp;';
        case '<':
            return '&lt;';
        case '>':
            return '&gt;';
        case '"':
            return '&quot;';
        case '\u00A0':
            return '&nbsp;';
        default:
            return '';
    }
}
function escapeAttr(s) {
    return replace.call(s, escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
    return replace.call(s, escapeDataRegExp, escapeReplace);
}
var voidElements = new Set([
    'AREA',
    'BASE',
    'BR',
    'COL',
    'COMMAND',
    'EMBED',
    'HR',
    'IMG',
    'INPUT',
    'KEYGEN',
    'LINK',
    'META',
    'PARAM',
    'SOURCE',
    'TRACK',
    'WBR',
]);
var plaintextParents = new Set([
    'STYLE',
    'SCRIPT',
    'XMP',
    'IFRAME',
    'NOEMBED',
    'NOFRAMES',
    'PLAINTEXT',
    'NOSCRIPT',
]);
function getOuterHTML(node) {
    switch (node.nodeType) {
        case Node.ELEMENT_NODE: {
            var attrs = node.attributes;
            var tagName = tagNameGetter.call(node);
            var s = '<' + toLowerCase.call(tagName);
            for (var i = 0, attr = void 0; (attr = attrs[i]); i++) {
                s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
            }
            s += '>';
            if (voidElements.has(tagName)) {
                return s;
            }
            return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';
        }
        case Node.TEXT_NODE: {
            var _a = node, data = _a.data, parentNode = _a.parentNode;
            if (parentNode instanceof Element &&
                plaintextParents.has(tagNameGetter.call(parentNode))) {
                return data;
            }
            return escapeData(data);
        }
        case Node.COMMENT_NODE: {
            return '<!--' + node.data + '-->';
        }
        default: {
            throw new Error();
        }
    }
}

var ShadowRootResolverKey = '$shadowResolver$';
var InternalSlot = createFieldName('shadowRecord');
var createDocumentFragment = document.createDocumentFragment;
function getInternalSlot(root) {
    var record = getInternalField(root, InternalSlot);
    if (isUndefined(record)) {
        throw new TypeError();
    }
    return record;
}
var ShadowResolverPrivateKey = '$$ShadowResolverKey$$';
defineProperty(Node.prototype, ShadowRootResolverKey, {
    set: function (fn) {
        this[ShadowResolverPrivateKey] = fn;
        setNodeOwnerKey(this, fn.nodeKey);
    },
    get: function () {
        return this[ShadowResolverPrivateKey];
    },
    configurable: true,
    enumerable: true,
});
function getShadowRootResolver(node) {
    return node[ShadowRootResolverKey];
}
function setShadowRootResolver(node, fn) {
    node[ShadowRootResolverKey] = fn;
}
function isDelegatingFocus(host) {
    return getInternalSlot(host).delegatesFocus;
}
function getHost(root) {
    return getInternalSlot(root).host;
}
function getShadowRoot(elm) {
    return getInternalSlot(elm).shadowRoot;
}
function hasSyntheticShadow(elm) {
    return !isUndefined(getInternalField(elm, InternalSlot));
}
var uid = 0;
function attachShadow(elm, options) {
    if (!isUndefined(getInternalField(elm, InternalSlot))) {
        throw new Error("Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.");
    }
    var mode = options.mode, delegatesFocus = options.delegatesFocus;
    var doc = getOwnerDocument(elm);
    var sr = createDocumentFragment.call(doc);
    var record = {
        mode: mode,
        delegatesFocus: !!delegatesFocus,
        host: elm,
        shadowRoot: sr,
    };
    setInternalField(sr, InternalSlot, record);
    setInternalField(elm, InternalSlot, record);
    var shadowResolver = function () { return sr; };
    var x = (shadowResolver.nodeKey = uid++);
    setNodeKey(elm, x);
    setShadowRootResolver(sr, shadowResolver);
    setPrototypeOf(sr, SyntheticShadowRoot.prototype);
    return sr;
}
var SyntheticShadowRootDescriptors = {
    constructor: {
        writable: true,
        configurable: true,
        value: SyntheticShadowRoot,
    },
    toString: {
        writable: true,
        configurable: true,
        value: function () {
            return "[object ShadowRoot]";
        },
    },
};
var ShadowRootDescriptors = {
    activeElement: {
        enumerable: true,
        configurable: true,
        get: function () {
            var host = getHost(this);
            var doc = getOwnerDocument(host);
            var activeElement = DocumentPrototypeActiveElement.call(doc);
            if (isNull(activeElement)) {
                return activeElement;
            }
            if ((compareDocumentPosition.call(host, activeElement) &
                DOCUMENT_POSITION_CONTAINED_BY) ===
                0) {
                return null;
            }
            var node = activeElement;
            while (!isNodeOwnedBy(host, node)) {
                node = parentElementGetter.call(node);
            }
            if (isSlotElement(node)) {
                return null;
            }
            return node;
        },
    },
    delegatesFocus: {
        configurable: true,
        get: function () {
            return getInternalSlot(this).delegatesFocus;
        },
    },
    elementFromPoint: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (left, top) {
            var host = getHost(this);
            var doc = getOwnerDocument(host);
            var element = elementFromPoint.call(doc, left, top);
            if (isNull(element)) {
                return element;
            }
            return retarget(this, pathComposer(element, true));
        },
    },
    elementsFromPoint: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (_left, _top) {
            throw new Error();
        },
    },
    getSelection: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function () {
            throw new Error();
        },
    },
    host: {
        enumerable: true,
        configurable: true,
        get: function () {
            return getHost(this);
        },
    },
    mode: {
        configurable: true,
        get: function () {
            return getInternalSlot(this).mode;
        },
    },
    styleSheets: {
        enumerable: true,
        configurable: true,
        get: function () {
            throw new Error();
        },
    },
};
var NodePatchDescriptors = {
    insertBefore: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (newChild, refChild) {
            insertBefore.call(getHost(this), newChild, refChild);
            return newChild;
        },
    },
    removeChild: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (oldChild) {
            removeChild.call(getHost(this), oldChild);
            return oldChild;
        },
    },
    appendChild: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (newChild) {
            appendChild.call(getHost(this), newChild);
            return newChild;
        },
    },
    replaceChild: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (newChild, oldChild) {
            replaceChild.call(getHost(this), newChild, oldChild);
            return oldChild;
        },
    },
    addEventListener: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (type, listener, options) {
            addShadowRootEventListener(this, type, listener, options);
        },
    },
    removeEventListener: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (type, listener, options) {
            removeShadowRootEventListener(this, type, listener, options);
        },
    },
    baseURI: {
        enumerable: true,
        configurable: true,
        get: function () {
            return getHost(this).baseURI;
        },
    },
    childNodes: {
        enumerable: true,
        configurable: true,
        get: function () {
            return createStaticNodeList(shadowRootChildNodes(this));
        },
    },
    compareDocumentPosition: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (otherNode) {
            var host = getHost(this);
            if (this === otherNode) {
                return 0;
            }
            else if (this.contains(otherNode)) {
                return 20;
            }
            else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
                return 37;
            }
            else {
                return 35;
            }
        },
    },
    contains: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (otherNode) {
            if (this === otherNode) {
                return true;
            }
            var host = getHost(this);
            return ((compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !==
                0 && isNodeOwnedBy(host, otherNode));
        },
    },
    firstChild: {
        enumerable: true,
        configurable: true,
        get: function () {
            var childNodes = getInternalChildNodes(this);
            return childNodes[0] || null;
        },
    },
    lastChild: {
        enumerable: true,
        configurable: true,
        get: function () {
            var childNodes = getInternalChildNodes(this);
            return childNodes[childNodes.length - 1] || null;
        },
    },
    hasChildNodes: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function () {
            var childNodes = getInternalChildNodes(this);
            return childNodes.length > 0;
        },
    },
    isConnected: {
        enumerable: true,
        configurable: true,
        get: function () {
            return isConnected.call(getHost(this));
        },
    },
    nextSibling: {
        enumerable: true,
        configurable: true,
        get: function () {
            return null;
        },
    },
    previousSibling: {
        enumerable: true,
        configurable: true,
        get: function () {
            return null;
        },
    },
    nodeName: {
        enumerable: true,
        configurable: true,
        get: function () {
            return '#document-fragment';
        },
    },
    nodeType: {
        enumerable: true,
        configurable: true,
        get: function () {
            return 11;
        },
    },
    nodeValue: {
        enumerable: true,
        configurable: true,
        get: function () {
            return null;
        },
    },
    ownerDocument: {
        enumerable: true,
        configurable: true,
        get: function () {
            return getHost(this).ownerDocument;
        },
    },
    parentElement: {
        enumerable: true,
        configurable: true,
        get: function () {
            return null;
        },
    },
    parentNode: {
        enumerable: true,
        configurable: true,
        get: function () {
            return null;
        },
    },
    textContent: {
        enumerable: true,
        configurable: true,
        get: function () {
            var childNodes = getInternalChildNodes(this);
            var textContent = '';
            for (var i = 0, len = childNodes.length; i < len; i += 1) {
                textContent += getTextContent(childNodes[i]);
            }
            return textContent;
        },
        set: function (v) {
            var host = getHost(this);
            textContextSetter.call(host, v);
        },
    },
    getRootNode: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (options) {
            return !isUndefined(options) && isTrue(options.composed)
                ? getHost(this).getRootNode(options)
                : this;
        },
    },
};
var ElementPatchDescriptors = {
    innerHTML: {
        enumerable: true,
        configurable: true,
        get: function () {
            var childNodes = getInternalChildNodes(this);
            var innerHTML = '';
            for (var i = 0, len = childNodes.length; i < len; i += 1) {
                innerHTML += getOuterHTML(childNodes[i]);
            }
            return innerHTML;
        },
        set: function (v) {
            var host = getHost(this);
            innerHTMLSetter.call(host, v);
        },
    },
};
var ParentNodePatchDescriptors = {
    childElementCount: {
        enumerable: true,
        configurable: true,
        get: function () {
            return this.children.length;
        },
    },
    children: {
        enumerable: true,
        configurable: true,
        get: function () {
            return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), function (elm) { return elm instanceof Element; }));
        },
    },
    firstElementChild: {
        enumerable: true,
        configurable: true,
        get: function () {
            return this.children[0] || null;
        },
    },
    lastElementChild: {
        enumerable: true,
        configurable: true,
        get: function () {
            var children = this.children;
            return children.item(children.length - 1) || null;
        },
    },
    querySelector: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (selectors) {
            return shadowRootQuerySelector(this, selectors);
        },
    },
    querySelectorAll: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function (selectors) {
            return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
        },
    },
};
assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);
function SyntheticShadowRoot() {
    throw new TypeError('Illegal constructor');
}
SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);
if (isNativeShadowRootAvailable) {
    setPrototypeOf(SyntheticShadowRoot.prototype, window.ShadowRoot.prototype);
}
function getIE11FakeShadowRootPlaceholder(host) {
    var shadowRoot = getShadowRoot(host);
    var c = shadowRoot.$$placeholder$$;
    if (!isUndefined(c)) {
        return c;
    }
    var doc = getOwnerDocument(host);
    c = shadowRoot.$$placeholder$$ = createComment.call(doc, '');
    defineProperties(c, {
        childNodes: {
            get: function () {
                return shadowRoot.childNodes;
            },
            enumerable: true,
            configurable: true,
        },
        tagName: {
            get: function () {
                return "#shadow-root (" + shadowRoot.mode + ")";
            },
            enumerable: true,
            configurable: true,
        },
    });
    return c;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var MO = window.MutationObserver;
if (typeof MO === 'undefined') {
    function MutationObserverMock() { }
    MutationObserverMock.prototype = {
        observe: function () {
            if (process.env.NODE_ENV !== 'production') {
                if (process.env.NODE_ENV !== 'test') {
                    throw new Error("MutationObserver should not be mocked outside of the jest test environment");
                }
            }
        },
    };
    MO = window.MutationObserver = MutationObserverMock;
}
var MutationObserver = MO;
var MutationObserverObserve = MutationObserver.prototype.observe;

function collectionFilter(collection, fn) {
    var res = [];
    var length = collection.length;
    for (var i = 0; i < length; i++) {
        var curr = collection[i];
        if (isTrue(fn(curr, i, collection))) {
            ArrayPush.call(res, curr);
        }
    }
    return res;
}
function collectionFind(collection, fn) {
    var length = collection.length;
    for (var i = 0; i < length; i++) {
        var curr = collection[i];
        if (isTrue(fn(curr, i, collection))) {
            return curr;
        }
    }
    return undefined;
}
function collectionSlice(collection, begin, end) {
    end = !isUndefined(end) ? end : collection.length;
    var cloned = [];
    var len = collection.length;
    var start = !isUndefined(begin) ? begin : 0;
    start = start >= 0 ? start : Math.max(0, len + start);
    var upTo = !isUndefined(end) ? Math.min(end, len) : len;
    if (end < 0) {
        upTo = len + end;
    }
    var size = upTo - start;
    if (size > 0) {
        for (var i = 0; i < size; i++) {
            ArrayPush.call(cloned, collection[start + i]);
        }
    }
    return cloned;
}
function collectionIndexOf(collection, searchItem, fromIndex) {
    if (fromIndex === void 0) { fromIndex = 0; }
    var len = collection.length;
    var i = Math.min(fromIndex, len);
    if (i < 0) {
        i = Math.max(0, len + i);
    }
    else if (i >= len) {
        return -1;
    }
    for (; i !== len; ++i) {
        if (collection[i] === searchItem) {
            return i;
        }
    }
    return -1;
}

var TabbableElementsQuery = "\n    button:not([tabindex=\"-1\"]):not([disabled]),\n    [contenteditable]:not([tabindex=\"-1\"]),\n    video[controls]:not([tabindex=\"-1\"]),\n    audio[controls]:not([tabindex=\"-1\"]),\n    [href]:not([tabindex=\"-1\"]),\n    input:not([tabindex=\"-1\"]):not([disabled]),\n    select:not([tabindex=\"-1\"]):not([disabled]),\n    textarea:not([tabindex=\"-1\"]):not([disabled]),\n    [tabindex=\"0\"]\n";
var DidAddMouseDownListener = createFieldName('DidAddMouseDownListener');
function isVisible(element) {
    var _a = getBoundingClientRect.call(element), width = _a.width, height = _a.height;
    var noZeroSize = width > 0 || height > 0;
    return noZeroSize && getComputedStyle(element).visibility !== 'hidden';
}
function isTabbable(element) {
    return matches.call(element, TabbableElementsQuery) && isVisible(element);
}
function getTabbableSegments(host) {
    var doc = getOwnerDocument(host);
    var all = querySelectorAll.call(doc, TabbableElementsQuery);
    var inner = collectionSlice(querySelectorAll$1.call(host, TabbableElementsQuery));
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(getAttribute.call(host, 'tabindex') === '-1' || isDelegatingFocus(host), "The focusin event is only relevant when the tabIndex property is -1 on the host.");
    }
    var firstChild = inner[0];
    var lastChild = inner[inner.length - 1];
    var hostIndex = collectionIndexOf(all, host);
    var firstChildIndex = hostIndex > -1 ? hostIndex : collectionIndexOf(all, firstChild);
    var lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : collectionIndexOf(all, lastChild) + 1;
    var prev = collectionSlice(all, 0, firstChildIndex);
    var next = collectionSlice(all, lastChildIndex);
    return {
        prev: prev,
        inner: inner,
        next: next,
    };
}
function getActiveElement(host) {
    var doc = getOwnerDocument(host);
    var activeElement = DocumentPrototypeActiveElement.call(doc);
    if (isNull(activeElement)) {
        return activeElement;
    }
    return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !==
        0
        ? activeElement
        : null;
}
function relatedTargetPosition(host, relatedTarget) {
    var pos = compareDocumentPosition.call(host, relatedTarget);
    if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
        return 0;
    }
    else if (pos & DOCUMENT_POSITION_PRECEDING) {
        return 1;
    }
    else if (pos & DOCUMENT_POSITION_FOLLOWING) {
        return 2;
    }
    return -1;
}
function muteEvent(event) {
    event.preventDefault();
    event.stopPropagation();
}
function muteFocusEventsDuringExecution(win, func) {
    windowAddEventListener.call(win, 'focusin', muteEvent, true);
    windowAddEventListener.call(win, 'focusout', muteEvent, true);
    func();
    windowRemoveEventListener.call(win, 'focusin', muteEvent, true);
    windowRemoveEventListener.call(win, 'focusout', muteEvent, true);
}
function focusOnNextOrBlur(segment, target, relatedTarget) {
    var win = getOwnerWindow(relatedTarget);
    var next = getNextTabbable(segment, relatedTarget);
    if (isNull(next)) {
        muteFocusEventsDuringExecution(win, function () {
            target.blur();
        });
    }
    else {
        muteFocusEventsDuringExecution(win, function () {
            next.focus();
        });
    }
}
var letBrowserHandleFocus = false;
function disableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = true;
}
function enableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = false;
}
function skipHostHandler(event) {
    if (letBrowserHandleFocus) {
        enableKeyboardFocusNavigationRoutines();
        return;
    }
    var host = eventCurrentTargetGetter.call(event);
    var target = eventTargetGetter.call(event);
    if (host !== target) {
        return;
    }
    var relatedTarget = focusEventRelatedTargetGetter.call(event);
    if (isNull(relatedTarget)) {
        return;
    }
    var segments = getTabbableSegments(host);
    var position = relatedTargetPosition(host, relatedTarget);
    if (position === 1) {
        var findTabbableElms = isTabbableFrom.bind(null, patchedGetRootNode$1.call(host));
        var first_1 = ArrayFind.call(segments.inner, findTabbableElms);
        if (!isUndefined(first_1)) {
            var win = getOwnerWindow(first_1);
            muteFocusEventsDuringExecution(win, function () {
                first_1.focus();
            });
        }
        else {
            focusOnNextOrBlur(segments.next, target, relatedTarget);
        }
    }
    else if (host === target) {
        focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
}
function skipShadowHandler(event) {
    if (letBrowserHandleFocus) {
        enableKeyboardFocusNavigationRoutines();
        return;
    }
    var relatedTarget = focusEventRelatedTargetGetter.call(event);
    if (isNull(relatedTarget)) {
        return;
    }
    var host = eventCurrentTargetGetter.call(event);
    var segments = getTabbableSegments(host);
    if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
        return;
    }
    var target = eventTargetGetter.call(event);
    var position = relatedTargetPosition(host, relatedTarget);
    if (position === 1) {
        focusOnNextOrBlur(segments.next, target, relatedTarget);
    }
    if (position === 2) {
        focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
}
function isTabbableFrom(fromRoot, toElm) {
    if (!isTabbable(toElm)) {
        return false;
    }
    var ownerDocument = getOwnerDocument(toElm);
    var root = patchedGetRootNode$1.call(toElm);
    while (root !== ownerDocument && root !== fromRoot) {
        var sr = root;
        var host = sr.host;
        if (getAttribute.call(host, 'tabindex') === '-1') {
            return false;
        }
        root = host && patchedGetRootNode$1.call(host);
    }
    return true;
}
function getNextTabbable(tabbables, relatedTarget) {
    var len = tabbables.length;
    if (len > 0) {
        for (var i = 0; i < len; i += 1) {
            var next = tabbables[i];
            if (isTabbableFrom(patchedGetRootNode$1.call(relatedTarget), next)) {
                return next;
            }
        }
    }
    return null;
}
function handleFocus(elm) {
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(isDelegatingFocus(elm), "Invalid attempt to handle focus event for " + toString(elm) + ". " + toString(elm) + " should have delegates focus true, but is not delegating focus");
    }
    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocusIn(elm);
    addEventListener.call(elm, 'focusin', skipHostHandler, true);
}
function ignoreFocus(elm) {
    removeEventListener.call(elm, 'focusin', skipHostHandler, true);
}
function bindDocumentMousedownMouseupHandlers(elm) {
    var ownerDocument = getOwnerDocument(elm);
    if (!getInternalField(ownerDocument, DidAddMouseDownListener)) {
        setInternalField(ownerDocument, DidAddMouseDownListener, true);
        addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);
        addEventListener.call(ownerDocument, 'mouseup', function () {
            setTimeout(enableKeyboardFocusNavigationRoutines);
        }, true);
    }
}
function handleFocusIn(elm) {
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(tabIndexGetter.call(elm) === -1, "Invalid attempt to handle focus in  " + toString(elm) + ". " + toString(elm) + " should have tabIndex -1, but has tabIndex " + tabIndexGetter.call(elm));
    }
    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocus(elm);
    addEventListener.call(elm, 'focusin', skipShadowHandler, true);
}
function ignoreFocusIn(elm) {
    removeEventListener.call(elm, 'focusin', skipShadowHandler, true);
}

var nativeGetRootNode = Node.prototype.getRootNode;
var getDocumentOrRootNode = !isUndefined(nativeGetRootNode)
    ? nativeGetRootNode
    : function () {
        var node = this;
        var nodeParent;
        while (!isNull((nodeParent = parentNodeGetter.call(node)))) {
            node = nodeParent;
        }
        return node;
    };
function getNearestRoot(node) {
    var ownerNode = getNodeOwner(node);
    if (isNull(ownerNode)) {
        return getDocumentOrRootNode.call(node);
    }
    return getShadowRoot(ownerNode);
}
function patchedGetRootNode(options) {
    var composed = isUndefined(options) ? false : !!options.composed;
    return isTrue(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
}
function apply$1() {
    defineProperty(Node.prototype, 'getRootNode', {
        value: patchedGetRootNode,
        enumerable: true,
        configurable: true,
        writable: true,
    });
}

{
    apply$1();
}

function foldSlotElement(slot) {
    var parent = parentElementGetter.call(slot);
    while (!isNull(parent) && isSlotElement(parent)) {
        slot = parent;
        parent = parentElementGetter.call(slot);
    }
    return slot;
}
function isNodeSlotted(host, node) {
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(host instanceof HTMLElement, "isNodeSlotted() should be called with a host as the first argument instead of " + host);
        assert.invariant(node instanceof Node, "isNodeSlotted() should be called with a node as the second argument instead of " + node);
        assert.isTrue(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS, "isNodeSlotted() should never be called with a node that is not a child node of " + host);
    }
    var hostKey = getNodeKey(host);
    var currentElement = node instanceof Element ? node : parentElementGetter.call(node);
    while (!isNull(currentElement) && currentElement !== host) {
        var elmOwnerKey = getNodeNearestOwnerKey(currentElement);
        var parent = parentElementGetter.call(currentElement);
        if (elmOwnerKey === hostKey) {
            return isSlotElement(currentElement);
        }
        else if (parent === host) {
            return false;
        }
        else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
            if (isSlotElement(parent)) {
                currentElement = getNodeOwner(foldSlotElement(parent));
                if (!isNull(currentElement)) {
                    if (currentElement === host) {
                        return true;
                    }
                    else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
                        return true;
                    }
                }
            }
            else {
                return false;
            }
        }
        else {
            currentElement = parent;
        }
    }
    return false;
}
function getAllSlottedMatches(host, nodeList) {
    var filteredAndPatched = [];
    for (var i = 0, len = nodeList.length; i < len; i += 1) {
        var node = nodeList[i];
        if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
            ArrayPush.call(filteredAndPatched, node);
        }
    }
    return filteredAndPatched;
}
function getFirstSlottedMatch(host, nodeList) {
    for (var i = 0, len = nodeList.length; i < len; i += 1) {
        var node = nodeList[i];
        if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
            return node;
        }
    }
    return null;
}
function lightDomQuerySelectorAll(elm, selectors) {
    var owner = getNodeOwner(elm);
    if (isNull(owner)) {
        return [];
    }
    var nodeList = querySelectorAll$1.call(elm, selectors);
    if (getNodeKey(elm)) {
        return getAllSlottedMatches(elm, nodeList);
    }
    else {
        return getAllMatches(owner, nodeList);
    }
}
function lightDomQuerySelector(elm, selector) {
    var owner = getNodeOwner(elm);
    if (isNull(owner)) {
        return null;
    }
    var nodeList = querySelectorAll$1.call(elm, selector);
    if (getNodeKey(elm)) {
        return getFirstSlottedMatch(elm, nodeList);
    }
    else {
        return getFirstMatch(owner, nodeList);
    }
}
function PatchedElement(elm) {
    var Ctor = PatchedNode(elm);
    var superAddEventListener = elm.addEventListener, superRemoveEventListener = elm.removeEventListener, superBlur = elm.blur, superFocus = elm.focus;
    return  (function (_super) {
        __extends(PatchedHTMLElement, _super);
        function PatchedHTMLElement() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PatchedHTMLElement.prototype.querySelector = function (selector) {
            return lightDomQuerySelector(this, selector);
        };
        PatchedHTMLElement.prototype.querySelectorAll = function (selectors) {
            return createStaticNodeList(lightDomQuerySelectorAll(this, selectors));
        };
        Object.defineProperty(PatchedHTMLElement.prototype, "innerHTML", {
            get: function () {
                var childNodes = getInternalChildNodes(this);
                var innerHTML = '';
                for (var i = 0, len = childNodes.length; i < len; i += 1) {
                    innerHTML += getOuterHTML(childNodes[i]);
                }
                return innerHTML;
            },
            set: function (value) {
                innerHTMLSetter.call(this, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedHTMLElement.prototype, "outerHTML", {
            get: function () {
                return getOuterHTML(this);
            },
            set: function (value) {
                outerHTMLSetter.call(this, value);
            },
            enumerable: true,
            configurable: true
        });
        PatchedHTMLElement.prototype.attachShadow = function (options) {
            return attachShadow(this, options);
        };
        PatchedHTMLElement.prototype.addEventListener = function (type, listener, options) {
            if (hasSyntheticShadow(this)) {
                addCustomElementEventListener(this, type, listener, options);
            }
            else {
                superAddEventListener.call(this, type, listener, options);
            }
        };
        PatchedHTMLElement.prototype.removeEventListener = function (type, listener, options) {
            if (hasSyntheticShadow(this)) {
                removeCustomElementEventListener(this, type, listener, options);
            }
            else {
                superRemoveEventListener.call(this, type, listener, options);
            }
        };
        Object.defineProperty(PatchedHTMLElement.prototype, "shadowRoot", {
            get: function () {
                if (hasSyntheticShadow(this)) {
                    var shadow = getShadowRoot(this);
                    if (shadow.mode === 'open') {
                        return shadow;
                    }
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedHTMLElement.prototype, "tabIndex", {
            get: function () {
                if (hasSyntheticShadow(this) &&
                    isDelegatingFocus(this) &&
                    isFalse(hasAttribute.call(this, 'tabindex'))) {
                    return 0;
                }
                var descriptor = getPropertyDescriptor(Ctor.prototype, 'tabIndex');
                return descriptor.get.call(this);
            },
            set: function (value) {
                if (hasSyntheticShadow(this)) {
                    var delegatesFocus = isDelegatingFocus(this);
                    var prevValue = tabIndexGetter.call(this);
                    var prevHasAttr = hasAttribute.call(this, 'tabindex');
                    var descriptor_1 = getPropertyDescriptor(Ctor.prototype, 'tabIndex');
                    descriptor_1.set.call(this, value);
                    var currValue = tabIndexGetter.call(this);
                    var currHasAttr = hasAttribute.call(this, 'tabindex');
                    var didValueChange = prevValue !== currValue;
                    if (prevHasAttr && (didValueChange || isFalse(currHasAttr))) {
                        if (prevValue === -1) {
                            ignoreFocusIn(this);
                        }
                        if (prevValue === 0 && delegatesFocus) {
                            ignoreFocus(this);
                        }
                    }
                    if (isFalse(currHasAttr)) {
                        return;
                    }
                    if (prevHasAttr && currHasAttr && isFalse(didValueChange)) {
                        return;
                    }
                    if (currValue === -1) {
                        handleFocusIn(this);
                    }
                    if (currValue === 0 && delegatesFocus) {
                        handleFocus(this);
                    }
                    return;
                }
                var descriptor = getPropertyDescriptor(Ctor.prototype, 'tabIndex');
                descriptor.set.call(this, value);
            },
            enumerable: true,
            configurable: true
        });
        PatchedHTMLElement.prototype.blur = function () {
            if (hasSyntheticShadow(this) && isDelegatingFocus(this)) {
                var currentActiveElement = getActiveElement(this);
                if (!isNull(currentActiveElement)) {
                    currentActiveElement.blur();
                    return;
                }
            }
            return superBlur.call(this);
        };
        PatchedHTMLElement.prototype.focus = function () {
            disableKeyboardFocusNavigationRoutines();
            superFocus.call(this);
            enableKeyboardFocusNavigationRoutines();
        };
        Object.defineProperty(PatchedHTMLElement.prototype, "childNodes", {
            get: function () {
                if (hasSyntheticShadow(this)) {
                    var owner = getNodeOwner(this);
                    var childNodes = isNull(owner)
                        ? []
                        : getAllMatches(owner, getFilteredChildNodes(this));
                    if (process.env.NODE_ENV !== 'production' &&
                        isFalse(hasNativeSymbolsSupport$1) &&
                        isExternalChildNodeAccessorFlagOn()) {
                        ArrayUnshift.call(childNodes, getIE11FakeShadowRootPlaceholder(this));
                    }
                    return createStaticNodeList(childNodes);
                }
                return childNodesGetter.call(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedHTMLElement.prototype, "children", {
            get: function () {
                if (hasSyntheticShadow(this)) {
                    if (process.env.NODE_ENV === 'test') {
                        return childrenGetter.call(this);
                    }
                    var owner = getNodeOwner(this);
                    var childNodes = isNull(owner)
                        ? []
                        : getAllMatches(owner, getFilteredChildNodes(this));
                    return createStaticHTMLCollection(ArrayFilter.call(childNodes, function (node) { return node instanceof Element; }));
                }
                return childrenGetter.call(this);
            },
            enumerable: true,
            configurable: true
        });
        return PatchedHTMLElement;
    }(Ctor));
}

var observer;
var observerConfig = { childList: true };
var SlotChangeKey = createFieldName('slotchange');
function initSlotObserver() {
    return new MutationObserver(function (mutations) {
        var slots = [];
        forEach.call(mutations, function (mutation) {
            if (process.env.NODE_ENV !== 'production') {
                assert.isTrue(mutation.type === 'childList', "Invalid mutation type: " + mutation.type + ". This mutation handler for slots should only handle \"childList\" mutations.");
            }
            var slot = mutation.target;
            if (ArrayIndexOf.call(slots, slot) === -1) {
                ArrayPush.call(slots, slot);
                dispatchEvent.call(slot, new CustomEvent('slotchange'));
            }
        });
    });
}
function getFilteredSlotAssignedNodes(slot) {
    var owner = getNodeOwner(slot);
    if (isNull(owner)) {
        return [];
    }
    var childNodes = collectionSlice(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, function (seed, child) {
        if (!isNodeOwnedBy(owner, child)) {
            ArrayPush.call(seed, child);
        }
        return seed;
    }, []);
}
function getFilteredSlotFlattenNodes(slot) {
    var childNodes = collectionSlice(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, function (seed, child) {
        if (child instanceof Element && isSlotElement(child)) {
            ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
        }
        else {
            ArrayPush.call(seed, child);
        }
        return seed;
    }, []);
}
function PatchedSlotElement(elm) {
    var Ctor = PatchedElement(elm);
    var superAddEventListener = elm.addEventListener;
    return  (function (_super) {
        __extends(PatchedHTMLSlotElement, _super);
        function PatchedHTMLSlotElement() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PatchedHTMLSlotElement.prototype.addEventListener = function (type, listener, options) {
            if (type === 'slotchange' && !getInternalField(this, SlotChangeKey)) {
                if (process.env.NODE_ENV === 'test') {
                    console.warn('The "slotchange" event is not supported in our jest test environment.');
                }
                setInternalField(this, SlotChangeKey, true);
                if (!observer) {
                    observer = initSlotObserver();
                }
                MutationObserverObserve.call(observer, this, observerConfig);
            }
            superAddEventListener.call(this, type, listener, options);
        };
        PatchedHTMLSlotElement.prototype.assignedElements = function (options) {
            var flatten = !isUndefined(options) && isTrue(options.flatten);
            var nodes = flatten
                ? getFilteredSlotFlattenNodes(this)
                : getFilteredSlotAssignedNodes(this);
            return ArrayFilter.call(nodes, function (node) { return node instanceof Element; });
        };
        PatchedHTMLSlotElement.prototype.assignedNodes = function (options) {
            var flatten = !isUndefined(options) && isTrue(options.flatten);
            return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
        };
        Object.defineProperty(PatchedHTMLSlotElement.prototype, "name", {
            get: function () {
                var name = getAttribute.call(this, 'name');
                return isNull(name) ? '' : name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedHTMLSlotElement.prototype, "childNodes", {
            get: function () {
                var owner = getNodeOwner(this);
                var childNodes = isNull(owner)
                    ? []
                    : getAllMatches(owner, getFilteredChildNodes(this));
                return createStaticNodeList(childNodes);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedHTMLSlotElement.prototype, "children", {
            get: function () {
                if (process.env.NODE_ENV === 'test') {
                    return childrenGetter.call(this);
                }
                var owner = getNodeOwner(this);
                var childNodes = isNull(owner)
                    ? []
                    : getAllMatches(owner, getFilteredChildNodes(this));
                return createStaticHTMLCollection(ArrayFilter.call(childNodes, function (node) { return node instanceof Element; }));
            },
            enumerable: true,
            configurable: true
        });
        return PatchedHTMLSlotElement;
    }(Ctor));
}

var patchedGetRootNode$1 = Node.prototype.getRootNode;
function getNodeOwner(node) {
    if (!(node instanceof Node)) {
        return null;
    }
    var ownerKey = getNodeNearestOwnerKey(node);
    if (isUndefined(ownerKey)) {
        return null;
    }
    var nodeOwner = node;
    while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
        nodeOwner = parentNodeGetter.call(nodeOwner);
    }
    if (isNull(nodeOwner)) {
        return null;
    }
    return nodeOwner;
}
function isSlotElement(elm) {
    return tagNameGetter.call(elm) === 'SLOT';
}
function isNodeOwnedBy(owner, node) {
    if (process.env.NODE_ENV !== 'production') {
        assert.invariant(owner instanceof HTMLElement, "isNodeOwnedBy() should be called with an element as the first argument instead of " + owner);
        assert.invariant(node instanceof Node, "isNodeOwnedBy() should be called with a node as the second argument instead of " + node);
        assert.isTrue(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS, "isNodeOwnedBy() should never be called with a node that is not a child node of " + owner);
    }
    var ownerKey = getNodeNearestOwnerKey(node);
    return isUndefined(ownerKey) || getNodeKey(owner) === ownerKey;
}
function shadowRootChildNodes(root) {
    var elm = getHost(root);
    return getAllMatches(elm, childNodesGetter.call(elm));
}
function getAllMatches(owner, nodeList) {
    var filteredAndPatched = [];
    for (var i = 0, len = nodeList.length; i < len; i += 1) {
        var node = nodeList[i];
        var isOwned = isNodeOwnedBy(owner, node);
        if (isOwned) {
            ArrayPush.call(filteredAndPatched, node);
        }
    }
    return filteredAndPatched;
}
function getFirstMatch(owner, nodeList) {
    for (var i = 0, len = nodeList.length; i < len; i += 1) {
        if (isNodeOwnedBy(owner, nodeList[i])) {
            return nodeList[i];
        }
    }
    return null;
}
function shadowRootQuerySelector(root, selector) {
    var elm = getHost(root);
    var nodeList = querySelectorAll$1.call(elm, selector);
    return getFirstMatch(elm, nodeList);
}
function shadowRootQuerySelectorAll(root, selector) {
    var elm = getHost(root);
    var nodeList = querySelectorAll$1.call(elm, selector);
    return getAllMatches(elm, nodeList);
}
function getFilteredChildNodes(node) {
    var children;
    if (!isUndefined(getNodeKey(node))) {
        var slots = querySelectorAll$1.call(node, 'slot');
        children = ArrayReduce.call(slots, function (seed, slot) {
            if (isNodeOwnedBy(node, slot)) {
                ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
            }
            return seed;
        }, []);
    }
    else {
        children = childNodesGetter.call(node);
    }
    var owner = getNodeOwner(node);
    if (isNull(owner)) {
        return [];
    }
    return ArrayReduce.call(children, function (seed, child) {
        if (isNodeOwnedBy(owner, child)) {
            ArrayPush.call(seed, child);
        }
        return seed;
    }, []);
}

var OwnerKey = '$$OwnerKey$$';
var OwnKey = '$$OwnKey$$';
var hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';
function getNodeOwnerKey(node) {
    return node[OwnerKey];
}
function setNodeOwnerKey(node, value) {
    if (process.env.NODE_ENV !== 'production') {
        defineProperty(node, OwnerKey, {
            value: value,
            configurable: true,
        });
    }
    else {
        node[OwnerKey] = value;
    }
}
function setNodeKey(node, value) {
    if (process.env.NODE_ENV !== 'production') {
        defineProperty(node, OwnKey, {
            value: value,
        });
    }
    else {
        node[OwnKey] = value;
    }
}
function getNodeNearestOwnerKey(node) {
    var ownerNode = node;
    var ownerKey;
    while (!isNull(ownerNode)) {
        ownerKey = ownerNode[OwnerKey];
        if (!isUndefined(ownerKey)) {
            return ownerKey;
        }
        ownerNode = parentNodeGetter.call(ownerNode);
    }
}
function getNodeKey(node) {
    return node[OwnKey];
}
function isNodeShadowed(node) {
    return !isUndefined(getNodeNearestOwnerKey(node));
}
function getShadowParent(node, value) {
    var owner = getNodeOwner(node);
    if (value === owner) {
        return getShadowRoot(owner);
    }
    else if (value instanceof Element) {
        if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
            return value;
        }
        else if (!isNull(owner) && isSlotElement(value)) {
            var slotOwner = getNodeOwner(value);
            if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
                return slotOwner;
            }
        }
    }
    return null;
}
function PatchedNode(node) {
    var Ctor = getPrototypeOf(node).constructor;
    var PatchedNodeClass =  (function () {
        function PatchedNodeClass() {
            throw new TypeError('Illegal constructor');
        }
        PatchedNodeClass.prototype.hasChildNodes = function () {
            return getInternalChildNodes(this).length > 0;
        };
        Object.defineProperty(PatchedNodeClass.prototype, "firstChild", {
            get: function () {
                var childNodes = getInternalChildNodes(this);
                return childNodes[0] || null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedNodeClass.prototype, "lastChild", {
            get: function () {
                var childNodes = getInternalChildNodes(this);
                return childNodes[childNodes.length - 1] || null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedNodeClass.prototype, "textContent", {
            get: function () {
                return getTextContent(this);
            },
            set: function (value) {
                textContextSetter.call(this, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedNodeClass.prototype, "childElementCount", {
            get: function () {
                return this.children.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedNodeClass.prototype, "firstElementChild", {
            get: function () {
                return this.children[0] || null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedNodeClass.prototype, "lastElementChild", {
            get: function () {
                var children = this.children;
                return children.item(children.length - 1) || null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedNodeClass.prototype, "assignedSlot", {
            get: function () {
                var parentNode = parentNodeGetter.call(this);
                if (isNull(parentNode) ||
                    !isSlotElement(parentNode) ||
                    getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
                    return null;
                }
                return parentNode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedNodeClass.prototype, "parentNode", {
            get: function () {
                var value = parentNodeGetter.call(this);
                if (isNull(value)) {
                    return value;
                }
                return getShadowParent(this, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PatchedNodeClass.prototype, "parentElement", {
            get: function () {
                var value = parentNodeGetter.call(this);
                if (isNull(value)) {
                    return null;
                }
                var parentNode = getShadowParent(this, value);
                return parentNode instanceof Element ? parentNode : null;
            },
            enumerable: true,
            configurable: true
        });
        PatchedNodeClass.prototype.compareDocumentPosition = function (otherNode) {
            if (patchedGetRootNode$1.call(this) === otherNode) {
                return 10;
            }
            else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                return 35;
            }
            return compareDocumentPosition.call(this, otherNode);
        };
        PatchedNodeClass.prototype.contains = function (otherNode) {
            if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                return false;
            }
            return ((compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !==
                0);
        };
        PatchedNodeClass.prototype.cloneNode = function (deep) {
            var clone = cloneNode.call(this, false);
            if (!deep) {
                return clone;
            }
            var childNodes = getInternalChildNodes(this);
            for (var i = 0, len = childNodes.length; i < len; i += 1) {
                clone.appendChild(childNodes[i].cloneNode(true));
            }
            return clone;
        };
        return PatchedNodeClass;
    }());
    setPrototypeOf(PatchedNodeClass, Ctor);
    setPrototypeOf(PatchedNodeClass.prototype, Ctor.prototype);
    return PatchedNodeClass;
}
var internalChildNodeAccessorFlag = false;
function isExternalChildNodeAccessorFlagOn() {
    return !internalChildNodeAccessorFlag;
}
var getInternalChildNodes = process.env.NODE_ENV !== 'production' && isFalse(hasNativeSymbolsSupport$1)
    ? function (node) {
        internalChildNodeAccessorFlag = true;
        var childNodes;
        var error = null;
        try {
            childNodes = node.childNodes;
        }
        catch (e) {
            error = e;
        }
        finally {
            internalChildNodeAccessorFlag = false;
            if (!isNull(error)) {
                throw error;
            }
        }
        return childNodes;
    }
    : function (node) {
        return node.childNodes;
    };

var skipGlobalPatching;
function isGlobalPatchingSkipped(node) {
    if (isUndefined(skipGlobalPatching)) {
        var ownerDocument = getOwnerDocument(node);
        skipGlobalPatching =
            ownerDocument.body.getAttribute('data-global-patching-bypass') === 'temporary-bypass';
    }
    return isTrue(skipGlobalPatching);
}
function apply$2() {
    function elemFromPoint(left, top) {
        var element = elementFromPoint.call(this, left, top);
        if (isNull(element)) {
            return element;
        }
        return retarget(this, pathComposer(element, true));
    }
    Document.prototype.elementFromPoint = elemFromPoint;
    defineProperty(Document.prototype, 'activeElement', {
        get: function () {
            var node = DocumentPrototypeActiveElement.call(this);
            if (isNull(node)) {
                return node;
            }
            while (!isUndefined(getNodeOwnerKey(node))) {
                node = parentElementGetter.call(node);
                if (isNull(node)) {
                    return null;
                }
            }
            if (node.tagName === 'HTML') {
                node = this.body;
            }
            return node;
        },
        enumerable: true,
        configurable: true,
    });
    defineProperty(Document.prototype, 'getElementById', {
        value: function () {
            var elm = getElementById.apply(this, ArraySlice.call(arguments));
            if (isNull(elm)) {
                return null;
            }
            return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(Document.prototype, 'querySelector', {
        value: function () {
            var elements = querySelectorAll.apply(this, ArraySlice.call(arguments));
            var filtered = collectionFind(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
            return !isUndefined(filtered) ? filtered : null;
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(Document.prototype, 'querySelectorAll', {
        value: function () {
            var elements = querySelectorAll.apply(this, ArraySlice.call(arguments));
            var filtered = collectionFilter(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
            return createStaticNodeList(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(Document.prototype, 'getElementsByClassName', {
        value: function () {
            var elements = getElementsByClassName.apply(this, ArraySlice.call(arguments));
            var filtered = collectionFilter(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
            return createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(Document.prototype, 'getElementsByTagName', {
        value: function () {
            var elements = getElementsByTagName.apply(this, ArraySlice.call(arguments));
            var filtered = collectionFilter(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
            return createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(Document.prototype, 'getElementsByTagNameNS', {
        value: function () {
            var elements = getElementsByTagNameNS.apply(this, ArraySlice.call(arguments));
            var filtered = collectionFilter(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
            return createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(
    getOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName')
        ? HTMLDocument.prototype
        : Document.prototype, 'getElementsByName', {
        value: function () {
            var elements = getElementsByName.apply(this, ArraySlice.call(arguments));
            var filtered = collectionFilter(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
            return createStaticNodeList(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
}

{
    apply$2();
}

var skipGlobalPatching$1;
function isGlobalPatchingSkipped$1(node) {
    if (isUndefined(skipGlobalPatching$1)) {
        var ownerDocument = getOwnerDocument(node);
        skipGlobalPatching$1 =
            ownerDocument.body.getAttribute('data-global-patching-bypass') === 'temporary-bypass';
    }
    return isTrue(skipGlobalPatching$1);
}
function apply$3() {
    var HTMLBodyElementPrototype = HTMLBodyElement.prototype;
    defineProperty(HTMLBodyElementPrototype, 'querySelector', {
        value: function () {
            var elements = querySelectorAll$1.apply(this, ArraySlice.call(arguments));
            var ownerKey = getNodeOwnerKey(this);
            var filtered = collectionFind(elements, function (elm) { return getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm); });
            return !isUndefined(filtered) ? filtered : null;
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(HTMLBodyElementPrototype, 'querySelectorAll', {
        value: function () {
            var elements = querySelectorAll$1.apply(this, ArraySlice.call(arguments));
            var ownerKey = getNodeOwnerKey(this);
            var filtered = collectionFilter(elements, function (elm) { return getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm); });
            return createStaticNodeList(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(HTMLBodyElementPrototype, 'getElementsByClassName', {
        value: function () {
            var elements = getElementsByClassName$1.apply(this, ArraySlice.call(arguments));
            var ownerKey = getNodeOwnerKey(this);
            var filtered = collectionFilter(elements, function (elm) { return getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm); });
            return createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(HTMLBodyElementPrototype, 'getElementsByTagName', {
        value: function () {
            var elements = getElementsByTagName$1.apply(this, ArraySlice.call(arguments));
            var ownerKey = getNodeOwnerKey(this);
            var filtered = collectionFilter(elements, function (elm) { return getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm); });
            return createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
    defineProperty(HTMLBodyElementPrototype, 'getElementsByTagNameNS', {
        value: function () {
            var elements = getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments));
            var ownerKey = getNodeOwnerKey(this);
            var filtered = collectionFilter(elements, function (elm) { return getNodeOwnerKey(elm) === ownerKey || isGlobalPatchingSkipped$1(elm); });
            return createStaticHTMLCollection(filtered);
        },
        writable: true,
        enumerable: true,
        configurable: true,
    });
}

{
    apply$3();
}

function apply$4() {
    Object.defineProperty(window, 'ShadowRoot', {
        value: SyntheticShadowRoot,
        configurable: true,
        writable: true,
    });
}

{
    apply$4();
}

var composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');
function detect() {
    if (!composedDescriptor) {
        return false;
    }
    var clickEvent = new Event('click');
    var button = document.createElement('button');
    button.addEventListener('click', function (event) { return (clickEvent = event); });
    button.click();
    return !composedDescriptor.get.call(clickEvent);
}

var originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'click');
function handleClick(event) {
    Object.defineProperty(event, 'composed', {
        configurable: true,
        enumerable: true,
        get: function () {
            return true;
        },
    });
}
function apply$5() {
    HTMLElement.prototype.click = function () {
        addEventListener.call(this, 'click', handleClick);
        try {
            originalClickDescriptor.value.call(this);
        }
        finally {
            removeEventListener.call(this, 'click', handleClick);
        }
    };
}

if (detect()) {
    apply$5();
}

function detect$1() {
    return Object.getOwnPropertyDescriptor(Event.prototype, 'composed') === undefined;
}

function apply$6() {
    var composedEvents = assign(create(null), {
        blur: 1,
        focus: 1,
        focusin: 1,
        focusout: 1,
        click: 1,
        dblclick: 1,
        mousedown: 1,
        mouseenter: 1,
        mouseleave: 1,
        mousemove: 1,
        mouseout: 1,
        mouseover: 1,
        mouseup: 1,
        wheel: 1,
        beforeinput: 1,
        input: 1,
        keydown: 1,
        keyup: 1,
        compositionstart: 1,
        compositionupdate: 1,
        compositionend: 1,
        touchstart: 1,
        touchend: 1,
        touchmove: 1,
        touchcancel: 1,
        pointerover: 1,
        pointerenter: 1,
        pointerdown: 1,
        pointermove: 1,
        pointerup: 1,
        pointercancel: 1,
        pointerout: 1,
        pointerleave: 1,
        gotpointercapture: 1,
        lostpointercapture: 1,
        dragstart: 1,
        drag: 1,
        dragenter: 1,
        dragleave: 1,
        dragover: 1,
        drop: 1,
        dragend: 1,
        DOMActivate: 1,
        DOMFocusIn: 1,
        DOMFocusOut: 1,
        keypress: 1,
    });
    Object.defineProperties(Event.prototype, {
        composed: {
            get: function () {
                var type = this.type;
                return composedEvents[type] === 1;
            },
            configurable: true,
            enumerable: true,
        },
    });
}

if (detect$1()) {
    apply$6();
}

var OriginalCustomEvent = window.CustomEvent;
function PatchedCustomEvent(type, eventInitDict) {
    var event = new OriginalCustomEvent(type, eventInitDict);
    Object.defineProperties(event, {
        composed: {
            get: function () {
                return !!(eventInitDict && eventInitDict.composed);
            },
            configurable: true,
            enumerable: true,
        },
    });
    return event;
}
function apply$7() {
    window.CustomEvent = PatchedCustomEvent;
    window.CustomEvent.prototype = OriginalCustomEvent.prototype;
}

{
    apply$7();
}

function apply$8 () {
    var originalComposedGetter = Object.getOwnPropertyDescriptor(Event.prototype, 'composed')
        .get;
    Object.defineProperties(FocusEvent.prototype, {
        composed: {
            get: function () {
                var isTrusted = this.isTrusted;
                var composed = originalComposedGetter.call(this);
                if (isTrusted && composed === false) {
                    return true;
                }
                return composed;
            },
            enumerable: true,
            configurable: true,
        },
    });
}

{
    apply$8();
}

function detect$2() {
    return typeof HTMLIFrameElement !== 'undefined';
}

function apply$9() {
    var desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');
    var originalGetter = desc.get;
    desc.get = function () {
        var original = originalGetter.call(this);
        if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {
            return original;
        }
        return wrapIframeWindow(original);
    };
    defineProperty(HTMLIFrameElement.prototype, 'contentWindow', desc);
}
function wrapIframeWindow(win) {
    return {
        addEventListener: function () {
            return win.addEventListener.apply(win, arguments);
        },
        blur: function () {
            return win.blur.apply(win, arguments);
        },
        close: function () {
            return win.close.apply(win, arguments);
        },
        focus: function () {
            return win.focus.apply(win, arguments);
        },
        postMessage: function () {
            return win.postMessage.apply(win, arguments);
        },
        removeEventListener: function () {
            return win.removeEventListener.apply(win, arguments);
        },
        get closed() {
            return win.closed;
        },
        get frames() {
            return win.frames;
        },
        get length() {
            return win.length;
        },
        get location() {
            return win.location;
        },
        set location(value) {
            win.location = value;
        },
        get opener() {
            return win.opener;
        },
        get parent() {
            return win.parent;
        },
        get self() {
            return win.self;
        },
        get top() {
            return win.top;
        },
        get window() {
            return win.window;
        },
    };
}

if (detect$2()) {
    apply$9();
}

var OriginalMutationObserver = window.MutationObserver;
var _a$8 = OriginalMutationObserver.prototype, originalDisconnect = _a$8.disconnect, originalObserve = _a$8.observe, originalTakeRecords = _a$8.takeRecords;
var wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
var observerLookupField = '$$lwcNodeObservers$$';
var observerToNodesMap = new WeakMap();
function retargetMutationRecord(originalRecord) {
    var addedNodes = originalRecord.addedNodes, removedNodes = originalRecord.removedNodes, target = originalRecord.target, type = originalRecord.type;
    var retargetedRecord = create(MutationRecord.prototype);
    defineProperties(retargetedRecord, {
        addedNodes: {
            get: function () {
                return addedNodes;
            },
            enumerable: true,
            configurable: true,
        },
        removedNodes: {
            get: function () {
                return removedNodes;
            },
            enumerable: true,
            configurable: true,
        },
        type: {
            get: function () {
                return type;
            },
            enumerable: true,
            configurable: true,
        },
        target: {
            get: function () {
                return target.shadowRoot;
            },
            enumerable: true,
            configurable: true,
        },
    });
    return retargetedRecord;
}
function isQualifiedObserver(observer, target) {
    var parentNode = target;
    while (!isNull(parentNode)) {
        var parentNodeObservers = parentNode[observerLookupField];
        if (!isUndefined(parentNodeObservers) &&
            (parentNodeObservers[0] === observer ||
                ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {
            return true;
        }
        parentNode = parentNode.parentNode;
    }
    return false;
}
function filterMutationRecords(mutations, observer) {
    return ArrayReduce.call(mutations, function (filteredSet, record) {
        var target = record.target, addedNodes = record.addedNodes, removedNodes = record.removedNodes, type = record.type;
        if (type === 'childList' && !isUndefined(getNodeKey(target))) {
            if (addedNodes.length > 0) {
                var sampleNode = addedNodes[0];
                if (isQualifiedObserver(observer, sampleNode)) {
                    if (target[observerLookupField] &&
                        (target[observerLookupField][0] === observer ||
                            ArrayIndexOf.call(target[observerLookupField], observer) !== -1)) {
                        ArrayPush.call(filteredSet, record);
                    }
                    else {
                        ArrayPush.call(filteredSet, retargetMutationRecord(record));
                    }
                }
            }
            else {
                var shadowRoot = target.shadowRoot;
                var sampleNode = removedNodes[0];
                if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) &&
                    isQualifiedObserver(observer, target)
                ) {
                    ArrayPush.call(filteredSet, record);
                }
                else if (shadowRoot &&
                    shadowRoot[observerLookupField] &&
                    (shadowRoot[observerLookupField][0] === observer ||
                        ArrayIndexOf.call(shadowRoot[observerLookupField], observer) !== -1)) {
                    ArrayPush.call(filteredSet, retargetMutationRecord(record));
                }
            }
        }
        else {
            if (isQualifiedObserver(observer, target)) {
                ArrayPush.call(filteredSet, record);
            }
        }
        return filteredSet;
    }, []);
}
function getWrappedCallback(callback) {
    var wrappedCallback = callback[wrapperLookupField];
    if (isUndefined(wrappedCallback)) {
        wrappedCallback = callback[wrapperLookupField] = function (mutations, observer) {
            var filteredRecords = filterMutationRecords(mutations, observer);
            if (filteredRecords.length === 0) {
                return;
            }
            callback.call(observer, filteredRecords, observer);
        };
    }
    return wrappedCallback;
}
function PatchedMutationObserver(callback) {
    var wrappedCallback = getWrappedCallback(callback);
    var observer = new OriginalMutationObserver(wrappedCallback);
    return observer;
}
function patchedDisconnect() {
    var _this = this;
    originalDisconnect.call(this);
    var observedNodes = observerToNodesMap.get(this);
    if (!isUndefined(observedNodes)) {
        forEach.call(observedNodes, function (observedNode) {
            var observers = observedNode[observerLookupField];
            if (!isUndefined(observers)) {
                var index = ArrayIndexOf.call(observers, _this);
                if (index !== -1) {
                    ArraySplice.call(observers, index, 1);
                }
            }
        });
        observedNodes.length = 0;
    }
}
function patchedObserve(target, options) {
    if (isUndefined(target[observerLookupField])) {
        defineProperty(target, observerLookupField, { value: [] });
    }
    if (ArrayIndexOf.call(target[observerLookupField], this) === -1) {
        ArrayPush.call(target[observerLookupField], this);
    }
    if (target instanceof SyntheticShadowRoot) {
        target = target.host;
    }
    if (observerToNodesMap.has(this)) {
        var observedNodes = observerToNodesMap.get(this);
        if (ArrayIndexOf.call(observedNodes, target) === -1) {
            ArrayPush.call(observedNodes, target);
        }
    }
    else {
        observerToNodesMap.set(this, [target]);
    }
    return originalObserve.call(this, target, options);
}
function patchedTakeRecords() {
    return filterMutationRecords(originalTakeRecords.call(this), this);
}
PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
PatchedMutationObserver.prototype.observe = patchedObserve;
PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
function apply$a() {
    defineProperty(window, 'MutationObserver', {
        value: PatchedMutationObserver,
        configurable: true,
        writable: true,
    });
}

{
    apply$a();
}

var ShadowTokenPrivateKey = '$$ShadowTokenKey$$';
function getShadowToken(node) {
    return node.$shadowToken$;
}
function setShadowToken(node, shadowToken) {
    node.$shadowToken$ = shadowToken;
}
defineProperty(Element.prototype, '$shadowToken$', {
    set: function (shadowToken) {
        var oldShadowToken = this[ShadowTokenPrivateKey];
        if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
            removeAttribute.call(this, oldShadowToken);
        }
        if (!isUndefined(shadowToken)) {
            setAttribute.call(this, shadowToken, '');
        }
        this[ShadowTokenPrivateKey] = shadowToken;
    },
    get: function () {
        return this[ShadowTokenPrivateKey];
    },
    configurable: true,
});

var MutationObserver$1 = window.MutationObserver;
var MutationObserverObserve$1 = MutationObserver$1.prototype.observe;
var DomManualPrivateKey = '$$DomManualKey$$';
var portalObserver;
var portalObserverConfig = {
    childList: true,
    subtree: true,
};
function adoptChildNode(node, fn, shadowToken) {
    if (getShadowRootResolver(node) === fn) {
        return;
    }
    setShadowRootResolver(node, fn);
    if (node instanceof Element) {
        setShadowToken(node, shadowToken);
        var childNodes = getInternalChildNodes(node);
        for (var i = 0, len = childNodes.length; i < len; i += 1) {
            var child = childNodes[i];
            adoptChildNode(child, fn, shadowToken);
        }
    }
}
function initPortalObserver() {
    return new MutationObserver$1(function (mutations) {
        forEach.call(mutations, function (mutation) {
            var elm = mutation.target, addedNodes = mutation.addedNodes;
            var fn = getShadowRootResolver(elm);
            var shadowToken = getShadowToken(elm);
            for (var i = 0, len = addedNodes.length; i < len; i += 1) {
                var node = addedNodes[i];
                adoptChildNode(node, fn, shadowToken);
            }
        });
    });
}
function markElementAsPortal(elm) {
    if (isUndefined(portalObserver)) {
        portalObserver = initPortalObserver();
    }
    if (isUndefined(getShadowRootResolver(elm))) {
        throw new Error("Invalid Element");
    }
    MutationObserverObserve$1.call(portalObserver, elm, portalObserverConfig);
}
defineProperty(Element.prototype, '$domManual$', {
    set: function (v) {
        this[DomManualPrivateKey] = v;
        if (isTrue(v)) {
            markElementAsPortal(this);
        }
    },
    get: function () {
        return this[DomManualPrivateKey];
    },
    configurable: true,
});

Element.prototype.$lwcPolyfill$ = {
    PatchedNode: PatchedNode,
    PatchedElement: PatchedElement,
    PatchedSlotElement: PatchedSlotElement,
};
/** version: 1.0.2-222.23 */
