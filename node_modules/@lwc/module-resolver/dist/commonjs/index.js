"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/* eslint-env node */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fast_glob_1 = __importDefault(require("fast-glob"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const node_modules_paths_1 = __importDefault(require("./node-modules-paths"));
const DEFAULT_IGNORE = ['**/node_modules/**', '**/__tests__/**'];
const PACKAGE_PATTERN = ['*/*/package.json', '*/package.json', 'package.json'];
const MODULE_ENTRY_PATTERN = `**/*.([jt]s|html|css)`;
const LWC_CONFIG_FILE = '.lwcrc';
function createRegistryEntry(entry, moduleSpecifier, moduleName, moduleNamespace) {
    return { entry, moduleSpecifier, moduleName, moduleNamespace };
}
function loadLwcConfig(modulePath) {
    const packageJsonPath = path_1.default.join(modulePath, 'package.json');
    const lwcConfigPath = path_1.default.join(modulePath, LWC_CONFIG_FILE);
    let config;
    try {
        config = JSON.parse(fs_1.default.readFileSync(lwcConfigPath, 'utf8'));
    }
    catch (ignore) {
        // ignore
    }
    if (!config) {
        try {
            config = JSON.parse(fs_1.default.readFileSync(packageJsonPath, 'utf8')).lwc;
        }
        catch (ignore) {
            // ignore
        }
    }
    return config;
}
function resolveModulesInDir(absPath) {
    return fast_glob_1.default
        .sync(MODULE_ENTRY_PATTERN, {
        cwd: absPath,
        transform: entry => typeof entry === 'string' ? { path: entry } : { path: entry.path },
    })
        .reduce((mappings, { path: file }) => {
        const ext = path_1.default.extname(file);
        const fileName = path_1.default.basename(file, ext);
        const rootDir = path_1.default.dirname(file);
        const rootParts = rootDir.split('/'); // the glob library normalizes paths to forward slashes only - https://github.com/isaacs/node-glob#windows
        const entry = path_1.default.join(absPath, file);
        const dirModuleName = rootParts.pop();
        const dirModuleNamespace = rootParts.pop();
        if (dirModuleNamespace && dirModuleName === fileName) {
            const registryNode = createRegistryEntry(entry, `${dirModuleNamespace}/${fileName}`, fileName, dirModuleNamespace.toLowerCase());
            mappings[registryNode.moduleSpecifier] = registryNode;
        }
        return mappings;
    }, {});
}
exports.resolveModulesInDir = resolveModulesInDir;
function hasModuleBeenVisited(module, visited) {
    if (visited.has(module)) {
        /* eslint-disable-next-line no-console */
        console.log(`Package ${module} already resolved`);
        return true;
    }
    return false;
}
function expandModuleDirectories({ moduleDirectories, rootDir, modulePaths, } = {}) {
    if (modulePaths) {
        return modulePaths;
    }
    if (!moduleDirectories && !rootDir) {
        // paths() is spec'd to return null only for built-in node
        // modules like 'http'. To be safe, return empty array in
        // instead of null in this case.
        return require.resolve.paths('.') || [];
    }
    return node_modules_paths_1.default(rootDir || __dirname, moduleDirectories);
}
function resolveModules(modules, opts) {
    if (Array.isArray(modules)) {
        modules.forEach(modulePath => resolveModules(modulePath, opts));
    }
    else {
        const { mappings, visited, moduleRoot } = opts;
        if (typeof modules === 'string') {
            const packageEntries = resolveModulesInDir(path_1.default.join(moduleRoot, modules));
            Object.keys(packageEntries).forEach(moduleName => {
                if (!hasModuleBeenVisited(moduleName, visited)) {
                    mappings[moduleName] = packageEntries[moduleName];
                    visited.add(moduleName);
                }
            });
        }
        else {
            Object.keys(modules).forEach(moduleName => {
                if (!hasModuleBeenVisited(moduleName, visited)) {
                    const modulePath = path_1.default.join(moduleRoot, modules[moduleName]);
                    mappings[moduleName] = { moduleSpecifier: moduleName, entry: modulePath };
                    visited.add(moduleName);
                }
            });
        }
    }
}
function resolveLwcNpmModules(options = {}) {
    const visited = new Set();
    const modulePaths = expandModuleDirectories(options);
    return modulePaths.reduce((m, nodeModulesDir) => {
        return fast_glob_1.default
            .sync(PACKAGE_PATTERN, {
            cwd: nodeModulesDir,
            ignore: options.ignorePatterns || DEFAULT_IGNORE,
            transform: entry => typeof entry === 'string' ? { path: entry } : { path: entry.path },
        })
            .reduce((mappings, { path: file }) => {
            const moduleRoot = path_1.default.dirname(path_1.default.join(nodeModulesDir, file));
            const lwcConfig = loadLwcConfig(moduleRoot);
            if (lwcConfig) {
                resolveModules(lwcConfig.modules, { mappings, visited, moduleRoot, lwcConfig });
            }
            return mappings;
        }, m);
    }, {});
}
exports.resolveLwcNpmModules = resolveLwcNpmModules;
//# sourceMappingURL=index.js.map