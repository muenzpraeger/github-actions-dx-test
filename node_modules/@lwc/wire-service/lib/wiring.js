"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("./assert"));
const constants_1 = require("./constants");
const property_trap_1 = require("./property-trap");
const value_changed_event_1 = require("./value-changed-event");
const link_context_event_1 = require("./link-context-event");
function removeListener(listeners, toRemove) {
    const idx = listeners.indexOf(toRemove);
    if (idx > -1) {
        listeners.splice(idx, 1);
    }
}
function removeConfigListener(configListenerMetadatas, toRemove) {
    for (let i = 0, len = configListenerMetadatas.length; i < len; i++) {
        if (configListenerMetadatas[i].listener === toRemove) {
            configListenerMetadatas.splice(i, 1);
            return;
        }
    }
}
function buildReactiveParameter(reference) {
    if (!reference.includes('.')) {
        return {
            reference,
            head: reference,
        };
    }
    const segments = reference.split('.');
    return {
        reference,
        head: segments.shift(),
        tail: segments,
    };
}
class WireEventTarget {
    constructor(cmp, def, context, wireDef, wireTarget) {
        this._cmp = cmp;
        this._def = def;
        this._context = context;
        this._wireDef = wireDef;
        this._wireTarget = wireTarget;
    }
    addEventListener(type, listener) {
        switch (type) {
            case constants_1.CONNECT: {
                const connectedListeners = this._context[constants_1.CONTEXT_ID][constants_1.CONTEXT_CONNECTED];
                if (process.env.NODE_ENV !== 'production') {
                    assert_1.default.isFalse(connectedListeners.includes(listener), 'must not call addEventListener("connect") with the same listener');
                }
                connectedListeners.push(listener);
                break;
            }
            case constants_1.DISCONNECT: {
                const disconnectedListeners = this._context[constants_1.CONTEXT_ID][constants_1.CONTEXT_DISCONNECTED];
                if (process.env.NODE_ENV !== 'production') {
                    assert_1.default.isFalse(disconnectedListeners.includes(listener), 'must not call addEventListener("disconnect") with the same listener');
                }
                disconnectedListeners.push(listener);
                break;
            }
            case constants_1.CONFIG: {
                const reactives = this._wireDef.params;
                const statics = this._wireDef.static;
                let reactiveKeys;
                // no reactive parameters. fire config once with static parameters (if present).
                if (!reactives || (reactiveKeys = Object.keys(reactives)).length === 0) {
                    const config = statics || Object.create(null);
                    listener.call(undefined, config);
                    return;
                }
                const configListenerMetadata = {
                    listener,
                    statics,
                    reactives,
                };
                // setup listeners for all reactive parameters
                const configContext = this._context[constants_1.CONTEXT_ID][constants_1.CONTEXT_UPDATED];
                reactiveKeys.forEach(key => {
                    const reactiveParameter = buildReactiveParameter(reactives[key]);
                    let configListenerMetadatas = configContext.listeners[reactiveParameter.head];
                    if (!configListenerMetadatas) {
                        configListenerMetadatas = [configListenerMetadata];
                        configContext.listeners[reactiveParameter.head] = configListenerMetadatas;
                        property_trap_1.installTrap(this._cmp, reactiveParameter, configContext);
                    }
                    else {
                        configListenerMetadatas.push(configListenerMetadata);
                    }
                    // enqueue to pickup default values
                    property_trap_1.updated(this._cmp, reactiveParameter, configContext);
                });
                break;
            }
            default:
                throw new Error(`unsupported event type ${type}`);
        }
    }
    removeEventListener(type, listener) {
        switch (type) {
            case constants_1.CONNECT: {
                const connectedListeners = this._context[constants_1.CONTEXT_ID][constants_1.CONTEXT_CONNECTED];
                removeListener(connectedListeners, listener);
                break;
            }
            case constants_1.DISCONNECT: {
                const disconnectedListeners = this._context[constants_1.CONTEXT_ID][constants_1.CONTEXT_DISCONNECTED];
                removeListener(disconnectedListeners, listener);
                break;
            }
            case constants_1.CONFIG: {
                const paramToConfigListenerMetadata = this._context[constants_1.CONTEXT_ID][constants_1.CONTEXT_UPDATED]
                    .listeners;
                const reactives = this._wireDef.params;
                if (reactives) {
                    Object.keys(reactives).forEach(key => {
                        const reactiveParameter = buildReactiveParameter(reactives[key]);
                        const configListenerMetadatas = paramToConfigListenerMetadata[reactiveParameter.head];
                        if (configListenerMetadatas) {
                            removeConfigListener(configListenerMetadatas, listener);
                        }
                    });
                }
                break;
            }
            default:
                throw new Error(`unsupported event type ${type}`);
        }
    }
    dispatchEvent(evt) {
        if (evt instanceof value_changed_event_1.ValueChangedEvent) {
            const value = evt.value;
            if (this._wireDef.method) {
                this._cmp[this._wireTarget](value);
            }
            else {
                this._cmp[this._wireTarget] = value;
            }
            return false; // canceling signal since we don't want this to propagate
        }
        else if (evt instanceof link_context_event_1.LinkContextEvent) {
            const { uid, callback } = evt;
            // This event is responsible for connecting the host element with another
            // element in the composed path that is providing contextual data. The provider
            // must be listening for a special dom event with the name corresponding to `uid`,
            // which must remain secret, to guarantee that the linkage is only possible via
            // the corresponding wire adapter.
            const internalDomEvent = new CustomEvent(uid, {
                bubbles: true,
                composed: true,
                // avoid leaking the callback function directly to prevent a side channel
                // during the linking phase to the context provider.
                detail(...args) {
                    callback(...args);
                },
            });
            this._cmp.dispatchEvent(internalDomEvent);
            return false; // canceling signal since we don't want this to propagate
        }
        else if (evt.type === 'WireContextEvent') {
            // TODO: issue #1357 - remove this branch
            return this._cmp.dispatchEvent(evt);
        }
        else {
            throw new Error(`Invalid event ${evt}.`);
        }
    }
}
exports.WireEventTarget = WireEventTarget;
//# sourceMappingURL=wiring.js.map