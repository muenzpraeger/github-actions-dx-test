"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * The @wire service.
 *
 * Provides data binding between wire adapters and LWC components decorated with @wire.
 * Register wire adapters with `register(adapterId: any, adapterFactory: WireAdapterFactory)`.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("./assert"));
const constants_1 = require("./constants");
const wiring_1 = require("./wiring");
const value_changed_event_1 = require("./value-changed-event");
exports.ValueChangedEvent = value_changed_event_1.ValueChangedEvent;
const link_context_event_1 = require("./link-context-event");
exports.LinkContextEvent = link_context_event_1.LinkContextEvent;
// wire adapters: wire adapter id => adapter ctor
const adapterFactories = new Map();
/**
 * Invokes the specified callbacks.
 * @param listeners functions to call
 */
function invokeListener(listeners) {
    for (let i = 0, len = listeners.length; i < len; ++i) {
        listeners[i].call(undefined);
    }
}
/**
 * The wire service.
 *
 * This service is registered with the engine's service API. It connects service
 * callbacks to wire adapter lifecycle events.
 */
const wireService = {
    wiring: (cmp, data, def, context) => {
        const wireContext = (context[constants_1.CONTEXT_ID] = Object.create(null));
        wireContext[constants_1.CONTEXT_CONNECTED] = [];
        wireContext[constants_1.CONTEXT_DISCONNECTED] = [];
        wireContext[constants_1.CONTEXT_UPDATED] = { listeners: {}, values: {} };
        // engine guarantees invocation only if def.wire is defined
        const wireStaticDef = def.wire;
        const wireTargets = Object.keys(wireStaticDef);
        for (let i = 0, len = wireTargets.length; i < len; i++) {
            const wireTarget = wireTargets[i];
            const wireDef = wireStaticDef[wireTarget];
            const adapterFactory = adapterFactories.get(wireDef.adapter);
            if (process.env.NODE_ENV !== 'production') {
                assert_1.default.isTrue(wireDef.adapter, `@wire on "${wireTarget}": adapter id must be truthy`);
                assert_1.default.isTrue(adapterFactory, `@wire on "${wireTarget}": unknown adapter id: ${String(wireDef.adapter)}`);
                // enforce restrictions of reactive parameters
                if (wireDef.params) {
                    Object.keys(wireDef.params).forEach(param => {
                        const prop = wireDef.params[param];
                        const segments = prop.split('.');
                        segments.forEach(segment => {
                            assert_1.default.isTrue(segment.length > 0, `@wire on "${wireTarget}": reactive parameters must not be empty`);
                        });
                        assert_1.default.isTrue(segments[0] !== wireTarget, `@wire on "${wireTarget}": reactive parameter "${segments[0]}" must not refer to self`);
                        // restriction for dot-notation reactive parameters
                        if (segments.length > 1) {
                            // @wire emits a stream of immutable values. an emit sets the target property; it does not mutate a previously emitted value.
                            // restricting dot-notation reactive parameters to reference other @wire targets makes trapping the 'head' of the parameter
                            // sufficient to observe the value change.
                            assert_1.default.isTrue(wireTargets.includes(segments[0]) &&
                                wireStaticDef[segments[0]].method !== 1, `@wire on "${wireTarget}": dot-notation reactive parameter "${prop}" must refer to a @wire property`);
                        }
                    });
                }
            }
            if (adapterFactory) {
                const wireEventTarget = new wiring_1.WireEventTarget(cmp, def, context, wireDef, wireTarget);
                adapterFactory({
                    dispatchEvent: wireEventTarget.dispatchEvent.bind(wireEventTarget),
                    addEventListener: wireEventTarget.addEventListener.bind(wireEventTarget),
                    removeEventListener: wireEventTarget.removeEventListener.bind(wireEventTarget),
                });
            }
        }
    },
    connected: (cmp, data, def, context) => {
        let listeners;
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isTrue(!def.wire || context[constants_1.CONTEXT_ID], 'wire service was not initialized prior to component creation:  "connected" service hook invoked without necessary context');
        }
        if (!def.wire || !(listeners = context[constants_1.CONTEXT_ID][constants_1.CONTEXT_CONNECTED])) {
            return;
        }
        invokeListener(listeners);
    },
    disconnected: (cmp, data, def, context) => {
        let listeners;
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isTrue(!def.wire || context[constants_1.CONTEXT_ID], 'wire service was not initialized prior to component creation:  "disconnected" service hook invoked without necessary context');
        }
        if (!def.wire || !(listeners = context[constants_1.CONTEXT_ID][constants_1.CONTEXT_DISCONNECTED])) {
            return;
        }
        invokeListener(listeners);
    },
};
/**
 * Registers the wire service.
 */
function registerWireService(registerService) {
    registerService(wireService);
}
exports.registerWireService = registerWireService;
/**
 * Registers a wire adapter.
 */
function register(adapterId, adapterFactory) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(adapterId, 'adapter id must be truthy');
        assert_1.default.isTrue(typeof adapterFactory === 'function', 'adapter factory must be a callable');
    }
    adapterFactories.set(adapterId, adapterFactory);
}
exports.register = register;
//# sourceMappingURL=index.js.map