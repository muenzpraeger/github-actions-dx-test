"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const types = __importStar(require("@babel/types"));
const traverse_1 = __importDefault(require("@babel/traverse"));
const constants_1 = require("./constants");
const ir_1 = require("./ir");
/**
 * Rewrite member expressions in function body that are referencing iterator.
 * - function (iteratorIndex) { iterator.index } -> function (iteratorIndex) { iteratorIndex }
 */
function rewriteIteratorToArguments(expression, identifier, argNames) {
    traverse_1.default(expression, {
        noScope: true,
        MemberExpression(path) {
            const memberNode = path.node;
            const memberObject = memberNode.object;
            const memberProperty = memberNode.property;
            const rewrite = memberObject.name === identifier.name;
            if (rewrite && argNames[memberProperty.name]) {
                path.replaceWith(argNames[memberProperty.name]);
            }
        },
    });
    return {
        expression,
    };
}
exports.rewriteIteratorToArguments = rewriteIteratorToArguments;
/**
 * Bind the passed expression to the component instance. It applies the following transformation to the expression:
 * - {value} --> {$cmp.value}
 * - {value[state.index]} --> {$cmp.value[$cmp.index]}
 */
function bindExpression(expression, node, applyBinding = true) {
    const wrappedExpression = types.expressionStatement(expression);
    const boundIdentifiers = new Set();
    traverse_1.default(wrappedExpression, {
        noScope: true,
        Identifier(path) {
            const identifierNode = path.node;
            let shouldBind = false;
            if (types.isMemberExpression(path.parent)) {
                // If identifier is the 'object' of the member expression we can safely deduce,
                // the current identifier is the left most identifier of the expression
                shouldBind = path.parent.object === identifierNode;
            }
            else if (types.isExpressionStatement(path.parent)) {
                // In case the template expression is only composed of an identifier, we check
                // if the wrapper expression is the direct parent
                shouldBind = path.parent.expression === identifierNode;
            }
            // Checks if the identifier is a component property
            if (shouldBind && ir_1.isComponentProp(identifierNode, node)) {
                // Need to skip children once bounded, because the replaceWith call will creates
                // an infinite loop
                path.skip();
                if (applyBinding) {
                    const boundedExpression = types.memberExpression(types.identifier(constants_1.TEMPLATE_PARAMS.INSTANCE), identifierNode);
                    path.replaceWith(boundedExpression);
                }
                // Save the bounded identifier
                boundIdentifiers.add(identifierNode.name);
            }
        },
    });
    return {
        expression: wrappedExpression.expression,
        bounded: Array.from(boundIdentifiers),
    };
}
exports.bindExpression = bindExpression;
//# sourceMappingURL=scope.js.map